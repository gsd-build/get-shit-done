---
phase: 06-multi-stack-analyzer
plan: 04
type: execute
wave: 3
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - commands/gsd/analyze-codebase.md
  - hooks/gsd-intel-index.js
autonomous: true

must_haves:
  truths:
    - "Step 0 calls detect-stacks.js and receives JSON with detected stacks"
    - "Step 0.5 spawns gsd-intel-stack-analyzer subagent for each detected stack"
    - "Orchestrator context stays lightweight (~50-100 tokens for stack handling)"
    - "Merged results from subagents feed into existing Steps 1-9"
    - "index.json v2 includes stack field per file"
  artifacts:
    - path: "commands/gsd/analyze-codebase.md"
      provides: "Updated orchestrator with multi-stack support"
      contains: "Step 0"
    - path: "hooks/gsd-intel-index.js"
      provides: "PostToolUse hook with stack field extraction"
      contains: "stack"
  key_links:
    - from: "commands/gsd/analyze-codebase.md"
      to: "hooks/lib/detect-stacks.js"
      via: "Step 0 bash invocation"
      pattern: "detect-stacks.js"
    - from: "commands/gsd/analyze-codebase.md"
      to: "agents/gsd-intel-stack-analyzer.md"
      via: "Step 0.5 Task() spawning"
      pattern: "gsd-intel-stack-analyzer"
---

# Plan 06-04: Lightweight Orchestrator Update

<objective>
Update `commands/gsd/analyze-codebase.md` to integrate multi-stack detection and per-stack analysis via subagents. Add Step 0 (detection) and Step 0.5 (per-stack subagent spawning).

Purpose: Keep the orchestrator lightweight by delegating heavy analysis to subagents. The orchestrator receives only compact JSON summaries (~50 tokens per stack), preserving context for subsequent steps.

Output:
- Updated `commands/gsd/analyze-codebase.md` (add ~100 lines)
- Updated `hooks/gsd-intel-index.js` (add stack field extraction, ~20 lines)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-multi-stack-analyzer/06-RESEARCH.md
@commands/gsd/analyze-codebase.md
@hooks/gsd-intel-index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Step 0 (Stack Detection) to analyze-codebase.md</name>
  <files>commands/gsd/analyze-codebase.md</files>
  <action>
Insert Step 0 at the beginning of the process section (before current Step 1).

**Location:** After the `<process>` tag, before `## Step 1: Create directory structure`

**New Step 0:**
```markdown
## Step 0: Detect programming stacks

Run stack detection to identify all languages and frameworks in the codebase:

```bash
node hooks/lib/detect-stacks.js "$(pwd)" json > /tmp/gsd-stacks.json
cat /tmp/gsd-stacks.json
```

Parse the JSON result to get:
- `detected[]` - Array of detected stacks with confidence scores
- `primary` - The dominant stack (highest confidence)
- `isPolyglot` - Boolean indicating multiple stacks detected
- `stackCount` - Number of stacks above threshold

**Decision logic:**
- If `stackCount` is 0: Fall back to default JS/TS patterns (current behavior)
- If `stackCount` is 1: Use single stack's globs and patterns
- If `stackCount` > 1 (polyglot): Spawn subagent per stack in Step 0.5

Store detected stacks for use in subsequent steps. Primary stack determines conventions priority.
```

**Also update the command description in the frontmatter** to mention multi-stack support:
```yaml
description: Scan existing codebase and populate .planning/intel/ with file index, conventions, and semantic entity files. Supports 35+ programming languages with automatic stack detection.
```
  </action>
  <verify>
```bash
# Check Step 0 exists
grep -n "## Step 0" commands/gsd/analyze-codebase.md

# Verify detect-stacks.js reference
grep "detect-stacks.js" commands/gsd/analyze-codebase.md
```
  </verify>
  <done>Step 0 added to analyze-codebase.md with stack detection logic</done>
</task>

<task type="auto">
  <name>Task 2: Add Step 0.5 (Per-Stack Subagent Spawning)</name>
  <files>commands/gsd/analyze-codebase.md</files>
  <action>
Insert Step 0.5 between Step 0 and the renamed Step 1.

**New Step 0.5:**
```markdown
## Step 0.5: Analyze each stack (if polyglot)

If `isPolyglot` is true OR `stackCount` > 1, spawn a subagent for each detected stack:

For each stack in `detected[]`:

```python
Task(
    prompt=f"""Analyze the {stack.name} stack in this codebase.

**Stack ID:** {stack.stack}
**Project root:** {project_root}
**Confidence:** {stack.confidence}%
**Frameworks detected:** {stack.frameworks}

**Your job:**
1. Load profile: `node hooks/lib/get-stack-profile.js {stack.stack}`
2. Find files matching profile globs (up to 100 files)
3. Extract exports using profile's export_patterns
4. Extract imports using profile's import_patterns
5. Detect naming conventions from actual code
6. Return JSON summary (not file contents)

Return ONLY JSON with: stack, files_analyzed, exports_found, imports_found, exports_by_type, naming_observed, directories, frameworks_confirmed
""",
    subagent_type="gsd-intel-stack-analyzer"
)
```

**Wait for all subagents to complete.** Each runs in parallel with fresh 200k context.

**Merge results:**
- Combine exports from all stacks into unified index
- Store per-stack conventions (nested structure)
- Track which files belong to which stack

If single-stack (not polyglot), skip Step 0.5 and use primary stack directly in Step 2.
```

**Note:** Ensure Task() syntax matches the existing pattern used in Step 9 for gsd-entity-generator.
  </action>
  <verify>
```bash
# Check Step 0.5 exists
grep -n "## Step 0.5" commands/gsd/analyze-codebase.md

# Verify subagent reference
grep "gsd-intel-stack-analyzer" commands/gsd/analyze-codebase.md

# Verify Task() invocation pattern
grep -A 5 "Task(" commands/gsd/analyze-codebase.md | head -20
```
  </verify>
  <done>Step 0.5 added with per-stack subagent spawning logic</done>
</task>

<task type="auto">
  <name>Task 3: Update gsd-intel-index.js for stack field extraction</name>
  <files>hooks/gsd-intel-index.js</files>
  <action>
Update the PostToolUse hook to extract and store the `stack` field from entity frontmatter.

**Locate the `parseEntityFrontmatter` function (around line 586-601).**

The function already parses frontmatter into key-value pairs. Ensure the `stack` field is included in the extracted data.

**Update the graph schema (if needed):**
In the entity node creation, ensure `stack` field is stored:

```javascript
// In the function that creates/updates entity nodes
// Around where path, type, updated, status are stored
// Add stack field extraction

const frontmatter = parseEntityFrontmatter(content);
const entityData = {
  path: frontmatter.path,
  type: frontmatter.type,
  updated: frontmatter.updated,
  status: frontmatter.status,
  stack: frontmatter.stack || null,  // NEW: Add stack field
  framework: frontmatter.framework || null  // NEW: Add framework field (optional)
};
```

**Update index.json v2 schema (in regenerateIndex or similar):**
When writing files to index.json, include stack if available:

```javascript
index.files[filePath] = {
  exports: [...],
  imports: [...],
  indexed: Date.now(),
  stack: detectedStack || null  // NEW: Add stack field
};
```

**Key locations to modify:**
1. `parseEntityFrontmatter` - Already handles generic key-value extraction (no change needed)
2. Entity node creation in graph - Add `stack` and `framework` fields
3. Index.json regeneration - Include `stack` field per file
4. Add `version: 2` to index.json schema when stacks are present

**Backward compatibility:**
- If `stack` field is missing, treat as null (don't break on old entities)
- Keep `version: 1` for index.json if no stacks detected
- Bump to `version: 2` when stacks are present
  </action>
  <verify>
```bash
# Check stack field handling in hook
grep -n "stack" hooks/gsd-intel-index.js | head -20

# Verify parseEntityFrontmatter function
grep -A 20 "parseEntityFrontmatter" hooks/gsd-intel-index.js | head -25
```
  </verify>
  <done>gsd-intel-index.js updated to extract and store stack field from entity frontmatter</done>
</task>

</tasks>

<verification>
- [ ] Step 0 added before Step 1 in analyze-codebase.md
- [ ] Step 0 calls detect-stacks.js and parses JSON output
- [ ] Step 0.5 spawns gsd-intel-stack-analyzer for each detected stack
- [ ] Task() invocation follows existing pattern from Step 9
- [ ] gsd-intel-index.js extracts stack field from entity frontmatter
- [ ] Index.json v2 schema documented with stack field
- [ ] Backward compatibility maintained (missing stack = null)
</verification>

<success_criteria>
- analyze-codebase.md has Step 0 (detection) and Step 0.5 (per-stack analysis)
- Orchestrator context stays lightweight (~50-100 tokens for stack handling)
- detect-stacks.js is invoked via Bash
- gsd-intel-stack-analyzer subagents are spawned per detected stack
- gsd-intel-index.js stores stack field in graph nodes and index.json
- Single-stack codebases still work (skip Step 0.5, use primary stack)
</success_criteria>

<output>
After completion, create `.planning/phases/06-multi-stack-analyzer/06-04-SUMMARY.md`
</output>
