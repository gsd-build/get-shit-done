---
phase: 07-autonomous-execution-optimization
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/completion-signal.js
  - get-shit-done/bin/gsd-tools.js
  - get-shit-done/agents/gsd-phase-coordinator.md
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Sub-coordinators return structured completion signals (success/failure/blocked/skipped)"
    - "Completion signals include tokens used, files modified, and next steps"
    - "Failed signals include retry options and error details"
    - "Blocked signals indicate dependency or user input requirements"
  artifacts:
    - path: "get-shit-done/bin/completion-signal.js"
      provides: "Structured completion signal format for multi-agent coordination"
      exports: ["CompletionSignal", "COMPLETION_STATUS"]
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "CLI commands for completion signal creation"
      contains: "completion"
  key_links:
    - from: "gsd-phase-coordinator.md"
      to: "completion-signal.js"
      via: "import and use for return signals"
      pattern: "CompletionSignal"
    - from: "execute-roadmap.md"
      to: "completion signals"
      via: "handle phase completion signals"
      pattern: "handleCompletionSignal"
---

<objective>
Structured Completion Signals for Sub-Coordinators

Purpose: Enable reliable multi-agent coordination by standardizing how sub-coordinators report completion status. Signals include success/failure/blocked/skipped status with rich context for decision-making.

Output: completion-signal.js module with signal creation helpers and CLI integration
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-autonomous-execution-optimization/07-RESEARCH.md

# Phase 6 foundation
@get-shit-done/bin/gsd-tools.js
@get-shit-done/bin/execution-log.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create completion-signal.js module</name>
  <files>get-shit-done/bin/completion-signal.js</files>
  <action>
Create CompletionSignal class and status constants:

1. COMPLETION_STATUS constant:
   - SUCCESS: 'success'
   - FAILURE: 'failure'
   - BLOCKED: 'blocked'
   - SKIPPED: 'skipped'

2. CompletionSignal class:
   Constructor(status, phase, details = {}):
   - this.status = status
   - this.phase = phase
   - this.timestamp = new Date().toISOString()
   - this.details = { tokensUsed, filesModified, checkpoints, errors, nextSteps, ...details }

Static factory methods:
- success(phase, details): Create success signal
  - Include nextPhaseReady: true
  - Include tokensUsed, filesModified, checkpoints, verificationStatus

- failure(phase, error, options = {}): Create failure signal
  - Include error.message, error.stack
  - Include retryable (default true), retryOptions (maxRetries, backoffMs)
  - Include skipOption (default true), escalateOption

- blocked(phase, reason, details = {}): Create blocked signal
  - Include reason
  - Include blockingDependencies array
  - Include userInputRequired boolean
  - Include estimatedUnblockTime if applicable

- skipped(phase, reason): Create skipped signal
  - Include reason
  - Include incomplete: true
  - Include affectedPhases array (to be populated by caller)

Instance methods:
- isTerminal(): Return true if status is BLOCKED and userInputRequired
- canRetry(): Return true if status is FAILURE and retryable
- toJSON(): Serialize for logging

Export: { CompletionSignal, COMPLETION_STATUS }

Follow Pattern 5 from 07-RESEARCH.md for implementation details.
  </action>
  <verify>node -e "const cs = require('./get-shit-done/bin/completion-signal.js'); const s = cs.CompletionSignal.success(6, {tokensUsed: 50000}); console.log(s.status, s.details.tokensUsed); const f = cs.CompletionSignal.failure(6, new Error('test')); console.log(f.canRetry())"</verify>
  <done>CompletionSignal class exports success/failure/blocked/skipped factory methods with proper status handling</done>
</task>

<task type="auto">
  <name>Task 2: Add completion commands to gsd-tools.js</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add completion-signal require at top of gsd-tools.js:
const { CompletionSignal, COMPLETION_STATUS } = require('./completion-signal.js');

Add completion command handler in switch statement:

case 'completion':
  Handle subcommands:

  1. 'create' - Create completion signal JSON
     - Read status from argv[4] (success|failure|blocked|skipped)
     - Read phase from argv[5]
     - Read additional details from argv[6] (JSON string or key=value pairs)
     - Create appropriate signal using factory method
     - Output: Signal as JSON

  2. 'log' - Log completion signal to EXECUTION_LOG.md
     - Read signal JSON from argv[4] (or stdin)
     - Append to EXECUTION_LOG.md as NDJSON event
     - Output: "Completion signal logged"

  3. 'parse' - Parse completion signal from JSON
     - Read JSON from argv[4]
     - Create CompletionSignal from JSON
     - Output: { status, phase, isTerminal, canRetry }

  4. 'handle' - Process completion signal and output decision
     - Read signal JSON from argv[4]
     - Check status:
       - SUCCESS: { continue: true, nextPhase: N+1 }
       - FAILURE + canRetry: { continue: false, action: 'retry', backoff: Nms }
       - FAILURE + !canRetry: { continue: false, action: 'escalate' }
       - BLOCKED + userInput: { continue: false, action: 'await_user' }
       - BLOCKED + dependency: { continue: false, action: 'await_dependency', deps: [...] }
       - SKIPPED: { continue: true, nextPhase: N+1 }
     - Output: Decision JSON
  </action>
  <verify>node get-shit-done/bin/gsd-tools.js completion create success 6 '{"tokensUsed":50000}' && node get-shit-done/bin/gsd-tools.js completion create failure 6 '{"error":"Test error"}'</verify>
  <done>gsd-tools.js handles completion create/log/parse/handle commands with proper signal processing</done>
</task>

<task type="auto">
  <name>Task 3: Update gsd-phase-coordinator to use completion signals</name>
  <files>get-shit-done/agents/gsd-phase-coordinator.md</files>
  <action>
Update gsd-phase-coordinator.md to use structured completion signals:

1. At the end of phase execution, create and return completion signal:
   ```
   On successful completion:
   - Create SUCCESS signal with:
     - tokensUsed (estimated from plan complexity)
     - filesModified (from SUMMARY.md)
     - checkpoints created
     - verificationStatus (from VERIFICATION.md)
   - Log signal to EXECUTION_LOG.md
   - Return signal to orchestrator

   On failure:
   - Create FAILURE signal with:
     - error message and stack
     - retryable boolean (based on error type)
     - retryOptions if applicable
   - Log signal to EXECUTION_LOG.md
   - Return signal to orchestrator

   On blocked (missing dependency, needs user input):
   - Create BLOCKED signal with:
     - reason
     - blockingDependencies or userInputRequired
   - Log signal to EXECUTION_LOG.md
   - Return signal to orchestrator
   ```

2. Add signal creation commands in return_state section:
   ```bash
   # Create completion signal
   SIGNAL=$(node gsd-tools.js completion create ${STATUS} ${PHASE} '${DETAILS}')

   # Log to execution log
   node gsd-tools.js completion log "${SIGNAL}"
   ```

3. Update return state format to include signal:
   ```yaml
   return_state:
     signal: <CompletionSignal JSON>
     summary_path: ".planning/phases/XX-name/XX-NN-SUMMARY.md"
   ```

Note: Ensure signal is created AFTER all phase work is complete (after SUMMARY.md exists).
  </action>
  <verify>grep -c "CompletionSignal\|completion create\|completion log" /Users/ollorin/.claude/get-shit-done/agents/gsd-phase-coordinator.md | [ $(cat) -ge 2 ] && echo "Completion signal usage found in coordinator"</verify>
  <done>gsd-phase-coordinator.md creates and returns structured completion signals for all exit paths</done>
</task>

</tasks>

<verification>
1. Module load test:
   node -e "require('./get-shit-done/bin/completion-signal.js')" && echo "completion-signal.js loads"

2. Signal creation test:
   node get-shit-done/bin/gsd-tools.js completion create success 6 '{"tokensUsed":50000,"filesModified":["a.js","b.js"]}'
   node get-shit-done/bin/gsd-tools.js completion create failure 6 '{"error":"Network timeout","retryable":true}'
   node get-shit-done/bin/gsd-tools.js completion create blocked 6 '{"reason":"Waiting for Phase 5","blockingDependencies":[5]}'

3. Signal handling test:
   node get-shit-done/bin/gsd-tools.js completion handle '{"status":"success","phase":6}'
   node get-shit-done/bin/gsd-tools.js completion handle '{"status":"failure","phase":6,"details":{"retryable":true}}'

4. Coordinator integration check:
   grep "completion" ~/.claude/get-shit-done/agents/gsd-phase-coordinator.md
</verification>

<success_criteria>
- CompletionSignal class created with success/failure/blocked/skipped factory methods
- gsd-tools.js handles completion create/log/parse/handle commands
- gsd-phase-coordinator.md creates and returns completion signals
- Signals include all required context (tokens, files, errors, next steps)
- Signal handling produces clear continue/wait/escalate decisions
</success_criteria>

<output>
After completion, create `.planning/phases/07-autonomous-execution-optimization/07-03-SUMMARY.md`
</output>
