---
phase: 07-autonomous-execution-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/token-monitor.js
  - get-shit-done/bin/gsd-tools.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Token usage is tracked per phase and cumulatively during roadmap execution"
    - "System alerts at 80% utilization before reaching hard limits"
    - "Token budget can be reserved before operations and recorded after"
    - "Sub-coordinators can check token availability before spawning"
  artifacts:
    - path: "get-shit-done/bin/token-monitor.js"
      provides: "Token budget monitoring with threshold alerts"
      exports: ["TokenBudgetMonitor", "estimatePhaseTokens"]
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "CLI commands for token monitoring"
      contains: "token init"
  key_links:
    - from: "get-shit-done/bin/gsd-tools.js"
      to: "token-monitor.js"
      via: "require and command handlers"
      pattern: "require.*token-monitor"
    - from: "execute-roadmap.md"
      to: "gsd-tools.js token commands"
      via: "CLI invocation before phase spawn"
      pattern: "token reserve|token record"
---

<objective>
Token Budget Monitoring with 80% Alert Thresholds

Purpose: Prevent mid-execution context exhaustion by proactively tracking token usage and alerting before hitting hard limits. This is the highest-value, lowest-risk optimization for Phase 7.

Output: token-monitor.js module with CLI integration for reserve/record/report operations
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-autonomous-execution-optimization/07-RESEARCH.md

# Phase 6 foundation
@get-shit-done/bin/gsd-tools.js
@get-shit-done/bin/roadmap-parser.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token-monitor.js module</name>
  <files>get-shit-done/bin/token-monitor.js</files>
  <action>
Create TokenBudgetMonitor class with:

1. Constructor accepting model (default 'opus') and maxTokens (default 200000)
2. Properties: currentUsage, phaseUsage (Map), alerts array
3. ALERT_THRESHOLDS constant: { warn: 0.80, critical: 0.90, stop: 0.95 }

Methods:
- reserve(estimatedTokens, operation): Check if operation can proceed
  - Calculate projected usage
  - Add alerts at warn/critical/stop thresholds
  - Return boolean (true = proceed, false = blocked)
- recordUsage(actualTokens, phase): Add to currentUsage and phaseUsage map
- getReport(): Return { current_usage, max_tokens, utilization_percent, remaining_tokens, phase_breakdown, active_alerts }
- reset(): Clear usage for new session

Helper function:
- estimatePhaseTokens(phase): Heuristic estimation
  - Base 10000 tokens
  - + (requirements.length * 1000)
  - + (success_criteria.length * 500)
  - Return estimated total

Export: { TokenBudgetMonitor, estimatePhaseTokens }

Follow Pattern 1 from 07-RESEARCH.md for implementation details.
  </action>
  <verify>node -e "const tm = require('./get-shit-done/bin/token-monitor.js'); const m = new tm.TokenBudgetMonitor(); console.log(m.reserve(100000, 'test')); console.log(JSON.stringify(m.getReport()))"</verify>
  <done>TokenBudgetMonitor class exports reserve/recordUsage/getReport methods and estimatePhaseTokens helper function</done>
</task>

<task type="auto">
  <name>Task 2: Add token commands to gsd-tools.js</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add token-monitor require at top of gsd-tools.js:
const { TokenBudgetMonitor, estimatePhaseTokens } = require('./token-monitor.js');

Add token command handler in switch statement:

case 'token':
  Handle subcommands:

  1. 'init' - Initialize token budget file
     - Read model from argv[4] or default 'opus'
     - Create new TokenBudgetMonitor
     - Write to .planning/token_budget.json
     - Output: "Token budget initialized for {model} (200k limit)"

  2. 'reserve' - Reserve tokens before operation
     - Read estimatedTokens from argv[4]
     - Read operation name from argv[5]
     - Load existing budget from .planning/token_budget.json
     - Call reserve() method
     - Update budget file
     - Output JSON: { can_proceed, alerts, utilization }
     - Exit code 0 if can proceed, 1 if blocked

  3. 'record' - Record actual usage after operation
     - Read actualTokens from argv[4]
     - Read phase identifier from argv[5]
     - Load budget, call recordUsage(), save budget
     - Output: "Recorded {tokens} tokens for {phase}"

  4. 'report' - Display token usage report
     - Load budget from .planning/token_budget.json
     - Output JSON report

  5. 'reset' - Reset for new session
     - Create fresh budget file
     - Output: "Token budget reset"
  </action>
  <verify>node get-shit-done/bin/gsd-tools.js token init opus && node get-shit-done/bin/gsd-tools.js token reserve 50000 test-phase && node get-shit-done/bin/gsd-tools.js token record 45000 phase-1 && node get-shit-done/bin/gsd-tools.js token report</verify>
  <done>gsd-tools.js handles token init/reserve/record/report/reset commands with proper JSON output and exit codes</done>
</task>

<task type="auto">
  <name>Task 3: Integration with execute-roadmap workflow</name>
  <files>get-shit-done/workflows/execute-roadmap.md</files>
  <action>
Update execute-roadmap.md workflow to use token monitoring:

1. In initialization step (step 1), add:
   - Initialize token budget: node gsd-tools.js token init opus
   - Store budget file path for later reference

2. Before each phase spawn (in execute_phases step), add token check:
   ```bash
   # Estimate tokens for phase
   PHASE_TOKENS=$(node gsd-tools.js roadmap estimate-phase ${PHASE})

   # Reserve tokens
   TOKEN_CHECK=$(node gsd-tools.js token reserve ${PHASE_TOKENS} phase-${PHASE})

   # If blocked, trigger compression
   if [ $? -ne 0 ]; then
     echo "Token budget insufficient. Compressing context..."
     node gsd-tools.js phase archive ${PREV_PHASE}
     # Retry reservation after compression
   fi
   ```

3. After each phase completion (after SUMMARY created), add:
   ```bash
   # Record actual usage (estimate based on phase complexity)
   node gsd-tools.js token record ${ACTUAL_TOKENS} phase-${PHASE}
   ```

4. In completion step, add final report:
   ```bash
   node gsd-tools.js token report
   ```

Note: Integrate smoothly with existing workflow steps. Do not duplicate functionality already in execute-roadmap.md.
  </action>
  <verify>grep -c "token" /Users/ollorin/.claude/get-shit-done/workflows/execute-roadmap.md | [ $(cat) -ge 3 ] && echo "Token integration found"</verify>
  <done>execute-roadmap.md workflow initializes token budget, checks before phase spawn, records after completion, and shows final report</done>
</task>

</tasks>

<verification>
1. Module load test:
   node -e "require('./get-shit-done/bin/token-monitor.js')" && echo "token-monitor.js loads"

2. CLI integration test:
   node get-shit-done/bin/gsd-tools.js token init opus
   node get-shit-done/bin/gsd-tools.js token reserve 160000 test-phase  # Should warn at 80%
   node get-shit-done/bin/gsd-tools.js token reserve 30000 test-phase-2  # Should hit critical at 95%
   node get-shit-done/bin/gsd-tools.js token report

3. Workflow integration check:
   grep "token init\|token reserve\|token record" ~/.claude/get-shit-done/workflows/execute-roadmap.md
</verification>

<success_criteria>
- TokenBudgetMonitor class created with reserve/recordUsage/getReport methods
- gsd-tools.js handles token init/reserve/record/report/reset commands
- execute-roadmap.md workflow integrates token checking before phase spawn
- 80% utilization triggers warn alert, 90% triggers critical, 95% blocks execution
- Token budget persisted to .planning/token_budget.json for cross-session tracking
</success_criteria>

<output>
After completion, create `.planning/phases/07-autonomous-execution-optimization/07-01-SUMMARY.md`
</output>
