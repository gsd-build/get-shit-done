---
phase: 07-autonomous-execution-optimization
plan: 06
type: execute
wave: 2
depends_on: ["07-04"]
files_modified:
  - get-shit-done/bin/parallel-executor.js
  - get-shit-done/bin/gsd-tools.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Independent phases execute in parallel when dependency graph allows"
    - "Worker pool manages concurrent phase execution"
    - "Parallel execution respects token budget limits"
  artifacts:
    - path: "get-shit-done/bin/parallel-executor.js"
      provides: "ParallelPhaseExecutor class with worker pool management"
      min_lines: 150
      exports: ["ParallelPhaseExecutor", "executeParallelGroups"]
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "CLI commands: parallel analyze, parallel execute, parallel status"
      contains: "cmdParallel"
  key_links:
    - from: "gsd-tools.js"
      to: "parallel-executor.js"
      via: "require('./parallel-executor.js')"
      pattern: "require.*parallel-executor"
    - from: "parallel-executor.js"
      to: "roadmap-parser.js"
      via: "detectParallelOpportunities"
      pattern: "require.*roadmap-parser"
    - from: "parallel-executor.js"
      to: "token-monitor.js"
      via: "token budget checks"
      pattern: "require.*token-monitor"
---

<objective>
Close gap for EXEC-12 (independent phases execute in parallel when dependency graph allows).

Purpose: Enable parallel execution of independent phases using a worker pool, with token budget awareness and safe fallback to sequential execution.
Output: ParallelPhaseExecutor module with CLI integration
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-autonomous-execution-optimization/07-VERIFICATION.md
@.planning/phases/07-autonomous-execution-optimization/07-RESEARCH.md
@get-shit-done/bin/roadmap-parser.js
@get-shit-done/bin/token-monitor.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parallel-executor.js module</name>
  <files>get-shit-done/bin/parallel-executor.js</files>
  <action>
Create parallel execution module following Pattern 4 from 07-RESEARCH.md:

1. **Configuration constants:**
   ```javascript
   const CONFIG = {
     MAX_WORKERS: 2,              // Conservative: max 2 parallel phases
     MIN_TOKEN_BUDGET_PER_PHASE: 50000, // Minimum tokens to start a phase
     FALLBACK_TO_SEQUENTIAL: true // Fall back on budget exhaustion
   };
   ```

2. **ParallelPhaseExecutor class:**
   - Constructor(maxWorkers = 2):
     - this.maxWorkers = maxWorkers
     - this.activePhases = new Map() // phaseNum -> { startTime, status }
     - this.completedPhases = []
     - this.failedPhases = []

3. **analyzeParallelOpportunities(phases):**
   - Import detectParallelOpportunities from roadmap-parser.js
   - Group phases into parallel groups based on dependency graph
   - Return: { parallelGroups: [[1], [2,3], [4]], totalPhases, maxParallelism }

4. **canExecuteInParallel(phases, tokenMonitor):**
   - Estimate total tokens needed for parallel group
   - Check if token budget allows (MIN_TOKEN_BUDGET_PER_PHASE * phases.length)
   - Return: { canParallel: boolean, reason: string }

5. **executeParallelGroup(phases, tokenMonitor):**
   - Check token budget before starting
   - If insufficient: return { fallback: true, reason: 'token_budget' }
   - Use Promise.allSettled to execute phases concurrently
   - Track each phase in activePhases
   - On completion: move to completedPhases or failedPhases
   - Record token usage per phase
   - Return: { results: [], totalTokens, duration }

6. **executeSequentially(phases, tokenMonitor):**
   - Fallback for when parallelism not safe
   - Execute phases one at a time
   - Same return format as executeParallelGroup

7. **executePhaseGroups(parallelGroups, phaseMap, tokenMonitor):**
   - Main orchestration function
   - For each group:
     - If single phase: execute directly
     - If multiple phases: check canExecuteInParallel
     - If canParallel: executeParallelGroup
     - If not: executeSequentially with warning
   - Aggregate results
   - Return: { results: [], stats: { parallel, sequential, failed } }

8. **getStatus():**
   - Return current execution state
   - Include: active, completed, failed, progress percentage

9. **toJSON() / fromJSON():**
   - Serialize state for checkpoint persistence
   - Enable resume from parallel execution state

Export: ParallelPhaseExecutor, executeParallelGroups (standalone), analyzeParallelOpportunities, CONFIG
  </action>
  <verify>
```bash
node -e "const { ParallelPhaseExecutor, analyzeParallelOpportunities, CONFIG } = require('./get-shit-done/bin/parallel-executor.js'); console.log('Module loads'); console.log('Config:', CONFIG); const executor = new ParallelPhaseExecutor(2); console.log('Executor created, status:', executor.getStatus())"
```
  </verify>
  <done>parallel-executor.js module created with ParallelPhaseExecutor class, analyzeParallelOpportunities, and executeParallelGroups. Module loads without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add parallel execution commands to gsd-tools.js</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add parallel execution CLI commands to gsd-tools.js:

1. **Import parallel-executor** at top:
   `const { ParallelPhaseExecutor, analyzeParallelOpportunities, CONFIG } = require('./parallel-executor.js');`

2. **Add cmdParallel function** with subcommands:

   **parallel analyze:**
   - Read ROADMAP.md via roadmap-parser
   - Call analyzeParallelOpportunities
   - Output JSON with: parallelGroups, totalPhases, maxParallelism
   - Human-readable: "Phases [2,3] can run in parallel (Wave 1), Phase [4] depends on them"

   **parallel check:**
   - Analyze parallel opportunities AND token budget
   - Report which groups can execute in parallel now
   - Exit code 0 if parallelism possible, 1 if sequential only
   - Include: { canParallel: true, groups: [...], tokenBudget: {...} }

   **parallel config:**
   - Display CONFIG constants
   - Useful for understanding limits
   - Output: MAX_WORKERS, MIN_TOKEN_BUDGET_PER_PHASE, FALLBACK_TO_SEQUENTIAL

   **parallel simulate <groups>:**
   - Simulate parallel execution without actually spawning
   - Groups format: "1,2:3,4" means [1,2] then [3,4]
   - Show estimated duration (parallel vs sequential)
   - Show estimated token usage

3. **Wire cmdParallel** in main switch statement

4. **Integration notes:**
   - This module prepares infrastructure for execute-roadmap.md
   - Actual execution spawns sub-coordinators (not implemented here)
   - CLI provides analysis and validation tools
  </action>
  <verify>
```bash
node get-shit-done/bin/gsd-tools.js parallel config
node get-shit-done/bin/gsd-tools.js parallel analyze
node get-shit-done/bin/gsd-tools.js parallel check
```
  </verify>
  <done>gsd-tools.js handles parallel analyze/check/config/simulate commands. Commands work correctly with ROADMAP.md.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate parallel executor with token monitoring</name>
  <files>get-shit-done/bin/parallel-executor.js</files>
  <action>
Enhance parallel-executor.js with token budget integration:

1. **Import TokenBudgetMonitor:**
   `const { TokenBudgetMonitor } = require('./token-monitor.js');`

2. **reserveTokensForParallelGroup(phases, tokenMonitor):**
   - Calculate total tokens needed for all phases
   - Use estimatePhaseTokens from token-monitor.js
   - Reserve tokens upfront
   - If reservation fails: trigger compression or fallback
   - Return: { reserved: boolean, tokens: number, warnings: [] }

3. **trackParallelTokenUsage(results, tokenMonitor):**
   - After parallel execution completes
   - Record actual tokens used per phase
   - Update token budget state
   - Return aggregated stats

4. **handleParallelFailure(phases, failedPhase, tokenMonitor):**
   - If one phase in parallel group fails:
     - Let others continue (don't kill siblings)
     - Record failure for later retry/escalation
     - Release unused token reservation
   - Return: { shouldContinue: boolean, failedPhase, remainingPhases }

5. **executeWithTokenAwareness(phases, tokenBudgetPath):**
   - High-level function that:
     - Loads token budget from .planning/token_budget.json
     - Analyzes parallel opportunities
     - Checks budget for parallel execution
     - Falls back to sequential if needed
     - Returns comprehensive results
   - For CLI integration and workflow use

6. **CLI enhancement:**
   - Update `parallel check` to include token budget analysis
   - Show: "Token budget: 150k remaining, need 100k for parallel group -> CAN_PROCEED"
   - Or: "Token budget: 30k remaining, need 100k for parallel group -> FALLBACK_SEQUENTIAL"

Export: Add reserveTokensForParallelGroup, executeWithTokenAwareness
  </action>
  <verify>
```bash
node -e "const { ParallelPhaseExecutor, reserveTokensForParallelGroup, executeWithTokenAwareness } = require('./get-shit-done/bin/parallel-executor.js'); console.log('Functions exported:', typeof reserveTokensForParallelGroup, typeof executeWithTokenAwareness)"
node get-shit-done/bin/gsd-tools.js parallel check
```
  </verify>
  <done>parallel-executor.js integrated with token-monitor.js. Token-aware parallel execution checks work. Fallback to sequential on budget exhaustion implemented.</done>
</task>

</tasks>

<verification>
1. `node get-shit-done/bin/parallel-executor.js` - No import errors
2. `node get-shit-done/bin/gsd-tools.js parallel analyze` - Shows parallel groups from ROADMAP.md
3. `node get-shit-done/bin/gsd-tools.js parallel check` - Shows token budget status for parallel execution
4. `node get-shit-done/bin/gsd-tools.js parallel config` - Shows CONFIG constants
5. Token budget integration working (reservation, tracking)
6. EXEC-12 requirement covered: Independent phases can execute in parallel
</verification>

<success_criteria>
- analyzeParallelOpportunities() identifies phases that can run in parallel
- ParallelPhaseExecutor.executeParallelGroup() runs phases concurrently
- Token budget checks prevent parallel execution when budget insufficient
- Fallback to sequential execution works gracefully
- CLI commands work: parallel analyze, parallel check, parallel config
</success_criteria>

<output>
After completion, create `.planning/phases/07-autonomous-execution-optimization/07-06-SUMMARY.md`
</output>
