---
phase: 01-auto-mode-foundation
plan: 09
type: execute
wave: 3
depends_on: ["01-07", "01-08"]
files_modified:
  - ~/.claude/get-shit-done/agents/gsd-task-router.md
  - ~/.claude/get-shit-done/agents/gsd-phase-coordinator.md
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "gsd-task-router.md agent exists and calls routing match-with-quota to get model recommendation"
    - "gsd-phase-coordinator.md calls gsd-task-router before spawning each executor Task()"
    - "Task() spawns in gsd-phase-coordinator use the model returned by the router, not hardcoded 'sonnet'"
    - "When auto profile is inactive, coordinator falls back to sonnet (unchanged default)"
  artifacts:
    - path: "~/.claude/get-shit-done/agents/gsd-task-router.md"
      provides: "Agent definition: takes task description, returns structured routing decision (model + context + quota info)"
      contains: "routing match-with-quota"
    - path: "~/.claude/get-shit-done/agents/gsd-phase-coordinator.md"
      provides: "Updated coordinator that reads model_profile config and calls gsd-task-router when auto profile active"
      contains: "gsd-task-router"
  key_links:
    - from: "gsd-phase-coordinator.md execute step"
      to: "gsd-task-router.md"
      via: "Task() spawn of gsd-task-router agent before executor spawn"
      pattern: "gsd-task-router"
    - from: "gsd-task-router.md"
      to: "routing match-with-quota"
      via: "Bash call to gsd-tools.js"
      pattern: "routing match-with-quota"
    - from: "gsd-phase-coordinator.md"
      to: "model parameter in Task() spawn"
      via: "router_model variable set from gsd-task-router response"
      pattern: "router_model|ROUTER_MODEL"
---

<objective>
Create the gsd-task-router.md agent and wire it into gsd-phase-coordinator.md so that auto mode routing is actively used when spawning executor Tasks.

Purpose: This is Gap 3 — the "last mile" integration. Plans 01-07 and 01-08 built complexity scoring and quota-aware routing in gsd-tools.js. This plan creates the agent layer that coordinators actually call, and updates gsd-phase-coordinator.md to use it. Without this, auto mode is documented but never exercised.

Output: gsd-task-router.md agent (creates) + updated gsd-phase-coordinator.md (modifies execute step).
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/ollorin/get-shit-done/.planning/STATE.md
@/Users/ollorin/get-shit-done/.planning/phases/01-auto-mode-foundation/01-CONTEXT.md
@/Users/ollorin/get-shit-done/.planning/phases/01-auto-mode-foundation/01-08-SUMMARY.md
@/Users/ollorin/get-shit-done/.planning/phases/01-auto-mode-foundation/01-VERIFICATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gsd-task-router.md agent</name>
  <files>~/.claude/get-shit-done/agents/gsd-task-router.md</files>
  <action>
Create the file `~/.claude/get-shit-done/agents/gsd-task-router.md`.

This agent receives a task description, calls `routing match-with-quota`, and returns a structured routing decision for the calling coordinator.

The file content:

```markdown
---
name: gsd-task-router
description: Determines optimal model tier for a task using complexity scoring and quota state
tools: Bash
color: cyan
---

<role>
You are a task router. Given a task description, you determine which model tier (haiku/sonnet/opus) should execute it, using multi-signal complexity analysis and current quota state.

Spawned by: gsd-phase-coordinator and other coordinators that need auto-mode routing.

Your job: Run the routing command, parse the result, return a structured routing decision. You do NOT execute tasks — you only route them.
</role>

<process>

<step name="get_routing_decision">
Run the quota-aware routing command for the provided task description:

```bash
node /Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js routing match-with-quota "{TASK_DESCRIPTION}" --json
```

Replace `{TASK_DESCRIPTION}` with the actual task description passed to you.

Parse the JSON result. It contains:
- `model`: recommended model tier ("haiku", "sonnet", or "opus")
- `score`: complexity score 0-100
- `signals`: breakdown of keyword/length/structural contributions
- `reason`: human-readable rationale
- `quota_adjusted`: whether quota pressure changed the recommendation
- `quota_percent`: current session quota usage %
</step>

<step name="resolve_model_id">
Map symbolic tier to Claude model ID based on what's available in Claude Code:
- "haiku" → claude-haiku-4-5
- "sonnet" → claude-sonnet-4-5 (or claude-sonnet-4-6 if available)
- "opus" → claude-opus-4-5 (or the highest available Opus)

Use the symbolic name if you cannot determine the specific model ID. The calling coordinator uses this in the Task() `model` parameter.
</step>

<step name="get_context">
Optionally, also fetch relevant context docs for the task:

```bash
node /Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js routing context "{TASK_DESCRIPTION}" --json
```

Extract top matches (up to 3) for context injection by the coordinator.
</step>

<step name="return_decision">
Return a structured routing decision in this exact format:

```
ROUTING DECISION
================
Task: {task description}
Model: {haiku|sonnet|opus}
Score: {0-100} (keyword:{K} length:{L} structural:{S})
Quota: {percent}% used{, adjusted if quota_adjusted=true}
Reason: {reason string}

Context injection:
- {doc path 1} — {relevance score}
- {doc path 2} — {relevance score}
- {doc path 3} — {relevance score}
(or: No relevant context docs found)
```

If the routing command fails (file not found, parse error), fall back to:
```
ROUTING DECISION
================
Task: {task description}
Model: sonnet
Score: N/A (routing fallback)
Reason: routing command failed — defaulting to sonnet
```
</step>

</process>
```

Note: The file lives at `~/.claude/get-shit-done/agents/gsd-task-router.md` (NOT in the project repository). This is a global GSD agent.
  </action>
  <verify>
```bash
# Verify file exists
ls -la ~/.claude/get-shit-done/agents/gsd-task-router.md

# Verify it has the routing command reference
grep "routing match-with-quota" ~/.claude/get-shit-done/agents/gsd-task-router.md

# Verify frontmatter is valid
head -5 ~/.claude/get-shit-done/agents/gsd-task-router.md
# Expected: ---\nname: gsd-task-router\n...
```
  </verify>
  <done>
- File `~/.claude/get-shit-done/agents/gsd-task-router.md` exists
- Contains frontmatter with name, description, tools, color
- References `routing match-with-quota` command
- Has fallback behavior when routing command fails
- Returns structured ROUTING DECISION format
  </done>
</task>

<task type="auto">
  <name>Task 2: Update gsd-phase-coordinator.md to use routing when auto profile active</name>
  <files>~/.claude/get-shit-done/agents/gsd-phase-coordinator.md</files>
  <action>
Read the current `~/.claude/get-shit-done/agents/gsd-phase-coordinator.md` file. Locate the `<step name="execute">` section.

Currently the execute step has this Task() spawn (hardcoded model="sonnet"):
```
Task(
  subagent_type="gsd-executor",
  model="sonnet",
  prompt="..."
)
```

Make the following changes to the execute step:

**1. Add profile check before the executor spawn loop:**

After the `phase-plan-index` bash command and before "For each incomplete plan", insert:

```
Check the model profile setting to determine if auto routing is active:

```bash
CONFIG_FILE=".planning/config.json"
if [ -f "$CONFIG_FILE" ]; then
  MODEL_PROFILE=$(jq -r '.model_profile // "quality"' "$CONFIG_FILE")
else
  MODEL_PROFILE="quality"
fi
echo "Model profile: $MODEL_PROFILE"
```

If MODEL_PROFILE is "auto", auto routing is active. Otherwise use sonnet as default.
```

**2. Add routing call inside the per-plan loop, before spawning the executor:**

Inside "For each incomplete plan (no SUMMARY.md)", BEFORE spawning the executor Task(), add:

```
**If auto profile active:** Get model recommendation from task router.

Read the plan objective (first line of <objective> tag in PLAN.md) as the task description for routing.

```bash
PLAN_OBJECTIVE=$(grep -A1 '<objective>' {plan_file} | tail -1 | tr -d '\n')
```

Spawn routing agent to get model recommendation:
```
Task(
  subagent_type="gsd-task-router",
  prompt="Route this task: {PLAN_OBJECTIVE}"
)
```

Parse the ROUTING DECISION response to extract the `Model:` line.
Set EXECUTOR_MODEL to the returned model tier (haiku/sonnet/opus).

**If auto profile NOT active:** Set EXECUTOR_MODEL="sonnet" (unchanged default behavior).
```

**3. Update the executor Task() spawn to use EXECUTOR_MODEL:**

Change:
```
Task(
  subagent_type="gsd-executor",
  model="sonnet",
  prompt="..."
)
```

To:
```
Task(
  subagent_type="gsd-executor",
  model="{EXECUTOR_MODEL}",
  prompt="..."
)
```

**4. Add routing context injection to the executor prompt (when auto profile active):**

When auto profile is active and the router returned context docs, append to the executor prompt:

```
<routing_context>
Auto mode active. Routed to {EXECUTOR_MODEL} (score: {SCORE}).
Relevant context injected by router:
{context doc paths}
</routing_context>
```

This makes auto mode observable — executors receive routing metadata.

Keep all existing behavior intact when MODEL_PROFILE is not "auto". The only behavioral change is: auto profile → routing agent called → model parameter set dynamically.
  </action>
  <verify>
```bash
# Verify file was updated
grep "gsd-task-router" ~/.claude/get-shit-done/agents/gsd-phase-coordinator.md
# Expected: at least one match showing the Task() spawn call

grep "MODEL_PROFILE\|model_profile" ~/.claude/get-shit-done/agents/gsd-phase-coordinator.md
# Expected: config.json read and MODEL_PROFILE variable

grep "EXECUTOR_MODEL" ~/.claude/get-shit-done/agents/gsd-phase-coordinator.md
# Expected: variable set and used in Task() spawn

# Verify the file is not broken (check it still has the execute step)
grep -c "<step name=" ~/.claude/get-shit-done/agents/gsd-phase-coordinator.md
# Expected: >= 4 (research, plan, execute, verify steps)
```
  </verify>
  <done>
- `gsd-phase-coordinator.md` reads `model_profile` from `.planning/config.json`
- When profile is "auto": spawns gsd-task-router agent before each executor, uses returned model in Task() call
- When profile is not "auto": uses sonnet as before (no behavioral change)
- EXECUTOR_MODEL variable replaces hardcoded "sonnet" in executor Task() spawn
- File still has all original steps (research, plan, execute, verify) intact
  </done>
</task>

</tasks>

<verification>
```bash
# Task 1: router agent exists and is complete
ls ~/.claude/get-shit-done/agents/gsd-task-router.md && echo "EXISTS"
grep "ROUTING DECISION" ~/.claude/get-shit-done/agents/gsd-task-router.md && echo "HAS_FORMAT"
grep "routing match-with-quota" ~/.claude/get-shit-done/agents/gsd-task-router.md && echo "HAS_COMMAND"

# Task 2: coordinator updated
grep "gsd-task-router" ~/.claude/get-shit-done/agents/gsd-phase-coordinator.md && echo "ROUTER_WIRED"
grep "EXECUTOR_MODEL" ~/.claude/get-shit-done/agents/gsd-phase-coordinator.md && echo "DYNAMIC_MODEL"
grep "model_profile" ~/.claude/get-shit-done/agents/gsd-phase-coordinator.md && echo "PROFILE_CHECK"
```
</verification>

<success_criteria>
Gap 3 closed: Auto mode is end-to-end observable.
- gsd-task-router.md agent exists and calls quota-aware routing
- gsd-phase-coordinator.md reads model_profile and calls router before each executor spawn
- Executor Tasks receive the router's model recommendation instead of hardcoded "sonnet"
- When model_profile != "auto", behavior is identical to pre-gap-closure (sonnet default)
</success_criteria>

<output>
After completion, create `/Users/ollorin/get-shit-done/.planning/phases/01-auto-mode-foundation/01-09-SUMMARY.md`
</output>
