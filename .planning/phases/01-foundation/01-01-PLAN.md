---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - FORK-BOUNDARY.md
  - package.json
  - src/graph/engine.js
  - src/graph/engine.test.js
  - esbuild.config.js
autonomous: true

must_haves:
  truths:
    - "Graph engine can create nodes with semantic IDs (D-XX, M-XX, A-XX) and three states (PENDING, ACTIVE, DONE)"
    - "Graph engine can add upward-causation edges (action->milestone, milestone->declaration) and rejects invalid edge types"
    - "Graph engine can validate structure (orphans, cycles, broken edges) and return structured errors"
    - "Graph engine can produce topological sort for execution ordering"
    - "FORK-BOUNDARY.md exists defining the GSD fork relationship"
  artifacts:
    - path: "src/graph/engine.js"
      provides: "DeclareDag class with addNode, addEdge, validate, topologicalSort, layer queries, toJSON/fromJSON"
      min_lines: 150
    - path: "src/graph/engine.test.js"
      provides: "Comprehensive tests for graph engine operations"
      min_lines: 100
    - path: "FORK-BOUNDARY.md"
      provides: "Living document defining GSD fork relationship"
      contains: "Fork and Diverge"
    - path: "esbuild.config.js"
      provides: "Build config for bundling src/ into dist/declare-tools.cjs"
  key_links:
    - from: "src/graph/engine.js"
      to: "src/graph/engine.test.js"
      via: "require in test file"
      pattern: "require.*engine"
---

<objective>
Create the graph engine core and establish the fork boundary from GSD.

Purpose: The DeclareDag class is the foundational data structure for all of Declare -- every other component (artifact persistence, slash commands, validation) depends on it. The fork boundary document establishes the project's relationship to GSD.

Output: Working graph engine with tests, FORK-BOUNDARY.md, project scaffolding (src/ directory structure, esbuild config, updated package.json).
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project scaffolding and FORK-BOUNDARY.md</name>
  <files>FORK-BOUNDARY.md, package.json, esbuild.config.js</files>
  <action>
1. Create FORK-BOUNDARY.md at project root. This is a living document (per user decision) that defines:
   - Origin: forked from GSD (get-shit-done-cc)
   - Strategy: "Fork and Diverge" -- copy patterns, evolve independently, no upstream dependency
   - What's carried forward: full agent stack (planner, executor, researcher, verifier), slash command patterns, gsd-tools patterns (becoming declare-tools.cjs), esbuild bundling
   - What's replaced: linear phase planning (replaced by three-layer DAG), phase-based roadmap (replaced by declaration-driven structure), gsd-tools.cjs (replaced by declare-tools.cjs)
   - What's extended: artifact formats (FUTURE.md, MILESTONES.md are new), graph engine (new), validation system (extended from plan verification to graph validation)
   - Divergence log: empty table with columns (Date, Component, Change, GSD Equivalent) -- to be filled as Declare evolves

2. Update package.json:
   - Change name to "declare-cc"
   - Change description to "A future-driven meta-prompting engine for agentic development, rooted in declared futures and causal graph structure."
   - Add scripts.test: "node --test src/graph/engine.test.js"
   - Add scripts.build: "node esbuild.config.js"
   - Keep esbuild as devDependency
   - Update engines to node >= 18.0.0 (for node:test)

3. Create esbuild.config.js at project root:
   - Entry point: src/declare-tools.js (will be created in Plan 02)
   - Output: dist/declare-tools.cjs
   - Format: cjs, platform: node, bundle: true, minify: false (readable output)
   - External: none (zero runtime dependencies)
   - Follow GSD's existing build pattern from scripts/build-hooks.js

4. Create empty src/ directory structure: src/graph/, src/artifacts/, src/git/, src/commands/ (just the directories with placeholder files if needed for git tracking).
  </action>
  <verify>
- `cat FORK-BOUNDARY.md` shows the living document with fork strategy
- `node -e "require('./package.json')" && echo "valid JSON"` confirms package.json is valid
- `cat esbuild.config.js` shows the build config
- `ls src/graph/ src/artifacts/ src/git/ src/commands/` shows the directory structure
  </verify>
  <done>FORK-BOUNDARY.md exists with fork-and-diverge strategy. package.json updated for Declare. esbuild.config.js ready to bundle. src/ directory structure created.</done>
</task>

<task type="auto">
  <name>Task 2: DeclareDag graph engine with tests</name>
  <files>src/graph/engine.js, src/graph/engine.test.js</files>
  <action>
Create src/graph/engine.js implementing the DeclareDag class. Use CJS module format with JSDoc type annotations. Zero runtime dependencies.

The class must implement (reference RESEARCH.md Pattern 1 for architecture):

**Constructor:**
- `this.nodes = new Map()` -- id -> { id, type, title, status, metadata }
- `this.upEdges = new Map()` -- id -> Set of IDs this node causes/realizes (upward)
- `this.downEdges = new Map()` -- id -> Set of IDs that cause/realize this node (downward)

**Node operations:**
- `addNode(id, type, title, status = 'PENDING', metadata = {})` -- validates semantic prefix (D-XX for declaration, M-XX for milestone, A-XX for action), validates status is one of PENDING/ACTIVE/DONE, initializes edge sets
- `removeNode(id)` -- removes node and all its edges (both up and down)
- `getNode(id)` -- returns node or undefined
- `updateNodeStatus(id, status)` -- changes node status, validates status value

**Edge operations:**
- `addEdge(from, to)` -- validates upward causation (action->milestone or milestone->declaration only), validates both nodes exist, adds to both upEdges and downEdges
- `removeEdge(from, to)` -- removes from both edge maps

**Layer queries:**
- `getDeclarations()` -- returns all declaration nodes
- `getMilestones()` -- returns all milestone nodes
- `getActions()` -- returns all action nodes
- `getUpstream(id)` -- returns nodes this node causes/realizes
- `getDownstream(id)` -- returns nodes that cause/realize this node

**Validation (per user decision: only runs on /declare:status, NOT on normal operations):**
- `validate()` -- returns { valid: boolean, errors: Array }
- Checks: orphan nodes (milestones/actions with no upward edge), cycles (via Kahn's), broken edges (targets don't exist), invalid edge directions

**Topological sort:**
- `topologicalSort()` -- Kahn's algorithm, returns array of node IDs in execution order (actions first, then milestones, then declarations). Throws on cycle detection.

**Serialization:**
- `toJSON()` -- returns { nodes: [...], edges: [...] }
- `static fromJSON(data)` -- reconstructs DeclareDag from JSON

**Auto-increment helper:**
- `nextId(type)` -- scans existing nodes of given type, finds max numeric suffix, returns next ID (e.g., if D-01, D-02 exist, returns 'D-03'). Zero-pad to 2 digits, allow growth beyond.

**Node counts:**
- `size` getter -- total node count
- `stats()` -- returns { declarations: N, milestones: N, actions: N, edges: N, byStatus: { PENDING: N, ACTIVE: N, DONE: N } }

Export: `module.exports = { DeclareDag }`

Then create src/graph/engine.test.js using node:test and node:assert/strict:

Test cases:
1. addNode with valid semantic IDs succeeds
2. addNode with mismatched prefix/type throws
3. addNode with invalid status throws
4. addEdge action->milestone succeeds
5. addEdge milestone->declaration succeeds
6. addEdge action->declaration throws (skip layer)
7. addEdge declaration->anything throws (declarations are top)
8. addEdge with nonexistent node throws
9. removeNode removes node and all connected edges
10. validate detects orphan milestone (no upward edge)
11. validate passes for valid graph
12. validate detects cycle (if manually introduced through direct map manipulation)
13. topologicalSort returns correct execution order
14. topologicalSort throws on cycle
15. toJSON/fromJSON round-trip preserves graph
16. nextId returns correct sequential IDs
17. stats returns correct counts
18. Many-to-many: action serving multiple milestones, milestone linked to multiple declarations
19. Layer queries return correct subsets
20. getUpstream/getDownstream return correct neighbors
  </action>
  <verify>
- `node --test src/graph/engine.test.js` -- all tests pass
- `node -e "const { DeclareDag } = require('./src/graph/engine'); const d = new DeclareDag(); d.addNode('D-01', 'declaration', 'Test'); console.log(d.stats())"` -- prints stats object
  </verify>
  <done>DeclareDag class fully implemented with all operations. All 20 test cases pass. Graph supports many-to-many relationships, three node states, semantic ID validation, Kahn's topological sort, and structural validation.</done>
</task>

</tasks>

<verification>
- `node --test src/graph/engine.test.js` passes all tests
- FORK-BOUNDARY.md exists and documents fork strategy
- package.json is valid with updated name, scripts, and engine requirement
- esbuild.config.js exists and is syntactically valid
- src/ directory structure matches research recommendations
</verification>

<success_criteria>
- DeclareDag class creates, queries, validates, and sorts a three-layer graph
- All 20 test cases pass
- FORK-BOUNDARY.md establishes the GSD fork relationship as a living document
- Project scaffolding ready for Plans 02 and 03
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
