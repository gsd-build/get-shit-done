---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - .claude/commands/declare/init.md
  - .claude/commands/declare/status.md
  - .claude/commands/declare/help.md
  - src/commands/init.js
  - src/commands/status.js
  - src/commands/help.js
  - dist/declare-tools.cjs
autonomous: false

must_haves:
  truths:
    - "User can invoke /declare:init and get a .planning/ directory with FUTURE.md, MILESTONES.md, and config.json"
    - "User can invoke /declare:status and see graph stats, layer counts, health indicators, and validation results"
    - "User can invoke /declare:help and see available commands with descriptions"
    - "/declare:init detects existing .planning/ and offers to keep/replace each artifact individually"
    - "All state changes from init produce atomic git commits"
    - "dist/declare-tools.cjs is a bundled single-file CLI tool"
  artifacts:
    - path: ".claude/commands/declare/init.md"
      provides: "Slash command definition for /declare:init"
      contains: "declare:init"
    - path: ".claude/commands/declare/status.md"
      provides: "Slash command definition for /declare:status"
      contains: "declare:status"
    - path: ".claude/commands/declare/help.md"
      provides: "Slash command definition for /declare:help"
      contains: "declare:help"
    - path: "src/commands/init.js"
      provides: "Init command logic: create .planning/, FUTURE.md, MILESTONES.md, config.json"
      exports: ["runInit"]
    - path: "src/commands/status.js"
      provides: "Status command logic: load graph, validate, display stats"
      exports: ["runStatus"]
    - path: "dist/declare-tools.cjs"
      provides: "Bundled single-file CLI tool"
  key_links:
    - from: ".claude/commands/declare/init.md"
      to: "src/commands/init.js"
      via: "slash command references workflow that calls declare-tools.cjs init"
      pattern: "declare-tools"
    - from: "src/commands/init.js"
      to: "src/artifacts/future.js"
      via: "writes FUTURE.md using writeFutureFile"
      pattern: "require.*artifacts/future"
    - from: "src/commands/init.js"
      to: "src/artifacts/milestones.js"
      via: "writes MILESTONES.md using writeMilestonesFile"
      pattern: "require.*artifacts/milestones"
    - from: "src/commands/status.js"
      to: "src/graph/engine.js"
      via: "loads graph, runs validate, calls stats"
      pattern: "require.*graph/engine"
    - from: "src/commands/status.js"
      to: "src/artifacts/future.js"
      via: "parses FUTURE.md to load declarations"
      pattern: "require.*artifacts/future"
---

<objective>
Wire up the slash commands (/declare:init, /declare:status, /declare:help), implement their command logic, and produce the bundled dist/declare-tools.cjs.

Purpose: This is the user-facing surface of Phase 1. Everything built in Plans 01-02 becomes accessible through Claude Code slash commands. The init command bootstraps a project, status shows the graph state with validation, and help provides discoverability.

Output: Three working slash commands, their implementation modules, and the bundled declare-tools.cjs.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Command logic modules (init, status, help)</name>
  <files>src/commands/init.js, src/commands/status.js, src/commands/help.js, src/declare-tools.js</files>
  <action>
**src/commands/init.js -- runInit(cwd, args):**

Implements the `/declare:init` logic. Per locked decisions:

1. Check if `.planning/` exists at cwd:
   - If yes: detect which artifacts exist (FUTURE.md, MILESTONES.md, config.json). For each existing file, report its presence. Return a summary indicating existing files found -- the slash command prompt will handle the user interaction about keep/replace (Claude sees the output and asks the user). Do NOT overwrite existing files automatically.
   - If no: create `.planning/` directory

2. Create missing artifacts:
   - `.planning/FUTURE.md` -- use writeFutureFile with empty declarations array and project name derived from directory name or args
   - `.planning/MILESTONES.md` -- use writeMilestonesFile with empty milestones/actions arrays
   - `.planning/config.json` -- `{ "commit_docs": true }` (default config)

3. Create `.planning/` directory if needed (mkdir -p equivalent)

4. Atomic git commit of all created files using commitPlanningDocs

5. Return JSON result: `{ initialized: true, created: [...filenames], existing: [...filenames], committed: true/false }`

**src/commands/status.js -- runStatus(cwd):**

Implements `/declare:status`. Per locked decisions: rich visual summary with graph stats, layer counts, health indicators, last activity. Validation runs here.

1. Check if `.planning/` exists -- if not, return `{ error: "No Declare project found. Run /declare:init first." }`

2. Load the graph:
   - Read `.planning/FUTURE.md` and `.planning/MILESTONES.md`
   - Parse both with artifact parsers
   - Reconstruct DeclareDag using fromJSON or manual addNode/addEdge

3. Run validation: `dag.validate()`

4. Get stats: `dag.stats()`

5. Determine last activity: check git log for last commit touching `.planning/` files:
   `git log -1 --format="%ci %s" -- .planning/`

6. Return JSON result with all data for the slash command to render:
   ```json
   {
     "project": "<name>",
     "stats": { "declarations": N, "milestones": N, "actions": N, "edges": N, "byStatus": {...} },
     "validation": { "valid": true/false, "errors": [...] },
     "lastActivity": "<date> <message>",
     "health": "healthy" | "warnings" | "errors"
   }
   ```

The slash command markdown will format this into a rich display. The JS module returns raw data.

**src/commands/help.js -- runHelp():**

Returns structured help information:
```json
{
  "commands": [
    { "name": "/declare:init", "description": "Initialize a Declare project with future declarations and graph structure", "usage": "/declare:init [project-name]" },
    { "name": "/declare:status", "description": "Show graph state, layer counts, health, and validation results", "usage": "/declare:status" },
    { "name": "/declare:help", "description": "Show available Declare commands", "usage": "/declare:help" }
  ],
  "version": "0.1.0"
}
```

**Update src/declare-tools.js:**

Wire the stubs from Plan 02 to actual implementations:
- 'init' command: require('./commands/init').runInit(cwd, args)
- 'status' command: require('./commands/status').runStatus(cwd)
- 'help' command: require('./commands/help').runHelp()
- Keep 'commit' command from Plan 02

All commands print JSON to stdout. Slash command prompts handle the human-readable formatting.
  </action>
  <verify>
- `node src/declare-tools.js help` -- prints JSON with command list
- `node src/declare-tools.js init --cwd /tmp/test-declare` -- initializes in a temp directory (or similar isolated test)
- `node src/declare-tools.js status` -- prints error about no project (or graph stats if .planning/ exists)
  </verify>
  <done>All three command modules implemented. declare-tools.js dispatches to real implementations. Init creates artifacts with merge behavior. Status loads graph and runs validation. Help returns command reference.</done>
</task>

<task type="auto">
  <name>Task 2: Slash command definitions and esbuild bundle</name>
  <files>.claude/commands/declare/init.md, .claude/commands/declare/status.md, .claude/commands/declare/help.md, dist/declare-tools.cjs</files>
  <action>
**Create .claude/commands/declare/ directory** with three slash command files.

Each command file follows Claude Code's slash command format (see RESEARCH Pattern 3). The commands are meta-prompts -- they instruct Claude on what to do, referencing declare-tools.cjs for data operations.

**.claude/commands/declare/init.md:**
```yaml
---
description: Initialize Declare project with future declarations and graph structure
allowed-tools:
  - Read
  - Write
  - Bash
  - Glob
  - Grep
---
```
Body: Instruct Claude to:
1. Run `node <path-to>/dist/declare-tools.cjs init` to check/create artifacts
2. If existing files detected, present them to the user and ask which to keep vs replace
3. Show the user what was created
4. Confirm initialization with a summary

Use `$ARGUMENTS` for optional project name.

**.claude/commands/declare/status.md:**
```yaml
---
description: Show graph state, layer counts, health indicators, and last activity
allowed-tools:
  - Read
  - Bash
  - Grep
  - Glob
---
```
Body: Instruct Claude to:
1. Run `node <path-to>/dist/declare-tools.cjs status`
2. Format the JSON response into a rich visual display (per user decision: "feel like GSD's progress view")
3. Show: project name, graph stats (declarations/milestones/actions counts), status distribution (PENDING/ACTIVE/DONE), validation health (pass/warnings/errors), last activity timestamp
4. If validation errors exist, list them with actionable suggestions
5. If no project found, suggest running `/declare:init`

**.claude/commands/declare/help.md:**
```yaml
---
description: Show available Declare commands
allowed-tools:
  - Read
  - Bash
---
```
Body: Instruct Claude to:
1. Run `node <path-to>/dist/declare-tools.cjs help`
2. Format the command list into a clean display
3. Include brief description of Declare's purpose
4. List all available `/declare:*` commands with usage

**Important for all command files:** The path to declare-tools.cjs should use a pattern that works from any project directory. Use the project-relative path since commands are in the repo: reference the bundled `dist/declare-tools.cjs` relative to the command file location, OR use an absolute path pattern. Follow how GSD references gsd-tools.cjs in its commands -- check the existing `.claude/commands/gsd/*.md` files for the path pattern.

**Bundle with esbuild:**

Run `node esbuild.config.js` to produce `dist/declare-tools.cjs`. Verify the bundle:
- `node dist/declare-tools.cjs help` works
- `node dist/declare-tools.cjs status` works (returns error about no project, which is correct)
- Bundle is a single CJS file with no external dependencies
  </action>
  <verify>
- `node dist/declare-tools.cjs help` -- prints command list JSON
- `node dist/declare-tools.cjs status` -- prints error or status JSON
- `ls .claude/commands/declare/` shows init.md, status.md, help.md
- `cat .claude/commands/declare/init.md` contains frontmatter with allowed-tools
- `wc -c dist/declare-tools.cjs` shows bundle exists with reasonable size
  </verify>
  <done>Three slash command files created in .claude/commands/declare/. dist/declare-tools.cjs is a working bundled CLI tool. All commands dispatchable from Claude Code via /declare:init, /declare:status, /declare:help.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify slash commands work in Claude Code</name>
  <files>none</files>
  <action>
CHECKPOINT: Human verifies the complete Phase 1 foundation works end-to-end.

What was built: Graph engine, artifact persistence, three slash commands (/declare:init, /declare:status, /declare:help), and bundled declare-tools.cjs.

Steps for the user to verify:
1. Open a new Claude Code session in this project directory
2. Type `/declare:help` -- should display available commands with descriptions
3. Create a temporary test directory: `mkdir /tmp/test-declare && cd /tmp/test-declare && git init`
4. Type `/declare:init` -- should create .planning/ with FUTURE.md, MILESTONES.md, and config.json
5. Verify files: `ls .planning/` shows the three files
6. Verify FUTURE.md format: `cat .planning/FUTURE.md` shows the sectioned card format
7. Verify MILESTONES.md format: `cat .planning/MILESTONES.md` shows milestone and action tables
8. Type `/declare:status` -- should show graph stats (all zeros for empty graph), healthy validation, last activity
9. Clean up: `rm -rf /tmp/test-declare`

Expected: All three commands respond appropriately. Init creates properly formatted artifacts. Status shows a rich visual summary.
  </action>
  <verify>User confirms all three slash commands work as expected in Claude Code.</verify>
  <done>User types "approved" or describes issues to fix.</done>
</task>

</tasks>

<verification>
- All three slash commands are invocable from Claude Code
- `/declare:init` creates .planning/ with FUTURE.md, MILESTONES.md, config.json
- `/declare:status` shows graph stats, validation health, and last activity
- `/declare:help` lists all available commands
- `dist/declare-tools.cjs` is a single-file bundle that runs independently
- `node --test src/graph/engine.test.js` still passes (regression check)
- `node --test src/artifacts/artifacts.test.js` still passes (regression check)
</verification>

<success_criteria>
- User can invoke all three Phase 1 slash commands from Claude Code
- Init creates properly formatted artifacts with re-init merge behavior
- Status loads the graph, validates, and displays a rich summary
- All state changes produce atomic git commits
- dist/declare-tools.cjs works as a standalone bundled CLI tool
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
