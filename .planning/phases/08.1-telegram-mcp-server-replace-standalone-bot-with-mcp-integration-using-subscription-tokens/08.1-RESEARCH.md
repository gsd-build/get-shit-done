# Phase 08.1: Telegram MCP Server - Research

**Researched:** 2026-02-17
**Domain:** Model Context Protocol (MCP) server implementation, Telegram bot integration, subscription token management, file-based persistence, real-time notifications
**Confidence:** HIGH

## Summary

Phase 08.1 migrates the standalone Telegram bot (Phase 8) to an MCP server architecture that auto-loads with Claude Code, uses subscription tokens instead of external API keys, and provides tools for blocking questions and resources for new requirements. The MCP server embeds the Telegraf bot process, persists state to file-based queues (JSONL format), and integrates with GSD orchestrators through a polling + callback notification pattern.

The architecture follows the Model Context Protocol specification (stable as of 2025-11-25), using **stdio transport** for local Claude Code integration via `@modelcontextprotocol/sdk` (TypeScript/Node.js). The server exposes **MCP tools** for blocking questions (orchestrator → Telegram → user → orchestrator) and **MCP resources** for new requirements (user → Telegram → Claude via push notifications). This replaces Phase 8's manual `node gsd-tools.js telegram start` with automatic MCP server initialization in `.mcp.json`.

**Primary recommendation:** Use `@modelcontextprotocol/sdk` v1.x (stable) with stdio transport, embed Telegraf bot in MCP server lifespan, implement tools for `ask_blocking_question` and `check_question_answers` with 30-minute configurable polling, implement notifications resource for `new_requirements` subscription pattern, persist pending questions to `.planning/telegram-questions/pending.jsonl`, persist message queue to `.planning/telegram-queue/messages.jsonl`, reuse Phase 8's Telegraf + Whisper code (proven, verified), and configure via `.claude/.mcp.json` for auto-loading.

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**MCP Tools Design:**
- **Blocking question flow:** Orchestrator/sub-orchestrator sends message via MCP tool → message displayed in Telegram pending questions list → user answers → orchestrator receives notification + answer → orchestrator marks question as answered → question disappears from waiting list
- **Question retrieval:** Long polling (check every 30 mins default) + callback notification when answer provided. Polling interval configurable via config file
- **New Requirements subscription:** MCP notifications resource pushes new requirement messages from Telegram to Claude (initiated by user clicking "New Requirements" button). Preferred for context efficiency and stability. Can be enhanced with more functionality later
- **Bot lifecycle:** Telegram bot embedded in MCP server process (single process, auto-loads with Claude Code)
- **Subagent spawning:** Prefer Haiku uses Task tool directly (Claude Code native). MCP tool for spawning may also be needed case-by-case

**Message Flow:**
- **Telegram message receipt:** Webhooks preferred if free/stable infrastructure with static URL (no config updates on restart). Fallback: long polling with check on bot/MCP server start
- **Message storage:** File-based queue in `.planning/telegram-queue/` (JSONL format). Survives restarts
- **Voice transcription:** Immediate transcription (bot transcribes voice → stores text in queue). Claude always receives text, not audio files
- **Notification timing:** Real-time webhook-driven if webhooks available. Else configurable polling interval (30s default)

**Session State:**
- **Pending questions tracking:** JSONL file at `.planning/telegram-questions/pending.jsonl` - append new, mark answered, persist across restarts
- **Session logging:** Unified log per day with all messages + questions (single chronological file easier to review than separate sessions)
- **Haiku context management:**
  - Stateless Haiku for ad-hoc flows (requirement gathering subagents)
  - Token budget tracking as safety tool for main Haiku orchestrator
- **Restart behavior:** Persist and reload pending questions from JSONL on MCP server startup. Continue waiting for answers

**Integration Pattern:**
- **GSD orchestrator integration:** Auto-detect if Telegram MCP available. Use if present, graceful degradation if not. No mandatory dependency
- **Configuration:** Secrets in `.env` (TELEGRAM_BOT_TOKEN, etc.), non-sensitive config in `.planning/config.json`. Separation of concerns

**Logging:**
- **What to log:** Everything in unified daily log
  - All messages (sent/received with timestamp, user, content)
  - Questions and answers (blocking questions lifecycle)
  - Haiku decisions (routing requirements, spawning subagents, etc.)
  - Errors and warnings (transcription failures, timeouts, API errors)
  - All activity and diagnostic info for debugging and audit trail

### Claude's Discretion

- MCP server pattern (follow Gemini MCP, hybrid with claudeclaw patterns, or custom)
- Language/runtime choice (Python like Gemini MCP, or Node.js to reuse Phase 8 Telegraf/Whisper code)
- Exact webhook implementation (if free/stable solution found)
- Log file naming and rotation strategy
- Queue cleanup and retention policies
- Error recovery strategies

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope (replace standalone bot with MCP server). All Phase 8 features (Status, Pending Questions, Requirements) will be preserved in new architecture.
</user_constraints>

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @modelcontextprotocol/sdk | 1.x (stable) | MCP server implementation | Official TypeScript SDK from Anthropic, supports stdio transport, v1.x production-ready (v2 expected Q1 2026) |
| telegraf | 4.16.3+ | Telegram bot framework | Modern framework with TypeScript support, proven in Phase 8, webhook/polling flexibility |
| @anthropic-ai/sdk | 0.74.0+ | Claude API client (subscription tokens) | Official Anthropic SDK, supports subscription usage (no external API keys needed) |
| whisper-node | 1.x | Local speech-to-text | CPU-optimized, proven in Phase 8, base multilingual model for English + Russian |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| fluent-ffmpeg | 2.x | Audio format conversion | Telegram .oga → 16kHz .wav for Whisper (reuse from Phase 8) |
| dotenv | 16.x | Environment variables | Load TELEGRAM_BOT_TOKEN, ANTHROPIC_API_KEY from .env |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Node.js MCP server | Python MCP server (like Gemini/Serena) | Python: matches user's Gemini MCP pattern. Node.js: reuses entire Phase 8 codebase (Telegraf, Whisper, session logging), no rewrite needed. **Recommend Node.js** for code reuse. |
| stdio transport | Streamable HTTP transport | HTTP: supports remote servers, network deployment. stdio: standard for local Claude Code, simpler, auto-loading. **Recommend stdio** for local-first architecture. |
| MCP tools for requirements | MCP prompts | Prompts: user-driven slash commands. Tools: model-driven autonomous calls. Resources: application-controlled push. **Recommend resources** for push notifications (user context). |

**Installation:**
```bash
# MCP SDK
npm install @modelcontextprotocol/sdk

# Reuse Phase 8 dependencies (already installed)
# telegraf, @anthropic-ai/sdk, whisper-node, fluent-ffmpeg, dotenv
```

---

## Architecture Patterns

### Recommended Project Structure
```
get-shit-done/
├── mcp-servers/
│   └── telegram-mcp/
│       ├── index.js                    # NEW: MCP server entry point (stdio transport)
│       ├── tools/
│       │   ├── ask-blocking-question.js  # NEW: MCP tool for orchestrator → Telegram
│       │   └── check-question-answers.js # NEW: MCP tool for polling answers
│       ├── resources/
│       │   └── new-requirements.js     # NEW: MCP resource for subscriptions
│       ├── bot/
│       │   ├── telegram-bot.js         # REUSE: Phase 8 bot (import, don't copy)
│       │   ├── telegram-conversation.js # REUSE: Phase 8 conversation state
│       │   └── whisper-transcribe.js   # REUSE: Phase 8 transcription
│       └── storage/
│           ├── question-queue.js       # NEW: JSONL persistence for pending questions
│           └── message-queue.js        # NEW: JSONL persistence for incoming messages
│
.claude/
└── .mcp.json                           # NEW: MCP server configuration (auto-load)

.planning/
├── telegram-queue/                     # NEW: Message queue directory
│   └── messages.jsonl                  # NEW: JSONL message queue
├── telegram-questions/                 # NEW: Pending questions directory
│   └── pending.jsonl                   # NEW: JSONL pending questions
└── config.json                         # EXTEND: Add telegram.pollingInterval
```

### Pattern 1: MCP Server with Stdio Transport

**What:** Create MCP server that communicates via stdin/stdout, auto-loads with Claude Code

**When to use:** Local development tools, Claude Code integrations, process-level isolation

**Example:**
```javascript
// Source: https://github.com/modelcontextprotocol/typescript-sdk - Official SDK examples
// mcp-servers/telegram-mcp/index.js
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';

// Import Phase 8 bot components
const { startBot, stopBot } = require('../../bin/telegram-bot.js');
const { askBlockingQuestion } = require('./tools/ask-blocking-question.js');
const { checkQuestionAnswers } = require('./tools/check-question-answers.js');
const { subscribeToRequirements } = require('./resources/new-requirements.js');

const server = new McpServer({
  name: 'telegram-mcp',
  version: '1.0.0',
});

// MCP Tool: Ask blocking question
server.tool(
  'ask_blocking_question',
  {
    question: z.string().describe('The question to send to user'),
    choices: z.array(z.string()).optional().describe('Optional multiple choice options'),
    timeout_minutes: z.number().optional().describe('Timeout in minutes (default: 60)')
  },
  async (args) => {
    const questionId = await askBlockingQuestion(args.question, {
      choices: args.choices,
      timeout: args.timeout_minutes || 60
    });

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            questionId,
            status: 'pending',
            message: `Question sent to Telegram. Use check_question_answers to poll for response.`
          })
        }
      ]
    };
  }
);

// MCP Tool: Check question answers (polling)
server.tool(
  'check_question_answers',
  {
    question_ids: z.array(z.string()).optional().describe('Specific question IDs to check, or all if not provided')
  },
  async (args) => {
    const answers = await checkQuestionAnswers(args.question_ids);

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(answers)
        }
      ]
    };
  }
);

// MCP Resource: New requirements (push notifications)
server.resource(
  'telegram://requirements/new',
  'New requirements submitted via Telegram',
  async () => {
    // Return current pending requirements
    const requirements = await getNewRequirements();
    return {
      contents: [
        {
          uri: 'telegram://requirements/new',
          mimeType: 'application/json',
          text: JSON.stringify(requirements)
        }
      ]
    };
  }
);

// Lifecycle management: Start bot on server startup
let botInstance;

async function startServer() {
  // Start Telegram bot (embedded in MCP server process)
  botInstance = await startBot();
  console.error('[MCP] Telegram bot started'); // stderr for logging

  // Setup MCP resource subscriptions
  await subscribeToRequirements((newReq) => {
    // Notify Claude Code via resource update
    server.notification({
      method: 'notifications/resources/updated',
      params: {
        uri: 'telegram://requirements/new'
      }
    });
  });

  // Connect to stdio transport
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('[MCP] Server ready on stdio');
}

// Graceful shutdown
process.on('SIGINT', async () => {
  console.error('[MCP] Shutting down...');
  await stopBot(botInstance);
  process.exit(0);
});

startServer().catch((err) => {
  console.error('[MCP] Fatal error:', err);
  process.exit(1);
});
```

**Key details:**
- Use `console.error()` for logging (NOT `console.log()` - corrupts JSON-RPC on stdout)
- Transport auto-handles JSON-RPC protocol over stdin/stdout
- Bot lifecycle tied to MCP server (starts with server, stops on SIGINT)

### Pattern 2: File-Based JSONL Queue for Persistence

**What:** Durable message queue using append-only JSONL files, survives restarts

**When to use:** Pending questions, message history, any state that must persist across MCP server restarts

**Example:**
```javascript
// Source: Custom pattern based on JSONL best practices
// mcp-servers/telegram-mcp/storage/question-queue.js
const fs = require('fs');
const path = require('path');

const QUEUE_PATH = path.join(process.cwd(), '.planning/telegram-questions/pending.jsonl');

/**
 * Append new pending question to queue
 */
function addPendingQuestion(questionId, question, options = {}) {
  const entry = {
    questionId,
    question,
    choices: options.choices || null,
    askedAt: new Date().toISOString(),
    timeout: options.timeout || 60,
    status: 'pending'
  };

  fs.appendFileSync(QUEUE_PATH, JSON.stringify(entry) + '\n');
  return questionId;
}

/**
 * Mark question as answered
 */
function markQuestionAnswered(questionId, answer) {
  const questions = loadPendingQuestions();
  const updated = questions.map(q => {
    if (q.questionId === questionId) {
      return {
        ...q,
        status: 'answered',
        answer: answer.content,
        answerType: answer.type,
        answeredAt: new Date().toISOString()
      };
    }
    return q;
  });

  // Rewrite entire file (remove answered from pending)
  const stillPending = updated.filter(q => q.status === 'pending');
  fs.writeFileSync(QUEUE_PATH, stillPending.map(q => JSON.stringify(q)).join('\n') + '\n');

  // Archive answered question
  archiveAnsweredQuestion(updated.find(q => q.questionId === questionId));

  return answer;
}

/**
 * Load all pending questions (parse JSONL)
 */
function loadPendingQuestions() {
  if (!fs.existsSync(QUEUE_PATH)) {
    fs.mkdirSync(path.dirname(QUEUE_PATH), { recursive: true });
    fs.writeFileSync(QUEUE_PATH, '');
    return [];
  }

  const content = fs.readFileSync(QUEUE_PATH, 'utf8');
  if (!content.trim()) return [];

  return content
    .trim()
    .split('\n')
    .map(line => JSON.parse(line))
    .filter(q => q.status === 'pending');
}

/**
 * Archive answered question to daily log
 */
function archiveAnsweredQuestion(question) {
  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  const archivePath = path.join(
    process.cwd(),
    '.planning/telegram-sessions',
    `${today}.jsonl`
  );

  fs.appendFileSync(archivePath, JSON.stringify(question) + '\n');
}

module.exports = {
  addPendingQuestion,
  markQuestionAnswered,
  loadPendingQuestions
};
```

**Key details:**
- Append-only for new questions (atomic, no race conditions)
- Rewrite on answer (filter out answered, keep pending)
- Archive to daily session logs (unified chronological log per day)
- Auto-creates directory structure on first use

### Pattern 3: MCP Resource Subscriptions for Push Notifications

**What:** Use MCP resources with subscriptions to push new requirements to Claude

**When to use:** When user initiates action (clicks button), Claude should be notified in real-time

**Example:**
```javascript
// Source: https://modelcontextprotocol.io/docs/concepts/resources - Official MCP spec
// mcp-servers/telegram-mcp/resources/new-requirements.js
const EventEmitter = require('events');

const requirementsEmitter = new EventEmitter();
const newRequirements = []; // In-memory buffer (ephemeral)

/**
 * Subscribe to new requirements
 */
function subscribeToRequirements(callback) {
  requirementsEmitter.on('new_requirement', callback);
}

/**
 * Add new requirement (called by Telegram bot when user clicks "New Requirements")
 */
function addNewRequirement(userId, username, text) {
  const requirement = {
    id: `req_${Date.now()}`,
    userId,
    username,
    text,
    timestamp: new Date().toISOString()
  };

  newRequirements.push(requirement);
  requirementsEmitter.emit('new_requirement', requirement);

  return requirement.id;
}

/**
 * Get pending requirements
 */
function getNewRequirements() {
  return newRequirements;
}

/**
 * Clear requirements (after Claude processes them)
 */
function clearRequirements() {
  newRequirements.length = 0;
}

module.exports = {
  subscribeToRequirements,
  addNewRequirement,
  getNewRequirements,
  clearRequirements
};
```

**Integration with MCP server:**
```javascript
// In mcp-servers/telegram-mcp/index.js
subscribeToRequirements((newReq) => {
  // Send resource update notification to Claude Code
  server.notification({
    method: 'notifications/resources/updated',
    params: {
      uri: 'telegram://requirements/new'
    }
  });
});
```

**Key details:**
- EventEmitter for pub/sub pattern (in-process)
- MCP server sends `notifications/resources/updated` when new requirement arrives
- Claude Code checks resource for updated content
- Stateless (requirements cleared after processing) - Haiku handles conversation state

### Pattern 4: Long Polling with Configurable Intervals

**What:** Orchestrator polls for question answers at configurable intervals (default 30 mins)

**When to use:** Checking for user responses when callback notification not immediately available

**Example:**
```javascript
// Source: https://javascript.info/long-polling - Long polling pattern
// In orchestrator code (not MCP server)
async function waitForBlockingQuestionAnswer(questionId, options = {}) {
  const pollingInterval = options.pollingInterval || 30 * 60 * 1000; // 30 minutes default
  const maxAttempts = options.maxAttempts || 120; // 60 hours max (120 * 30min)

  let attempts = 0;

  while (attempts < maxAttempts) {
    // Check for answer via MCP tool
    const result = await callMCPTool('check_question_answers', {
      question_ids: [questionId]
    });

    const answers = JSON.parse(result.content[0].text);
    const answer = answers.find(a => a.questionId === questionId);

    if (answer && answer.status === 'answered') {
      return answer.answer;
    }

    // Wait for next polling interval
    await sleep(pollingInterval);
    attempts++;
  }

  throw new Error(`Timeout waiting for answer to question ${questionId}`);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

**Configuration:**
```json
// .planning/config.json
{
  "telegram": {
    "pollingInterval": 1800000,  // 30 minutes in milliseconds
    "questionTimeout": 3600000    // 1 hour default timeout
  }
}
```

**Key details:**
- Configurable via config file (not hardcoded)
- Fallback for when callback notification not available
- Graceful timeout after max attempts

### Pattern 5: Claude Code MCP Configuration

**What:** Configure MCP server for auto-loading in Claude Code via `.claude/.mcp.json`

**When to use:** All MCP servers that should initialize when Claude Code starts

**Example:**
```json
// .claude/.mcp.json
{
  "mcpServers": {
    "telegram-mcp": {
      "type": "stdio",
      "command": "node",
      "args": [
        "/Users/ollorin/get-shit-done/mcp-servers/telegram-mcp/index.js"
      ],
      "env": {
        "NODE_ENV": "production"
      }
    }
  }
}
```

**Key details:**
- `type: "stdio"` - Standard for local MCP servers
- Absolute path to entry point (avoid relative path issues)
- Environment variables passed through `env` object
- MCP server reads `.env` file in project root (TELEGRAM_BOT_TOKEN, etc.)

### Anti-Patterns to Avoid

- **Using console.log() in stdio MCP server:** Corrupts JSON-RPC messages on stdout. Use `console.error()` for logging (writes to stderr).
- **Polling every second for question answers:** Wastes tokens, floods logs. Use 30-minute intervals (or configurable) + callback notification when available.
- **Storing secrets in .mcp.json:** `TELEGRAM_BOT_TOKEN` should be in `.env`, not MCP config. Only non-sensitive config in `.mcp.json`.
- **Rewriting Phase 8 code:** Telegraf, Whisper, session logging already verified. Import and reuse, don't duplicate.
- **Using MCP prompts for requirements:** Prompts are user-driven (slash commands). Requirements are application-driven (user clicks button) → use resources with subscriptions.
- **Blocking MCP tool calls:** MCP tools should return immediately. Use status pattern (return questionId, poll later) instead of blocking.
- **Starting bot manually:** MCP server lifecycle includes bot. No need for `gsd-tools.js telegram start` once MCP configured.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| MCP protocol implementation | Custom JSON-RPC over stdio | @modelcontextprotocol/sdk | Official SDK handles protocol, versioning, schema validation, transport abstraction. Custom implementations miss edge cases (batch requests, partial failures, notifications). |
| Telegram bot management | Raw Bot API HTTP requests | Telegraf (Phase 8 proven) | Phase 8 already verified Telegraf works. Handles webhook security, multipart uploads, rate limiting, middleware patterns. No need to rebuild. |
| JSONL file locking | Custom mutex/semaphore | Append-only + atomic rewrite | JSONL append is atomic on POSIX filesystems. No locking needed for append. Rewrite on update (filter pending) is safe for small datasets (<1000 entries). |
| Resource subscriptions | Custom WebSocket/SSE | MCP notifications/resources/updated | MCP spec defines resource update protocol. Client already supports it. Custom transport requires client changes. |
| Audio transcription | Custom ML model | Whisper (Phase 8 proven) | Phase 8 verified whisper-node works. Base multilingual model handles English + Russian. Already installed and configured. |

**Key insight:** Phase 8 solved Telegram integration (bot, voice, session logging). Phase 08.1 is architectural migration (standalone → MCP), not feature rewrite. Reuse maximum code, change minimal surface area (entry point, tool wrappers, MCP protocol).

---

## Common Pitfalls

### Pitfall 1: MCP Server Crashes on Unhandled Promise Rejection

**What goes wrong:** MCP server exits silently when async tool handler throws error

**Why it happens:** Node.js default behavior: unhandled promise rejection logs warning but doesn't crash (legacy). MCP server uses async/await extensively - unhandled rejections crash process.

**How to avoid:**
- Wrap all tool handlers in try/catch
- Return error response instead of throwing:
  ```javascript
  server.tool('ask_blocking_question', schema, async (args) => {
    try {
      const result = await askBlockingQuestion(args.question);
      return { content: [{ type: 'text', text: JSON.stringify(result) }] };
    } catch (err) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({ error: err.message, questionId: null })
        }],
        isError: true
      };
    }
  });
  ```
- Add global handler: `process.on('unhandledRejection', (err) => console.error('[MCP] Unhandled rejection:', err));`

**Warning signs:**
- MCP server disappears from Claude Code tool list
- No error messages in Claude Code console
- Check stderr logs: "UnhandledPromiseRejectionWarning"

### Pitfall 2: Pending Questions Persist After Restart Without Reloading

**What goes wrong:** Questions asked before restart are lost, user's answers ignored

**Why it happens:** In-memory Map/Array for pending questions not persisted to JSONL, or JSONL not loaded on startup

**How to avoid:**
- Load pending questions from JSONL on MCP server startup (before bot starts)
- Reattach listeners for existing questions:
  ```javascript
  async function restorePendingQuestions() {
    const pending = loadPendingQuestions(); // Read from JSONL
    for (const q of pending) {
      // Recreate promise that orchestrator is waiting for
      const { resolve, reject } = restoredQuestions.get(q.questionId);
      // Register callback for when answer arrives
      onAnswer(q.questionId, (answer) => resolve(answer));
    }
  }
  ```
- Test restart scenario: ask question, restart MCP server, answer question - should work

**Warning signs:**
- "Question not found" errors after MCP server restart
- pending.jsonl has entries but `getPendingQuestions()` returns empty array
- User answers question but orchestrator never receives response

### Pitfall 3: Resource Subscription Notification Not Received by Claude

**What goes wrong:** User clicks "New Requirements" in Telegram, but Claude doesn't get notified

**Why it happens:** MCP client (Claude Code) doesn't support resource subscriptions, or server sends wrong notification format

**How to avoid:**
- Check Claude Code capabilities (as of Feb 2026, resource subscriptions are client capability gap in some versions)
- Fallback to polling if notifications not supported:
  ```javascript
  // In orchestrator
  if (mcpClientSupportsResourceSubscriptions) {
    await subscribeTo('telegram://requirements/new');
    await waitForNotification(); // Blocking
  } else {
    // Fallback: poll resource every 30s
    while (true) {
      const resource = await readResource('telegram://requirements/new');
      if (resource.requirements.length > 0) break;
      await sleep(30000);
    }
  }
  ```
- Document limitation: "Resource subscriptions require Claude Code version X+"

**Warning signs:**
- Telegram bot shows "New requirement recorded" but Claude never processes it
- MCP server logs show `notifications/resources/updated` sent, but no client response
- Error in Claude Code: "Unsupported notification method"

### Pitfall 4: Subscription Token Exhaustion from Excessive Polling

**What goes wrong:** Orchestrator polls `check_question_answers` every second, burns through subscription quota

**Why it happens:** Developer sets polling interval too low during testing, forgets to increase for production

**How to avoid:**
- Default to conservative interval (30 minutes per user constraint)
- Make configurable via `.planning/config.json`:
  ```json
  {
    "telegram": {
      "pollingInterval": 1800000,  // 30 minutes
      "pollingIntervalDev": 10000  // 10 seconds for local dev
    }
  }
  ```
- Load from config: `const interval = config.telegram.pollingInterval || 1800000;`
- Log polling activity: `console.error('[MCP] Polling for answers (interval: ${interval}ms)');`

**Warning signs:**
- Subscription usage dashboard shows unexpectedly high API calls
- Logs filled with "Checking question answers..." every few seconds
- Claude Code reports "Rate limit exceeded"

### Pitfall 5: Bot Fails to Start Due to Port Conflict

**What goes wrong:** Telegram bot won't start, MCP server hangs on initialization

**Why it happens:** Phase 8 bot used webhook mode (binds to port 3000). If port in use, bot fails to start silently.

**How to avoid:**
- Use long polling mode by default (no port binding):
  ```javascript
  // In telegram-bot.js
  if (process.env.TELEGRAM_WEBHOOK_URL) {
    // Webhook mode (production)
    bot.launch({ webhook: { domain: process.env.TELEGRAM_WEBHOOK_URL } });
  } else {
    // Long polling mode (development/MCP server)
    bot.launch();
  }
  ```
- Check bot launch status:
  ```javascript
  try {
    await bot.launch();
    console.error('[Bot] Started successfully');
  } catch (err) {
    console.error('[Bot] Failed to start:', err.message);
    throw err; // Fail fast - don't start MCP server if bot broken
  }
  ```
- Document configuration: Webhook mode optional, long polling default

**Warning signs:**
- MCP server shows "Telegram bot started" but bot doesn't respond to messages
- Error: "EADDRINUSE: address already in use :::3000"
- Bot appears offline in Telegram

### Pitfall 6: Voice Messages Break After Migration

**What goes wrong:** Voice messages worked in Phase 8, fail in MCP server with "Whisper model not found"

**Why it happens:** MCP server runs from different directory, Whisper model path is relative

**How to avoid:**
- Use absolute path for Whisper model:
  ```javascript
  // In whisper-transcribe.js
  const modelPath = path.join(process.env.HOME, '.cache/whisper/base.bin');
  const transcript = await whisper(tempWav, {
    modelPath,
    modelName: 'base',
    whisperOptions: { language: 'auto' }
  });
  ```
- Verify model on MCP server startup:
  ```javascript
  const { checkWhisperModel } = require('./bot/whisper-transcribe.js');
  if (!checkWhisperModel()) {
    console.error('[MCP] WARNING: Whisper model not found. Voice messages will fail.');
    console.error('[MCP] Run: npx whisper-node download --model base');
  }
  ```
- Add to health check: `gsd-tools.js health` command verifies Whisper available

**Warning signs:**
- Voice messages return "Transcription failed" error
- Error: "Could not find model at path..."
- Model file exists but wrong path (relative vs absolute)

---

## Code Examples

Verified patterns from official sources.

### MCP Server Entry Point with Bot Lifecycle

```javascript
// Source: https://github.com/modelcontextprotocol/typescript-sdk - Official examples
// mcp-servers/telegram-mcp/index.js
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const { startBot, stopBot } = require('../../bin/telegram-bot.js');

const server = new McpServer({
  name: 'telegram-mcp',
  version: '1.0.0'
});

let botInstance;

// MCP tool definitions (ask_blocking_question, check_question_answers)
// ... [tool definitions here] ...

// Server lifecycle
async function main() {
  // Start Telegram bot
  botInstance = await startBot();
  console.error('[MCP] Bot started');

  // Load pending questions from JSONL (survive restart)
  await restorePendingQuestions();
  console.error('[MCP] Pending questions restored');

  // Connect stdio transport
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('[MCP] Server ready');
}

// Graceful shutdown
process.on('SIGINT', async () => {
  console.error('[MCP] Shutting down...');
  await stopBot(botInstance);
  process.exit(0);
});

main().catch(err => {
  console.error('[MCP] Fatal:', err);
  process.exit(1);
});
```

### JSONL Queue Read/Write Operations

```javascript
// Source: Custom pattern (JSONL best practices)
// mcp-servers/telegram-mcp/storage/question-queue.js
const fs = require('fs');
const path = require('path');

const QUEUE_FILE = '.planning/telegram-questions/pending.jsonl';

function addQuestion(questionId, question, options) {
  const entry = {
    questionId,
    question,
    choices: options.choices || null,
    askedAt: new Date().toISOString(),
    timeout: options.timeout || 60,
    status: 'pending'
  };

  // Atomic append
  fs.appendFileSync(QUEUE_FILE, JSON.stringify(entry) + '\n');
  return questionId;
}

function loadPendingQuestions() {
  if (!fs.existsSync(QUEUE_FILE)) {
    fs.mkdirSync(path.dirname(QUEUE_FILE), { recursive: true });
    fs.writeFileSync(QUEUE_FILE, '');
    return [];
  }

  const content = fs.readFileSync(QUEUE_FILE, 'utf8');
  return content
    .trim()
    .split('\n')
    .filter(line => line.trim())
    .map(line => JSON.parse(line))
    .filter(q => q.status === 'pending');
}

function markAnswered(questionId, answer) {
  const questions = loadPendingQuestions();
  const stillPending = questions.filter(q => q.questionId !== questionId);

  // Atomic rewrite (filter out answered)
  fs.writeFileSync(
    QUEUE_FILE,
    stillPending.map(q => JSON.stringify(q)).join('\n') + '\n'
  );
}

module.exports = { addQuestion, loadPendingQuestions, markAnswered };
```

### MCP Tool Handler with Error Recovery

```javascript
// Source: https://modelcontextprotocol.io/docs/develop/build-server - Best practices
// mcp-servers/telegram-mcp/tools/ask-blocking-question.js
const { z } = require('zod');
const { addQuestion } = require('../storage/question-queue.js');
const { sendBlockingQuestion } = require('../../bin/telegram-bot.js');

const schema = {
  question: z.string().describe('Question to send to user'),
  choices: z.array(z.string()).optional().describe('Multiple choice options'),
  timeout_minutes: z.number().optional().describe('Timeout (default: 60)')
};

async function handler(args) {
  try {
    // Generate question ID
    const questionId = `q_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

    // Send to Telegram
    await sendBlockingQuestion(questionId, args.question, {
      choices: args.choices,
      timeout: args.timeout_minutes || 60
    });

    // Persist to JSONL
    addQuestion(questionId, args.question, {
      choices: args.choices,
      timeout: args.timeout_minutes || 60
    });

    // Return status (don't block - orchestrator will poll)
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          questionId,
          status: 'pending',
          message: 'Question sent. Use check_question_answers to poll for response.'
        })
      }]
    };
  } catch (err) {
    console.error('[MCP] ask_blocking_question error:', err);
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: err.message,
          questionId: null
        })
      }],
      isError: true
    };
  }
}

module.exports = { schema, handler };
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Standalone daemon processes (claudeclaw pattern) | MCP servers with stdio transport | 2024-2025 (MCP spec released Nov 2024) | MCP standardizes AI-tool integration. Replaces custom protocols with universal standard. Claude Code auto-loads MCP servers. |
| Manual bot start (`node telegram-bot.js`) | Bot embedded in MCP server lifecycle | Phase 8 → 08.1 | Bot auto-starts with Claude Code. No manual intervention. Graceful shutdown on Claude Code exit. |
| External API keys (Haiku via Anthropic API) | Subscription tokens (Claude Code subscription) | 2026 (Claude Code Max subscription) | 18x cheaper ($200/month vs $3,650/month for heavy usage). Subscription usage tracked, no surprise bills. |
| Webhooks for real-time Telegram | Long polling fallback | 2026 (MCP server portability) | Webhooks require static URL (ngrok, cloud deployment). Long polling works locally, no infrastructure. MCP servers prioritize local-first. |
| In-memory conversation state | JSONL persistence | Phase 8 → 08.1 | Survives MCP server restarts. Questions persist across sessions. Audit trail in unified daily log. |

**Deprecated/outdated:**
- **claudeclaw daemon pattern**: Replaced by MCP servers (standard protocol, auto-loading)
- **Manual bot start scripts**: Embedded in MCP server, lifecycle-managed
- **Custom JSON-RPC protocols**: Use `@modelcontextprotocol/sdk` (official implementation)
- **Server-Sent Events transport**: Deprecated in MCP spec, replaced by Streamable HTTP or stdio

---

## Open Questions

1. **Webhook infrastructure for production deployment**
   - What we know: Webhooks preferred for real-time (user constraint), requires static URL
   - What's unclear: Free/stable options for static URL? ngrok tunnels expire. Cloud deployment adds complexity.
   - Recommendation: Start with long polling (works locally, no infrastructure). Document webhook setup as optional production optimization. Pattern: check `TELEGRAM_WEBHOOK_URL` env var, fallback to polling.

2. **MCP resource subscription client support**
   - What we know: MCP spec defines resource subscriptions, but client capability gap exists (Feb 2026)
   - What's unclear: Does current Claude Code version support `notifications/resources/updated`?
   - Recommendation: Implement hybrid approach - resource subscriptions with polling fallback. Test with Claude Code, document version requirements if subscription not working.

3. **Token budget for MCP tool calls**
   - What we know: Each `check_question_answers` call consumes tokens (tool output)
   - What's unclear: Optimal polling interval balancing responsiveness vs token cost?
   - Recommendation: Default 30 minutes (user constraint), make configurable. Monitor actual usage, tune based on data. Consider exponential backoff (start 1 min, increase to 30 min if no answer).

4. **Haiku subagent spawning via Task vs MCP tool**
   - What we know: User prefers Task tool (Claude Code native), but MCP tool may be needed case-by-case
   - What's unclear: When is MCP tool needed? Task tool has timeout limits? Context isolation?
   - Recommendation: Start with Task tool only (Claude Code native, no custom implementation). Add MCP tool if Task limitations discovered during Phase 08.1 execution.

5. **Migration path for existing Phase 8 users**
   - What we know: Phase 8 bot works via `gsd-tools.js telegram start`
   - What's unclear: Can both coexist? Migration steps? Backwards compatibility?
   - Recommendation: Keep Phase 8 bot functional (no breaking changes). Add MCP server as alternative. Document migration: (1) Configure `.mcp.json`, (2) Restart Claude Code, (3) Verify MCP tools available, (4) Stop manual bot. Gradual migration, not forced.

---

## Sources

### Primary (HIGH confidence)

- **Model Context Protocol Specification**: https://modelcontextprotocol.io/specification/2025-11-25 - Official MCP spec, stdio transport, resources/tools/prompts
- **MCP TypeScript SDK**: https://github.com/modelcontextprotocol/typescript-sdk - Official SDK, McpServer, StdioServerTransport, examples
- **MCP SDK npm Package**: https://www.npmjs.com/package/@modelcontextprotocol/sdk - v1.x stable, installation, API reference
- **Claude Code MCP Documentation**: https://code.claude.com/docs/en/mcp - MCP server configuration, .mcp.json format, tool search
- **MCP Resources Specification**: https://modelcontextprotocol.io/docs/concepts/resources - Resource definitions, subscriptions, notifications
- **Telegraf Documentation**: https://telegraf.js.org/ - v4.16.3, proven in Phase 8
- **Phase 8 Research**: `.planning/phases/08-notifications-and-observability/08-RESEARCH.md` - Telegraf, Whisper, session logging patterns
- **Phase 8 Verification**: `.planning/phases/08-notifications-and-observability/08-VERIFICATION.md` - Verified artifacts, integration testing

### Secondary (MEDIUM confidence)

- **MCP Build Server Guide**: https://modelcontextprotocol.io/docs/develop/build-server - Server lifecycle, tool handlers, best practices
- **Build MCP Server TypeScript 2026**: https://noqta.tn/en/tutorials/build-mcp-server-typescript-2026 - Modern patterns, Zod schemas
- **MCP Resources vs Tools Guide**: https://medium.com/@laurentkubaski/mcp-resources-explained-and-how-they-differ-from-mcp-tools-096f9d15f767 - When to use each
- **MCP Tool Search**: https://claudefa.st/blog/tools/mcp-extensions/best-addons - Tool Search feature (85% context reduction)
- **Long Polling Pattern**: https://javascript.info/long-polling - Classic pattern, configurable intervals
- **Claude Code Subscription Tokens**: https://claudefa.st/blog/guide/development/usage-optimization - Token management, cost optimization
- **Claude Pricing 2026**: https://intuitionlabs.ai/articles/claude-pricing-plans-api-costs - Subscription vs API cost comparison

### Tertiary (LOW confidence - requires validation)

- **MCP Observer Server Discussion**: https://github.com/orgs/modelcontextprotocol/discussions/391 - Resource subscriptions community patterns
- **MCP Client Capability Gap**: https://www.pulsemcp.com/posts/mcp-client-capabilities-gap - Known limitations in client support
- **File-Based Queues**: https://www.npmjs.com/package/file-queue - JSONL persistence patterns (package outdated, pattern still valid)

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - @modelcontextprotocol/sdk is official, Telegraf proven in Phase 8, Node.js reuses existing codebase
- Architecture patterns: HIGH - MCP spec stable (2025-11-25), stdio transport standard, JSONL patterns well-established
- Tools vs Resources: MEDIUM - MCP spec clear, but client support for resource subscriptions needs validation
- Webhook infrastructure: LOW - User constraint prefers webhooks, but free/stable static URL solution unclear

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (30 days - MCP spec stable, but client implementations evolving)

**Phase 8 dependency:**
- Reuses: telegram-bot.js, telegram-conversation.js, whisper-transcribe.js, telegram-session-logger.js
- Extends: JSONL persistence (pending questions), MCP tool wrappers, resource subscriptions
- Preserves: All Phase 8 features (Status, Pending Questions, Requirements)

**Key architectural decision:**
**Node.js recommended** over Python for MCP server. Rationale: Reuse entire Phase 8 codebase (Telegraf, Whisper, session logging) verified and working. Python would require complete rewrite (Telegram client, audio transcription, JSONL handling). Node.js MCP SDK mature (@modelcontextprotocol/sdk v1.x stable). Migration is architectural (standalone → MCP), not feature rewrite.
