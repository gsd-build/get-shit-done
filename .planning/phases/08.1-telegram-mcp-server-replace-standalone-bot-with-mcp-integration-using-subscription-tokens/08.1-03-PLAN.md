---
phase: 08.1-telegram-mcp-server
plan: 03
type: execute
wave: 2
depends_on: ["08.1-01", "08.1-02"]
files_modified:
  - mcp-servers/telegram-mcp/src/tools/ask-question.ts
  - mcp-servers/telegram-mcp/src/tools/check-answers.ts
  - mcp-servers/telegram-mcp/src/tools/mark-answered.ts
  - mcp-servers/telegram-mcp/src/tools/index.ts
  - mcp-servers/telegram-mcp/src/index.ts
autonomous: true

must_haves:
  truths:
    - "ask_blocking_question tool creates question in queue and returns question_id"
    - "check_question_answers tool returns answered questions with long polling"
    - "mark_question_answered tool archives question to daily log"
  artifacts:
    - path: "mcp-servers/telegram-mcp/src/tools/ask-question.ts"
      provides: "MCP tool handler for ask_blocking_question"
      exports: ["askBlockingQuestionHandler"]
      min_lines: 40
    - path: "mcp-servers/telegram-mcp/src/tools/check-answers.ts"
      provides: "MCP tool handler for check_question_answers with long polling"
      exports: ["checkQuestionAnswersHandler"]
      min_lines: 60
    - path: "mcp-servers/telegram-mcp/src/tools/mark-answered.ts"
      provides: "MCP tool handler for mark_question_answered"
      exports: ["markQuestionAnsweredHandler"]
      min_lines: 30
  key_links:
    - from: "mcp-servers/telegram-mcp/src/tools/ask-question.ts"
      to: "mcp-servers/telegram-mcp/src/storage/question-queue.ts"
      via: "appendQuestion import"
      pattern: "appendQuestion"
    - from: "mcp-servers/telegram-mcp/src/index.ts"
      to: "mcp-servers/telegram-mcp/src/tools/index.ts"
      via: "tool handler imports"
      pattern: "import.*tools"
---

<objective>
Implement MCP tool handlers for blocking question flow: ask, check answers, mark answered.

Purpose: Enable GSD orchestrators to send questions via MCP, poll for answers, and archive completed questions.

Output: Three functional MCP tools wired into the server from Plan 01.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-telegram-mcp-server-replace-standalone-bot-with-mcp-integration-using-subscription-tokens/08.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ask_blocking_question tool handler</name>
  <files>mcp-servers/telegram-mcp/src/tools/ask-question.ts</files>
  <action>
Create the ask_blocking_question tool handler at `mcp-servers/telegram-mcp/src/tools/ask-question.ts`:

1. Input schema (per RESEARCH.md):
```typescript
interface AskQuestionInput {
  question: string;           // Question text
  context?: string;           // Optional execution context
  timeout_minutes?: number;   // Max wait time (default: 30)
}
```

2. Output schema:
```typescript
interface AskQuestionOutput {
  question_id: string;        // UUID for tracking
  asked_at: string;           // ISO timestamp
  status: "pending";
}
```

3. Handler implementation:
   - Validate input (question required, non-empty)
   - Call `appendQuestion()` from storage module
   - Return question_id, asked_at, status: "pending"
   - NOTE: Telegram message sending will be added in Plan 04 when bot is integrated

4. Export as named function for index.ts to import

5. Handle errors gracefully (return error in MCP tool response format)
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm run build && node -e "
import('./dist/tools/ask-question.js').then(async m => {
  const result = await m.askBlockingQuestionHandler({ question: 'Test question?', context: 'unit test' });
  console.log('Result:', result.question_id ? 'has question_id' : 'missing question_id');
  console.log('Status:', result.status);
});
"
```
Should output question_id and status: pending
  </verify>
  <done>
ask-question.ts creates question in storage and returns question_id.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement check_question_answers tool handler with long polling</name>
  <files>mcp-servers/telegram-mcp/src/tools/check-answers.ts</files>
  <action>
Create the check_question_answers tool handler at `mcp-servers/telegram-mcp/src/tools/check-answers.ts`:

1. Input schema (per RESEARCH.md):
```typescript
interface CheckAnswersInput {
  question_ids?: string[];    // Filter by IDs (empty = all pending)
  wait_seconds?: number;      // Long poll timeout (default: 60, max: 300)
}
```

2. Output schema:
```typescript
interface CheckAnswersOutput {
  answers: Array<{
    question_id: string;
    question: string;
    answer: string;
    answered_at: string;
  }>;
  pending_count: number;
}
```

3. Handler implementation:
   - Load pending questions from storage
   - Filter by question_ids if provided
   - If any have status="answered", return immediately
   - If no answers and wait_seconds > 0:
     - Poll every 5 seconds (check file for updates)
     - Stop when answer found OR timeout reached
   - Return answers array + pending_count

4. Long polling pattern:
```typescript
async function pollForAnswers(questionIds: string[], timeoutMs: number): Promise<Answer[]> {
  const startTime = Date.now();
  while (Date.now() - startTime < timeoutMs) {
    const questions = await loadPendingQuestions();
    const answered = questions.filter(q =>
      q.status === 'answered' &&
      (!questionIds.length || questionIds.includes(q.id))
    );
    if (answered.length > 0) return answered;
    await sleep(5000); // 5 second poll interval
  }
  return [];
}
```

5. Cap wait_seconds at 300 (5 minutes) to prevent hanging
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm run build && node -e "
import('./dist/tools/check-answers.js').then(async m => {
  const result = await m.checkQuestionAnswersHandler({ wait_seconds: 1 });
  console.log('Result has answers array:', Array.isArray(result.answers));
  console.log('Result has pending_count:', typeof result.pending_count === 'number');
});
"
```
  </verify>
  <done>
check-answers.ts implements long polling with configurable timeout and returns answers + pending_count.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement mark_question_answered tool and wire all tools to server</name>
  <files>
    mcp-servers/telegram-mcp/src/tools/mark-answered.ts
    mcp-servers/telegram-mcp/src/tools/index.ts
    mcp-servers/telegram-mcp/src/index.ts
  </files>
  <action>
1. Create mark_question_answered handler at `mcp-servers/telegram-mcp/src/tools/mark-answered.ts`:

Input:
```typescript
interface MarkAnsweredInput {
  question_id: string;
}
```

Output:
```typescript
interface MarkAnsweredOutput {
  success: boolean;
  archived_to: string;  // Daily log path
}
```

Implementation:
- Call `archiveQuestion(question_id)` from storage
- Return success + archive path

2. Create tools index at `mcp-servers/telegram-mcp/src/tools/index.ts`:
```typescript
export { askBlockingQuestionHandler, ASK_QUESTION_TOOL_DEF } from './ask-question.js';
export { checkQuestionAnswersHandler, CHECK_ANSWERS_TOOL_DEF } from './check-answers.js';
export { markQuestionAnsweredHandler, MARK_ANSWERED_TOOL_DEF } from './mark-answered.js';
```

Each tool module should export both the handler function AND the tool definition (name, description, inputSchema).

3. Update `mcp-servers/telegram-mcp/src/index.ts`:
   - Import tool handlers and definitions from tools/index.ts
   - Replace placeholder tool definitions with real ones
   - Wire CallToolRequestSchema handler to dispatch to correct handler based on tool name:
```typescript
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  switch (name) {
    case 'ask_blocking_question':
      return { content: [{ type: 'text', text: JSON.stringify(await askBlockingQuestionHandler(args)) }] };
    case 'check_question_answers':
      return { content: [{ type: 'text', text: JSON.stringify(await checkQuestionAnswersHandler(args)) }] };
    case 'mark_question_answered':
      return { content: [{ type: 'text', text: JSON.stringify(await markQuestionAnsweredHandler(args)) }] };
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
});
```
  </action>
  <verify>
Test full tool invocation via JSON-RPC:
```bash
cd mcp-servers/telegram-mcp && npm run build && echo '{"jsonrpc":"2.0","method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test"}},"id":1}
{"jsonrpc":"2.0","method":"tools/call","params":{"name":"ask_blocking_question","arguments":{"question":"Does this work?"}},"id":2}' | node dist/index.js 2>/dev/null | tail -1 | jq -r '.result.content[0].text' | jq '.question_id'
```
Should output a UUID string.
  </verify>
  <done>
All three tool handlers implemented, wired to MCP server, tools/call dispatches correctly.
  </done>
</task>

</tasks>

<verification>
- [ ] ask_blocking_question creates question in JSONL and returns question_id
- [ ] check_question_answers polls for answers with configurable timeout
- [ ] mark_question_answered archives question to daily log
- [ ] All tools accessible via MCP tools/call request
- [ ] Tool definitions include proper JSON Schema for inputs
</verification>

<success_criteria>
MCP tools are functional: orchestrators can create questions, poll for answers, and archive completed questions. Ready for Telegram bot integration in Plan 04.
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-telegram-mcp-server-replace-standalone-bot-with-mcp-integration-using-subscription-tokens/08.1-03-SUMMARY.md`
</output>
