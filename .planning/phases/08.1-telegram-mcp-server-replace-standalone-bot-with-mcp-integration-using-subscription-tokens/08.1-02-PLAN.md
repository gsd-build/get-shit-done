---
phase: 08.1-telegram-mcp-server
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp-servers/telegram-mcp/src/storage/question-queue.ts
  - mcp-servers/telegram-mcp/src/storage/message-queue.ts
autonomous: true

must_haves:
  truths:
    - "Pending questions persist to JSONL and reload on restart"
    - "Requirements queue appends messages atomically"
    - "Answered questions can be marked and archived"
  artifacts:
    - path: "mcp-servers/telegram-mcp/src/storage/question-queue.ts"
      provides: "CRUD operations for pending questions JSONL"
      exports: ["appendQuestion", "loadPendingQuestions", "markAnswered", "archiveQuestion"]
      min_lines: 80
    - path: "mcp-servers/telegram-mcp/src/storage/message-queue.ts"
      provides: "CRUD operations for requirements JSONL"
      exports: ["appendRequirement", "loadRequirements", "clearRequirements"]
      min_lines: 50
  key_links:
    - from: "mcp-servers/telegram-mcp/src/storage/question-queue.ts"
      to: ".planning/telegram-questions/pending.jsonl"
      via: "fs read/write operations"
      pattern: "telegram-questions/pending\\.jsonl"
    - from: "mcp-servers/telegram-mcp/src/storage/message-queue.ts"
      to: ".planning/telegram-queue/requirements.jsonl"
      via: "fs append operations"
      pattern: "telegram-queue/requirements\\.jsonl"
---

<objective>
Create JSONL-based persistence layer for question queues and requirements messages.

Purpose: Enable questions and requirements to survive MCP server restarts. File-based storage avoids database dependencies while providing durability.

Output: Two storage modules with atomic write operations and reload capabilities.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-telegram-mcp-server-replace-standalone-bot-with-mcp-integration-using-subscription-tokens/08.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create question queue storage module</name>
  <files>mcp-servers/telegram-mcp/src/storage/question-queue.ts</files>
  <action>
Create the pending questions storage module at `mcp-servers/telegram-mcp/src/storage/question-queue.ts`:

1. Define PendingQuestion interface (per RESEARCH.md):
```typescript
interface PendingQuestion {
  id: string;              // UUID
  question: string;        // Question text
  context?: string;        // Execution context
  status: "pending" | "answered";
  created_at: string;      // ISO timestamp
  answer?: string;         // User's answer (when answered)
  answered_at?: string;    // ISO timestamp (when answered)
}
```

2. Implement CRUD functions:
   - `loadPendingQuestions()`: Read `.planning/telegram-questions/pending.jsonl`, parse each line, return array
   - `appendQuestion(question: Omit<PendingQuestion, 'id' | 'created_at' | 'status'>)`: Generate UUID, append to JSONL, return full question object
   - `markAnswered(questionId: string, answer: string)`: Load all, update matching question's status/answer/answered_at, write atomically
   - `archiveQuestion(questionId: string)`: Remove from pending.jsonl, append to daily log `.planning/telegram-sessions/YYYY-MM-DD.jsonl`
   - `getPendingById(questionId: string)`: Find single question by ID

3. Use atomic write pattern for updates:
```typescript
async function writeAtomic(filePath: string, content: string) {
  const tempPath = `${filePath}.tmp`;
  await fs.writeFile(tempPath, content, 'utf8');
  await fs.rename(tempPath, filePath);
}
```

4. Create directories if they don't exist (`.planning/telegram-questions/`)

5. Handle file-not-found gracefully (return empty array)
  </action>
  <verify>
Write unit tests inline or verify manually:
```bash
cd mcp-servers/telegram-mcp && npm run build && node -e "
import('./dist/storage/question-queue.js').then(async m => {
  const q = await m.appendQuestion({ question: 'Test?', context: 'test' });
  console.log('Created:', q.id);
  const all = await m.loadPendingQuestions();
  console.log('Loaded:', all.length, 'questions');
  await m.markAnswered(q.id, 'Yes');
  const updated = await m.loadPendingQuestions();
  console.log('After mark:', updated[0]?.status);
});
"
```
  </verify>
  <done>
question-queue.ts exists, exports all CRUD functions, JSONL files created in .planning/telegram-questions/.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create message queue storage module</name>
  <files>mcp-servers/telegram-mcp/src/storage/message-queue.ts</files>
  <action>
Create the requirements queue storage module at `mcp-servers/telegram-mcp/src/storage/message-queue.ts`:

1. Define RequirementMessage interface (per RESEARCH.md):
```typescript
interface RequirementMessage {
  message: string;         // Text or transcribed voice
  timestamp: string;       // ISO timestamp
  processed: boolean;      // False until Claude reads via resource
}
```

2. Implement functions:
   - `appendRequirement(message: string)`: Create entry with timestamp, processed=false, append to `.planning/telegram-queue/requirements.jsonl`
   - `loadRequirements()`: Read JSONL, return array of all messages
   - `loadUnprocessedRequirements()`: Filter to processed=false only
   - `markProcessed(timestamp: string)`: Update processed=true for matching entry
   - `clearRequirements()`: Truncate the file (optional cleanup)
   - `getRequirementsAsNDJSON()`: Return raw file content for MCP resource

3. Create directory if it doesn't exist (`.planning/telegram-queue/`)

4. Use append-only pattern for new requirements (no atomic rewrite needed for append)

5. Handle file-not-found gracefully (return empty string for NDJSON, empty array for load)
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm run build && node -e "
import('./dist/storage/message-queue.js').then(async m => {
  await m.appendRequirement('Add dark mode support');
  const all = await m.loadRequirements();
  console.log('Requirements:', all.length);
  const ndjson = await m.getRequirementsAsNDJSON();
  console.log('NDJSON length:', ndjson.length);
});
"
```
  </verify>
  <done>
message-queue.ts exists, exports all functions, requirements.jsonl created on first append.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add storage module exports and verify persistence across restarts</name>
  <files>mcp-servers/telegram-mcp/src/storage/index.ts</files>
  <action>
1. Create `mcp-servers/telegram-mcp/src/storage/index.ts` that re-exports both modules:
```typescript
export * from './question-queue.js';
export * from './message-queue.js';
```

2. Verify persistence survives restart:
   - Append a question, exit process
   - Start new process, load questions, verify question exists
   - Mark answered, exit process
   - Start new process, load questions, verify answered status persisted

3. Test edge cases:
   - Empty file (no questions yet)
   - Malformed JSON line (skip and continue)
   - Concurrent writes (not expected, but log warning if detected)
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm run build && \
node -e "import('./dist/storage/index.js').then(m => m.appendQuestion({question:'Persist test?'}))" && \
node -e "import('./dist/storage/index.js').then(async m => { const q = await m.loadPendingQuestions(); console.log('Persisted:', q.length > 0 && q[0].question === 'Persist test?'); })"
```
Should output: Persisted: true
  </verify>
  <done>
Storage index.ts exports both modules, questions persist across process restarts, JSONL files in .planning/ directories.
  </done>
</task>

</tasks>

<verification>
- [ ] question-queue.ts exports appendQuestion, loadPendingQuestions, markAnswered, archiveQuestion
- [ ] message-queue.ts exports appendRequirement, loadRequirements, getRequirementsAsNDJSON
- [ ] .planning/telegram-questions/ directory created on first write
- [ ] .planning/telegram-queue/ directory created on first write
- [ ] Questions persist across process restarts
- [ ] Atomic writes prevent file corruption
</verification>

<success_criteria>
Persistence layer is complete: questions and requirements survive restarts, atomic writes prevent corruption, ready for MCP tool implementation in Plan 03.
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-telegram-mcp-server-replace-standalone-bot-with-mcp-integration-using-subscription-tokens/08.1-02-SUMMARY.md`
</output>
