# Phase 08.1: Telegram MCP Server - Context

**Gathered:** 2026-02-17
**Status:** Ready for planning

<domain>
## Phase Boundary

Replace standalone Telegram bot (Phase 8) with MCP server that:
- Auto-loads with Claude Code (no manual start)
- Uses Claude Code subscription tokens (not external Haiku API)
- Embeds Telegraf bot in MCP server process
- Integrates with GSD orchestrators for blocking questions
- Fixes architectural issues from Phase 8's standalone approach

**Out of scope:** New bot features beyond current Phase 8 capabilities (Status, Pending Questions, Requirements gathering). Focus is on architecture migration: standalone → MCP.

</domain>

<decisions>
## Implementation Decisions

### MCP Tools Design
- **Blocking question flow:** Orchestrator/sub-orchestrator sends message via MCP tool → message displayed in Telegram pending questions list → user answers → orchestrator receives notification + answer → orchestrator marks question as answered → question disappears from waiting list
- **Question retrieval:** Long polling (check every 30 mins default) + callback notification when answer provided. Polling interval configurable via config file
- **New Requirements subscription:** MCP notifications resource pushes new requirement messages from Telegram to Claude (initiated by user clicking "New Requirements" button). Preferred for context efficiency and stability. Can be enhanced with more functionality later
- **Bot lifecycle:** Telegram bot embedded in MCP server process (single process, auto-loads with Claude Code)
- **Subagent spawning:** Prefer Haiku uses Task tool directly (Claude Code native). MCP tool for spawning may also be needed case-by-case

### Message Flow
- **Telegram message receipt:** Webhooks preferred if free/stable infrastructure with static URL (no config updates on restart). Fallback: long polling with check on bot/MCP server start
- **Message storage:** File-based queue in `.planning/telegram-queue/` (JSONL format). Survives restarts
- **Voice transcription:** Immediate transcription (bot transcribes voice → stores text in queue). Claude always receives text, not audio files
- **Notification timing:** Real-time webhook-driven if webhooks available. Else configurable polling interval (30s default)

### Session State
- **Pending questions tracking:** JSONL file at `.planning/telegram-questions/pending.jsonl` - append new, mark answered, persist across restarts
- **Session logging:** Unified log per day with all messages + questions (single chronological file easier to review than separate sessions)
- **Haiku context management:**
  - Stateless Haiku for ad-hoc flows (requirement gathering subagents)
  - Token budget tracking as safety tool for main Haiku orchestrator
- **Restart behavior:** Persist and reload pending questions from JSONL on MCP server startup. Continue waiting for answers

### Integration Pattern
- **GSD orchestrator integration:** Auto-detect if Telegram MCP available. Use if present, graceful degradation if not. No mandatory dependency
- **Configuration:** Secrets in `.env` (TELEGRAM_BOT_TOKEN, etc.), non-sensitive config in `.planning/config.json`. Separation of concerns

### Logging
- **What to log:** Everything in unified daily log
  - All messages (sent/received with timestamp, user, content)
  - Questions and answers (blocking questions lifecycle)
  - Haiku decisions (routing requirements, spawning subagents, etc.)
  - Errors and warnings (transcription failures, timeouts, API errors)
  - All activity and diagnostic info for debugging and audit trail

### Claude's Discretion
- MCP server pattern (follow Gemini MCP, hybrid with claudeclaw patterns, or custom)
- Language/runtime choice (Python like Gemini MCP, or Node.js to reuse Phase 8 Telegraf/Whisper code)
- Exact webhook implementation (if free/stable solution found)
- Log file naming and rotation strategy
- Queue cleanup and retention policies
- Error recovery strategies

</decisions>

<specifics>
## Specific Ideas

**References analyzed:**
- Phase 8 original research: `.planning/phases/08-notifications-and-observability/08-RESEARCH.md`
- claudeclaw: Slack MCP server (not actually MCP, but Claude Code plugin/daemon pattern)
- User's Gemini MCP: Python-based local server pattern

**Key insights:**
- Phase 8 used Telegraf with event listeners (`.once()`) incompatible with Telegraf's middleware architecture - caused crashes
- claudeclaw uses daemon pattern with heartbeat + cron + Telegram - runs as Claude Code plugin, not MCP server
- MCP server approach is BETTER than claudeclaw daemon because it's standard protocol, auto-loads, uses subscription tokens

**Problem solved:**
- Phase 8 bot required manual start: `node get-shit-done/bin/gsd-tools.js telegram start`
- Phase 8 used external Haiku API keys (costs more than subscription)
- Phase 8 had Telegraf event handling bugs (conversational flow broken)
- MCP server fixes all three: auto-start, subscription tokens, proper architecture

</specifics>

<deferred>
## Deferred Ideas

None — discussion stayed within phase scope (replace standalone bot with MCP server). All Phase 8 features (Status, Pending Questions, Requirements) will be preserved in new architecture.

</deferred>

---

*Phase: 08.1-telegram-mcp-server-replace-standalone-bot-with-mcp-integration-using-subscription-tokens*
*Context gathered: 2026-02-17*
