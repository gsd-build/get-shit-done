---
phase: 08.1-telegram-mcp-server
plan: 04
type: execute
wave: 2
depends_on: ["08.1-01", "08.1-02"]
files_modified:
  - mcp-servers/telegram-mcp/package.json
  - mcp-servers/telegram-mcp/src/bot/telegram-bot.ts
  - mcp-servers/telegram-mcp/src/bot/transcription.ts
  - mcp-servers/telegram-mcp/src/bot/session-logger.ts
autonomous: true

must_haves:
  truths:
    - "Telegraf bot starts in polling mode when MCP server initializes"
    - "Menu buttons work: Status, Pending Questions (no .once() listeners)"
    - "Voice messages transcribed via Whisper pipeline"
    - "Session activity logged to daily JSONL files"
  artifacts:
    - path: "mcp-servers/telegram-mcp/src/bot/telegram-bot.ts"
      provides: "Telegraf bot with middleware-based menu handlers"
      exports: ["startBot", "stopBot", "sendMessage", "bot"]
      min_lines: 150
    - path: "mcp-servers/telegram-mcp/src/bot/transcription.ts"
      provides: "Whisper transcription pipeline (ported from Phase 8)"
      exports: ["transcribeAudio", "checkWhisperModel"]
      min_lines: 60
    - path: "mcp-servers/telegram-mcp/src/bot/session-logger.ts"
      provides: "Session logging to daily JSONL files"
      exports: ["startSession", "endSession", "logMessage", "logBotResponse"]
      min_lines: 80
  key_links:
    - from: "mcp-servers/telegram-mcp/src/bot/telegram-bot.ts"
      to: "mcp-servers/telegram-mcp/src/storage/question-queue.ts"
      via: "loadPendingQuestions import"
      pattern: "loadPendingQuestions"
    - from: "mcp-servers/telegram-mcp/src/bot/telegram-bot.ts"
      to: "telegraf"
      via: "Telegraf import"
      pattern: "import.*Telegraf"
---

<objective>
Integrate Telegram bot into MCP server, reusing Phase 8 code with fixed menu handlers.

Purpose: Embed Telegraf bot in MCP server process for single lifecycle management. Fix the .once() bug from Phase 8 by using middleware pattern with ctx.session.

Output: Working Telegram bot with Status and Pending Questions buttons, voice transcription, session logging.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-telegram-mcp-server-replace-standalone-bot-with-mcp-integration-using-subscription-tokens/08.1-RESEARCH.md
@get-shit-done/bin/telegram-bot.js
@get-shit-done/bin/whisper-transcribe.js
@get-shit-done/bin/telegram-session-logger.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Telegram dependencies and create session logger</name>
  <files>
    mcp-servers/telegram-mcp/package.json
    mcp-servers/telegram-mcp/src/bot/session-logger.ts
  </files>
  <action>
1. Update `mcp-servers/telegram-mcp/package.json` to add dependencies:
```json
{
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "telegraf": "^4.16.0",
    "dotenv": "^16.0.0"
  }
}
```

Run `npm install` after updating.

2. Create `mcp-servers/telegram-mcp/src/bot/session-logger.ts`:

Port the session logger from Phase 8 (`get-shit-done/bin/telegram-session-logger.js`) to TypeScript:
- Keep JSONL format for daily logs
- Store in `.planning/telegram-sessions/YYYY-MM-DD.jsonl` (unified daily log per user decision)
- Export functions: startSession, endSession, logEvent, logMessage, logBotResponse, logDecision

Key change from Phase 8: Use unified daily log file instead of per-session timestamp files.

```typescript
// Daily log path pattern
function getDailyLogPath(): string {
  const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  return path.join(PROJECT_ROOT, '.planning', 'telegram-sessions', `${date}.jsonl`);
}
```

All functions should be async-safe (use appendFileSync or proper async handling).
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm install && npm run build && node -e "
import('./dist/bot/session-logger.js').then(async m => {
  const path = m.startSession();
  m.logMessage(123, 'testuser', 'text', 'Hello world');
  m.logBotResponse('Hi there');
  console.log('Session path:', path);
});
"
```
Should create/append to daily log file.
  </verify>
  <done>
Session logger TypeScript module exists, writes to daily JSONL files, all log functions working.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Whisper transcription module</name>
  <files>mcp-servers/telegram-mcp/src/bot/transcription.ts</files>
  <action>
Port the transcription module from Phase 8 (`get-shit-done/bin/whisper-transcribe.js`) to TypeScript:

1. Keep the same logic:
   - Download audio from Telegram URL
   - Convert to 16kHz mono WAV via ffmpeg
   - Transcribe with Whisper base.en model
   - Clean up temp files

2. Update package.json to add dependencies:
```json
{
  "dependencies": {
    "fluent-ffmpeg": "^2.1.0",
    "@ffmpeg-installer/ffmpeg": "^1.1.0"
  },
  "devDependencies": {
    "@types/fluent-ffmpeg": "^2.1.0"
  }
}
```

3. Handle whisper-node lazy loading (it corrupts cwd on import):
```typescript
// Lazy-load to avoid cwd corruption
async function getWhisper() {
  const whisper = await import('whisper-node');
  return whisper.default;
}
```

4. Export: transcribeAudio, checkWhisperModel, WHISPER_MODEL

Note: whisper-node is a devDependency that must be installed separately. checkWhisperModel should return clear instructions if not installed.
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm install fluent-ffmpeg @ffmpeg-installer/ffmpeg && npm run build && node -e "
import('./dist/bot/transcription.js').then(async m => {
  const status = await m.checkWhisperModel();
  console.log('Whisper available:', status.available);
  console.log('Message:', status.message || status.path);
});
"
```
  </verify>
  <done>
Transcription module compiles, checkWhisperModel returns status, ready for voice message handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Telegram bot with middleware-based menu handlers</name>
  <files>mcp-servers/telegram-mcp/src/bot/telegram-bot.ts</files>
  <action>
Create `mcp-servers/telegram-mcp/src/bot/telegram-bot.ts` with FIXED menu handler pattern:

1. Initialize Telegraf with session middleware:
```typescript
import { Telegraf, Markup, session } from 'telegraf';
import type { Context } from 'telegraf';

interface SessionData {
  awaitingRequirement: boolean;
  awaitingQuestionResponse: string | null;
}

interface BotContext extends Context {
  session: SessionData;
}

const bot = new Telegraf<BotContext>(process.env.TELEGRAM_BOT_TOKEN!);
bot.use(session({ defaultSession: () => ({ awaitingRequirement: false, awaitingQuestionResponse: null }) }));
```

2. Create menu keyboard (per user decision, New Requirements DISABLED for now):
```typescript
const MAIN_MENU = Markup.inlineKeyboard([
  [
    Markup.button.callback('Status', 'menu:status'),
    Markup.button.callback('Pending', 'menu:pending')
  ]
]);
```

3. Register menu action handlers (NOT .once() - use bot.action):
```typescript
bot.action('menu:status', async (ctx) => {
  // Load STATE.md and show current position
  await ctx.answerCbQuery();
  const status = await getGSDStatus();
  await ctx.editMessageText(status, Markup.inlineKeyboard([
    Markup.button.callback('Back', 'back:main')
  ]));
});

bot.action('menu:pending', async (ctx) => {
  await ctx.answerCbQuery();
  const questions = await loadPendingQuestions();
  // Show questions with answer buttons
});

bot.action('back:main', async (ctx) => {
  await ctx.answerCbQuery();
  await ctx.editMessageText('Main Menu:', MAIN_MENU);
});
```

4. Handle text messages:
   - If ctx.session.awaitingQuestionResponse is set, route to that question
   - If single pending question, auto-match response
   - Otherwise show menu

5. Handle voice messages:
   - Transcribe via transcription module
   - Route transcribed text same as text messages

6. Export: startBot, stopBot, sendMessage, getBot, MAIN_MENU

7. Bot lifecycle management:
```typescript
let botStarted = false;

async function startBot() {
  if (botStarted) return;
  startSession();
  await bot.launch();
  botStarted = true;
}

function stopBot() {
  if (!botStarted) return;
  endSession();
  bot.stop('SIGTERM');
  botStarted = false;
}
```
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm run build && node -e "
import('./dist/bot/telegram-bot.js').then(m => {
  console.log('Exports:', Object.keys(m));
  console.log('Has startBot:', typeof m.startBot === 'function');
  console.log('Has MAIN_MENU:', !!m.MAIN_MENU);
});
"
```
Should show startBot, stopBot, sendMessage, getBot, MAIN_MENU exports.
  </verify>
  <done>
Telegram bot module compiles, uses session middleware for state, action handlers registered (not .once()), ready for integration.
  </done>
</task>

</tasks>

<verification>
- [ ] Telegraf and dependencies installed in mcp-servers/telegram-mcp
- [ ] session-logger.ts writes to daily JSONL files
- [ ] transcription.ts compiles and exports checkWhisperModel
- [ ] telegram-bot.ts uses session middleware (not .once() listeners)
- [ ] Menu action handlers registered for status, pending, back
- [ ] Bot can be started/stopped programmatically
</verification>

<success_criteria>
Telegram bot is embedded in MCP server project with fixed menu handlers. Bot uses middleware pattern that works with Telegraf. Ready for MCP server integration in Plan 05.
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-telegram-mcp-server-replace-standalone-bot-with-mcp-integration-using-subscription-tokens/08.1-04-SUMMARY.md`
</output>
