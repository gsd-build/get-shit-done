---
phase: 08.1-telegram-mcp-server
plan: 05
type: execute
wave: 3
depends_on: ["08.1-03", "08.1-04"]
files_modified:
  - mcp-servers/telegram-mcp/src/index.ts
  - mcp-servers/telegram-mcp/src/resources/requirements.ts
  - mcp-servers/telegram-mcp/src/tools/ask-question.ts
autonomous: true

must_haves:
  truths:
    - "MCP server starts Telegram bot on initialize"
    - "ask_blocking_question sends message to Telegram chat"
    - "User answers in Telegram update question status in storage"
    - "telegram://requirements/new resource returns JSONL content"
  artifacts:
    - path: "mcp-servers/telegram-mcp/src/resources/requirements.ts"
      provides: "MCP resource handler for requirements JSONL"
      exports: ["REQUIREMENTS_RESOURCE_DEF", "readRequirementsResource"]
      min_lines: 30
    - path: "mcp-servers/telegram-mcp/src/index.ts"
      provides: "MCP server with bot lifecycle and resource handlers"
      min_lines: 150
  key_links:
    - from: "mcp-servers/telegram-mcp/src/index.ts"
      to: "mcp-servers/telegram-mcp/src/bot/telegram-bot.ts"
      via: "startBot import and call"
      pattern: "startBot"
    - from: "mcp-servers/telegram-mcp/src/tools/ask-question.ts"
      to: "mcp-servers/telegram-mcp/src/bot/telegram-bot.ts"
      via: "sendMessage import"
      pattern: "sendMessage"
---

<objective>
Wire Telegram bot into MCP server lifecycle and connect tools to actual Telegram messaging.

Purpose: Complete the integration so ask_blocking_question actually sends to Telegram, and the requirements resource provides real data.

Output: Fully integrated MCP server that starts bot on init, sends questions to Telegram, and exposes requirements resource.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-telegram-mcp-server-replace-standalone-bot-with-mcp-integration-using-subscription-tokens/08.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create requirements resource handler</name>
  <files>mcp-servers/telegram-mcp/src/resources/requirements.ts</files>
  <action>
Create `mcp-servers/telegram-mcp/src/resources/requirements.ts`:

1. Define resource definition:
```typescript
export const REQUIREMENTS_RESOURCE_DEF = {
  uri: 'telegram://requirements/new',
  name: 'New Requirements from Telegram',
  description: 'JSONL stream of new requirement messages from user',
  mimeType: 'application/x-ndjson'
};
```

2. Create resource read handler:
```typescript
import { getRequirementsAsNDJSON } from '../storage/message-queue.js';

export async function readRequirementsResource(uri: string) {
  if (uri !== 'telegram://requirements/new') {
    throw new Error(`Unknown resource: ${uri}`);
  }

  const content = await getRequirementsAsNDJSON();

  return {
    contents: [{
      uri,
      mimeType: 'application/x-ndjson',
      text: content
    }]
  };
}
```

3. Create resources index at `mcp-servers/telegram-mcp/src/resources/index.ts`:
```typescript
export { REQUIREMENTS_RESOURCE_DEF, readRequirementsResource } from './requirements.js';
```
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm run build && node -e "
import('./dist/resources/requirements.js').then(async m => {
  console.log('Resource URI:', m.REQUIREMENTS_RESOURCE_DEF.uri);
  const result = await m.readRequirementsResource('telegram://requirements/new');
  console.log('Has contents:', Array.isArray(result.contents));
});
"
```
  </verify>
  <done>
Requirements resource handler exports definition and read function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ask_blocking_question to send Telegram message</name>
  <files>mcp-servers/telegram-mcp/src/tools/ask-question.ts</files>
  <action>
Update `mcp-servers/telegram-mcp/src/tools/ask-question.ts` to send actual Telegram message:

1. Import sendMessage from bot module:
```typescript
import { sendMessage, getBot } from '../bot/telegram-bot.js';
```

2. Update handler to send Telegram message after creating question:
```typescript
export async function askBlockingQuestionHandler(input: AskQuestionInput): Promise<AskQuestionOutput> {
  // Validate input
  if (!input.question || input.question.trim().length === 0) {
    throw new Error('question is required');
  }

  // Create question in storage
  const question = await appendQuestion({
    question: input.question,
    context: input.context
  });

  // Send to Telegram
  const chatId = process.env.TELEGRAM_OWNER_ID;
  if (chatId) {
    const message = formatQuestionMessage(question);
    await sendMessage(parseInt(chatId, 10), message);
  }

  return {
    question_id: question.id,
    asked_at: question.created_at,
    status: 'pending'
  };
}

function formatQuestionMessage(question: PendingQuestion): string {
  let msg = `Question from Claude:\n\n${question.question}\n\n`;
  msg += `ID: ${question.id}\n`;
  if (question.context) {
    msg += `Context: ${question.context}\n`;
  }
  msg += `\nReply with your answer or use the Pending Questions button.`;
  return msg;
}
```

3. Handle case when TELEGRAM_OWNER_ID not set (log warning, still return question_id).
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm run build
# Verify code compiles. Actual Telegram send tested in integration test.
```
  </verify>
  <done>
ask_blocking_question creates question and sends Telegram message (when bot running and chat ID set).
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire bot lifecycle and resources into MCP server</name>
  <files>mcp-servers/telegram-mcp/src/index.ts</files>
  <action>
Update `mcp-servers/telegram-mcp/src/index.ts` to integrate everything:

1. Import bot and resource modules:
```typescript
import { startBot, stopBot } from './bot/telegram-bot.js';
import { REQUIREMENTS_RESOURCE_DEF, readRequirementsResource } from './resources/index.js';
```

2. Start bot after server connects to transport:
```typescript
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);

  // Start Telegram bot if token available
  if (process.env.TELEGRAM_BOT_TOKEN) {
    try {
      await startBot();
      console.error('[telegram-mcp] Telegram bot started');
    } catch (err) {
      console.error('[telegram-mcp] Bot start failed:', err);
    }
  } else {
    console.error('[telegram-mcp] TELEGRAM_BOT_TOKEN not set, bot disabled');
  }
}
```

3. Wire resource handlers:
```typescript
server.setRequestHandler(ListResourcesRequestSchema, async () => ({
  resources: [REQUIREMENTS_RESOURCE_DEF]
}));

server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  return readRequirementsResource(request.params.uri);
});
```

4. Handle graceful shutdown:
```typescript
process.on('SIGINT', () => {
  stopBot();
  process.exit(0);
});

process.on('SIGTERM', () => {
  stopBot();
  process.exit(0);
});
```

5. Load .env at startup:
```typescript
import 'dotenv/config';
```

6. Log to stderr only (stdout is JSON-RPC channel).
  </action>
  <verify>
```bash
cd mcp-servers/telegram-mcp && npm run build && \
echo '{"jsonrpc":"2.0","method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test"}},"id":1}
{"jsonrpc":"2.0","method":"resources/list","params":{},"id":2}
{"jsonrpc":"2.0","method":"resources/read","params":{"uri":"telegram://requirements/new"},"id":3}' | timeout 2 node dist/index.js 2>/dev/null | grep -c '"jsonrpc"'
```
Should output 3 (three JSON-RPC responses).
  </verify>
  <done>
MCP server starts bot on init, handles graceful shutdown, resources/list and resources/read work.
  </done>
</task>

</tasks>

<verification>
- [ ] MCP server starts Telegram bot when TELEGRAM_BOT_TOKEN is set
- [ ] ask_blocking_question sends message to Telegram chat
- [ ] resources/list returns telegram://requirements/new
- [ ] resources/read returns JSONL content from queue
- [ ] Graceful shutdown stops bot before exit
- [ ] All logging goes to stderr (stdout reserved for JSON-RPC)
</verification>

<success_criteria>
MCP server is fully integrated: bot starts with server, tools send Telegram messages, resources provide data. Ready for Claude Code configuration and orchestrator integration in Plan 06.
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-telegram-mcp-server-replace-standalone-bot-with-mcp-integration-using-subscription-tokens/08.1-05-SUMMARY.md`
</output>
