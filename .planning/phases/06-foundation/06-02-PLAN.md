---
phase: 06-foundation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - get-shit-done/bin/gsd-tools.cjs
  - bin/install.js
autonomous: true

must_haves:
  truths:
    - "User can run `gsd-tools.cjs coplanner detect --raw` and see which CLIs are installed with version info in a human-readable table"
    - "User can run `gsd-tools.cjs coplanner detect` and get structured JSON output (default mode, consistent with gsd-tools.cjs convention)"
    - "User can run `gsd-tools.cjs coplanner enabled` and see the kill switch status with its source"
    - "User can set co_planners.enabled:false in config.json and invoke returns silent skip"
    - "User can set GSD_CO_PLANNERS=true env var and it overrides config.json"
    - "User can invoke a CLI via `gsd-tools.cjs coplanner invoke codex --prompt text` and receive normalized output"
    - "When a CLI is missing/fails/times out, the command returns structured error instead of crashing"
    - "Adapters directory is copied during installation alongside other get-shit-done files"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.cjs"
      provides: "coplanner command group (detect, invoke, enabled)"
      contains: "coplanner"
    - path: "bin/install.js"
      provides: "Adapter directory installation support"
      contains: "adapters"
  key_links:
    - from: "get-shit-done/bin/gsd-tools.cjs"
      to: "get-shit-done/bin/adapters/*.cjs"
      via: "require() via loadAdapter()"
      pattern: "loadAdapter"
    - from: "get-shit-done/bin/gsd-tools.cjs"
      to: ".planning/config.json"
      via: "checkKillSwitch() reads co_planners.enabled"
      pattern: "co_planners"
    - from: "get-shit-done/bin/gsd-tools.cjs"
      to: "process.env.GSD_CO_PLANNERS"
      via: "env var override in checkKillSwitch()"
      pattern: "GSD_CO_PLANNERS"
    - from: "bin/install.js"
      to: "get-shit-done/bin/adapters/"
      via: "copyWithPathReplacement handles subdirectories recursively"
      pattern: "adapters"
---

<objective>
Wire adapter modules into gsd-tools.cjs as the `coplanner` command group and ensure the adapters/ directory is installed correctly.

Purpose: This plan connects the adapter building blocks (from Plan 01) to the GSD CLI interface, making detection, invocation, and kill switch functionality accessible to workflows and users. It also ensures the adapters/ directory survives the installation process.

Output: Three new gsd-tools.cjs commands (`coplanner detect`, `coplanner invoke`, `coplanner enabled`) and updated install.js.
</objective>

<execution_context>
@/Users/zpyoung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zpyoung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-foundation/06-CONTEXT.md
@.planning/phases/06-foundation/06-RESEARCH.md
@.planning/phases/06-foundation/06-01-SUMMARY.md
@get-shit-done/bin/gsd-tools.cjs
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add coplanner command group to gsd-tools.cjs</name>
  <files>get-shit-done/bin/gsd-tools.cjs</files>
  <action>
Add the `coplanner` command group to gsd-tools.cjs. This involves three parts:

**Part A: Helper functions** (add near the top, after existing helper functions like `execGit` around line 244):

1. `loadAdapter(cliName)` -- Load adapter from `adapters/` directory via `require()`. Returns the adapter module or null if file doesn't exist. Uses `path.join(__dirname, 'adapters', cliName + '.cjs')`.

2. `checkKillSwitch(cwd)` -- Check if co-planners are enabled. Returns `{ enabled: bool, source: "env"|"config"|"default" }`. Precedence: `process.env.GSD_CO_PLANNERS` (parse "true"/"1" as enabled) > `config.json co_planners.enabled` > default `false`.

3. `SUPPORTED_CLIS` constant -- `['codex', 'gemini', 'opencode']`.

**Part B: Command functions:**

1. `cmdCoplannerDetect(cwd, raw)` -- Iterate SUPPORTED_CLIS, load each adapter, call `adapter.detect()`. Collect results as `{ [cli]: { available, version, error } }`. If `raw` is true, output human-readable table via `output(results, true, tableString)`:
```
CLI        Available  Version
codex      yes        codex-cli 0.101.0
gemini     no         NOT_FOUND
opencode   yes        1.1.65
```
If `raw` is false (default), call `output(results, false)` for JSON. This follows the standard gsd-tools.cjs convention: JSON by default, `--raw` for human-readable text.

2. `cmdCoplannerInvoke(cwd, cliName, prompt, options, raw)` -- First check kill switch via `checkKillSwitch(cwd)`. If disabled, return `{ skipped: true, reason: "co-planners disabled", source: killSwitch.source }` (NOT an error -- silent skip per user decision). Then load adapter for `cliName`. If adapter not found, return error result `{ text: "", cli: cliName, duration: 0, exitCode: 1, error: "Unknown CLI", errorType: "NO_ADAPTER" }`. Call `adapter.invoke(prompt, { timeout: options.timeout, model: options.model })`. Return result via `output()`.

3. `cmdCoplannerEnabled(cwd, raw)` -- Call `checkKillSwitch(cwd)` and return result via `output()`. If raw, print `enabled` or `disabled` plus source.

**Part C: Main switch case** (add before the `default:` case near end of file):

```javascript
case 'coplanner': {
  const subCmd = args[1];
  switch (subCmd) {
    case 'detect': {
      cmdCoplannerDetect(cwd, raw);
      break;
    }
    case 'invoke': {
      const cliName = args[2];
      if (!cliName) error('CLI name required: codex, gemini, or opencode');
      const promptIdx = args.indexOf('--prompt');
      const prompt = promptIdx !== -1 ? args[promptIdx + 1] : null;
      if (!prompt) error('--prompt required');
      const timeoutIdx = args.indexOf('--timeout');
      const timeout = timeoutIdx !== -1 ? parseInt(args[timeoutIdx + 1], 10) : undefined;
      const modelIdx = args.indexOf('--model');
      const model = modelIdx !== -1 ? args[modelIdx + 1] : undefined;
      cmdCoplannerInvoke(cwd, cliName, prompt, { timeout, model }, raw);
      break;
    }
    case 'enabled': {
      cmdCoplannerEnabled(cwd, raw);
      break;
    }
    default:
      error('Unknown coplanner subcommand: ' + subCmd + '. Use: detect, invoke, enabled');
  }
  break;
}
```

**IMPORTANT â€” Convention alignment:** The CONTEXT.md locked decision says "table by default, `--json` for structured." However, gsd-tools.cjs already has a global `--raw` flag convention (parsed once in `main()`, passed to all commands). Introducing a separate `--json` flag just for `coplanner detect` would create an inconsistent convention.

**Resolution:** Use the EXISTING `--raw` convention. `coplanner detect --raw` outputs the human-readable table (text output, same as every other gsd-tools.cjs command with `--raw`). Without `--raw`, it outputs JSON (standard default). This honors the CONTEXT.md intent (two output modes: table + structured JSON) while staying consistent with the rest of gsd-tools.cjs. Do NOT introduce a new `--json` flag.

Also add the command group to the usage comment header at the top of the file.
  </action>
  <verify>
1. `node get-shit-done/bin/gsd-tools.cjs coplanner detect --raw` -- Should output human-readable table
2. `node get-shit-done/bin/gsd-tools.cjs coplanner detect` -- Should output JSON (default mode)
3. `node get-shit-done/bin/gsd-tools.cjs coplanner enabled` -- Should output `{ enabled: false, source: "default" }` or based on config
4. **Kill switch precedence chain (all three steps, in order):**
   a. `node get-shit-done/bin/gsd-tools.cjs coplanner enabled` -- Shows default (false, "default")
   b. Set `co_planners.enabled: true` in `.planning/config.json`, then `node get-shit-done/bin/gsd-tools.cjs coplanner enabled` -- Shows (true, "config")
   c. `GSD_CO_PLANNERS=false node get-shit-done/bin/gsd-tools.cjs coplanner enabled` -- Shows (false, "env") -- env overrides config
   d. `GSD_CO_PLANNERS=true node get-shit-done/bin/gsd-tools.cjs coplanner enabled` -- Shows (true, "env")
5. `node get-shit-done/bin/gsd-tools.cjs coplanner invoke codex --prompt "say hello"` -- Should return result or skip if disabled
6. **Temp file cleanup on invoke error:** Invoke a non-existent CLI name that has a valid adapter (e.g., codex when codex is not installed). After the command completes (with error result), run `ls /tmp/gsd-codex-* 2>/dev/null` -- should show no leftover temp files. This verifies the adapter's `finally` block cleaned up. (Note: temp file is created inside `adapter.invoke()` which is Plan 01's code -- this verify step confirms the integration path cleans up correctly.)
  </verify>
  <done>
gsd-tools.cjs has `coplanner` command group with `detect`, `invoke`, and `enabled` subcommands. Detection shows installed CLIs. Kill switch respects env var > config > default precedence. Invocation returns normalized output. All error paths return structured objects, never throw.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify install.js handles adapters/ directory</name>
  <files>bin/install.js</files>
  <action>
**Step 1: Run the installer and verify adapters are copied.**

Run `node bin/install.js --claude --local` to perform a local installation. Then check whether the adapters directory was copied:

```bash
node bin/install.js --claude --local
ls -la .claude/get-shit-done/bin/adapters/
```

The `copyWithPathReplacement` function in install.js handles recursive directory copying (line 692: `if (entry.isDirectory()) { copyWithPathReplacement(srcPath, destPath, ...) }`). The adapters/ directory lives inside `get-shit-done/bin/` and the installer copies the entire `get-shit-done/` tree via `copyWithPathReplacement(skillSrc, skillDest, ...)` (line 1393). The `.cjs` adapter files are handled by the `else` branch at line 718: `fs.copyFileSync(srcPath, destPath)` -- direct copy without path replacement, which is correct since adapters use `__dirname` for path resolution.

**Step 2: If Step 1 shows the adapters directory is present with all three files (codex.cjs, gemini.cjs, opencode.cjs), no install.js changes are needed.**

**Step 3: If Step 1 reveals the adapters directory is MISSING**, add explicit fallback copy logic after the get-shit-done skill copy (around line 1393):

```javascript
// After the get-shit-done skill copy
// Ensure adapters directory was included
const adaptersCheck = path.join(skillDest, 'bin', 'adapters');
if (!fs.existsSync(adaptersCheck)) {
  const adaptersSrc = path.join(skillSrc, 'bin', 'adapters');
  if (fs.existsSync(adaptersSrc)) {
    copyWithPathReplacement(adaptersSrc, adaptersCheck, pathPrefix, runtime);
  }
}
```

**Step 4: Verify the installed coplanner commands work from the installed location** (not just the source tree):

```bash
node .claude/get-shit-done/bin/gsd-tools.cjs coplanner detect
```

This confirms the full path chain: install.js -> adapters copied -> gsd-tools.cjs -> loadAdapter() -> adapter files found.
  </action>
  <verify>
Run `node bin/install.js --claude --local` then verify ALL of these:
1. `ls .claude/get-shit-done/bin/adapters/` shows codex.cjs, gemini.cjs, opencode.cjs
2. `node .claude/get-shit-done/bin/gsd-tools.cjs coplanner detect` works from installed location and produces JSON output
3. `node .claude/get-shit-done/bin/gsd-tools.cjs coplanner detect --raw` produces table output from installed location
  </verify>
  <done>
Adapters directory is correctly installed. Running `gsd-tools.cjs coplanner detect` from the installed location produces expected output. All three adapter .cjs files are present in the installed adapters/ directory.
  </done>
</task>

</tasks>

<verification>
1. `gsd-tools.cjs coplanner detect` outputs JSON (default mode)
2. `gsd-tools.cjs coplanner detect --raw` outputs human-readable table of CLI availability
3. `gsd-tools.cjs coplanner enabled` shows kill switch status and source
4. **Kill switch precedence chain:** (a) default shows false/"default", (b) config override shows true/"config", (c) `GSD_CO_PLANNERS=false` overrides config to show false/"env", (d) `GSD_CO_PLANNERS=true` overrides to show true/"env"
5. `gsd-tools.cjs coplanner invoke codex --prompt "test"` returns normalized output with fields: `{ text, cli, duration, exitCode, error, errorType }` (or skip object if disabled)
6. Invoking with non-existent CLI returns structured error with `errorType: "NO_ADAPTER"`, not crash
7. After invoke error path, no temp files remain in `os.tmpdir()` matching `gsd-*` pattern
8. `node bin/install.js --claude --local` copies adapters/ directory -- verified by `ls .claude/get-shit-done/bin/adapters/` showing all three .cjs files AND `coplanner detect` working from installed path
9. All three requirements (INFRA-01, INFRA-02, CORE-03) verified
</verification>

<success_criteria>
- `coplanner detect` works in both JSON (default) and table (`--raw`) modes, consistent with gsd-tools.cjs convention
- `coplanner enabled` correctly reports kill switch status with full precedence: env > config > default (verified with all three sources)
- `coplanner invoke` normalizes CLI output to `{ text, cli, duration, exitCode, error, errorType }` schema
- Missing/failed CLIs produce structured error responses, never crashes
- Temp files from failed invocations are cleaned up (no leaks in os.tmpdir())
- Adapters directory survives installation -- verified by running `node bin/install.js --claude --local` and confirming files exist AND commands work from installed path
- All Phase 6 success criteria from ROADMAP.md are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/06-foundation/06-02-SUMMARY.md`
</output>
