---
phase: 08-notifications-and-observability
plan: 05
type: execute
wave: 2
depends_on: ["08-03"]
files_modified:
  - get-shit-done/bin/dashboard-server.js
  - get-shit-done/bin/savings-report.js
  - get-shit-done/bin/gsd-tools.js
autonomous: true

must_haves:
  truths:
    - "Real-time dashboard shows execution status via EXECUTION_LOG.md streaming"
    - "Dashboard updates via WebSocket when new events are appended"
    - "Token savings report compares auto mode vs manual profiles"
    - "Report shows cost breakdown by model tier"
  artifacts:
    - path: "get-shit-done/bin/dashboard-server.js"
      provides: "WebSocket server streaming EXECUTION_LOG.md events"
      exports: ["startDashboard", "stopDashboard"]
    - path: "get-shit-done/bin/savings-report.js"
      provides: "Token savings calculation comparing auto vs fixed profiles"
      exports: ["calculateSavings", "generateReport"]
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "dashboard and savings commands"
      contains: "dashboard"
  key_links:
    - from: "dashboard-server.js"
      to: "execution-log.js"
      via: "imports getHistory for initial state"
      pattern: "require.*execution-log"
    - from: "savings-report.js"
      to: "llm-metrics.js"
      via: "uses CLAUDE_PRICING for cost calculation"
      pattern: "require.*llm-metrics"
---

<objective>
Create real-time progress dashboard and token savings reporting for production observability

Purpose: Provide visibility into autonomous execution progress via streaming dashboard, and quantify value of auto mode via detailed cost savings analysis comparing to hypothetical all-Opus execution.

Output: WebSocket-based dashboard server and savings report generation with detailed analytics.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-notifications-and-observability/08-RESEARCH.md
@.planning/phases/06-autonomous-execution-core/06-03-SUMMARY.md
@.planning/phases/08-notifications-and-observability/08-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard-server.js for real-time streaming</name>
  <files>get-shit-done/bin/dashboard-server.js</files>
  <action>
Install WebSocket dependency and create dashboard server:

1. Install dependency:
   ```bash
   cd get-shit-done && npm install ws
   ```

2. Create dashboard-server.js:

```javascript
/**
 * Real-time Progress Dashboard
 *
 * Streams EXECUTION_LOG.md events via WebSocket for live progress tracking.
 * Pattern: NDJSON streaming with file watching
 * Source: Phase 8 Research - Pattern 5
 */

const WebSocket = require('ws');
const http = require('http');
const fs = require('fs');
const path = require('path');

// Import execution log helpers
const { getHistory, getExecutionStats } = require('./execution-log.js');

let wss = null;
let httpServer = null;
let fileWatcher = null;

const DASHBOARD_HTML = `
<!DOCTYPE html>
<html>
<head>
  <title>GSD Execution Dashboard</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1e1e1e; color: #d4d4d4; margin: 0; }
    h1 { color: #4ec9b0; margin-bottom: 20px; }
    .container { display: flex; gap: 20px; }
    .events { flex: 2; max-height: 80vh; overflow-y: auto; }
    .stats { flex: 1; position: sticky; top: 20px; background: #252526; padding: 15px; border: 1px solid #3c3c3c; border-radius: 4px; height: fit-content; }
    .event { padding: 10px; margin: 5px 0; background: #2d2d2d; border-left: 3px solid #007acc; border-radius: 2px; }
    .phase_start { border-color: #4ec9b0; }
    .phase_complete { border-color: #b5cea8; }
    .phase_failed { border-color: #f48771; }
    .checkpoint { border-color: #dcdcaa; }
    .roadmap_start { border-color: #569cd6; background: #2d3748; }
    .roadmap_complete { border-color: #9cdcfe; background: #2d3748; }
    .time { color: #808080; }
    .type { font-weight: bold; color: #9cdcfe; }
    .message { margin-top: 5px; }
    .stat-row { display: flex; justify-content: space-between; margin: 8px 0; }
    .stat-label { color: #808080; }
    .stat-value { color: #4ec9b0; font-weight: bold; }
    .connected { color: #b5cea8; }
    .disconnected { color: #f48771; }
  </style>
</head>
<body>
  <h1>GSD Autonomous Execution Dashboard</h1>
  <div class="container">
    <div class="events" id="events">
      <p style="color: #808080;">Connecting to WebSocket...</p>
    </div>
    <div class="stats" id="stats">
      <h3>Statistics</h3>
      <div class="stat-row"><span class="stat-label">Status:</span><span class="stat-value disconnected" id="status">Connecting...</span></div>
      <div class="stat-row"><span class="stat-label">Phases Completed:</span><span class="stat-value" id="phases-completed">-</span></div>
      <div class="stat-row"><span class="stat-label">Phases Failed:</span><span class="stat-value" id="phases-failed">-</span></div>
      <div class="stat-row"><span class="stat-label">Checkpoints:</span><span class="stat-value" id="checkpoints">-</span></div>
      <div class="stat-row"><span class="stat-label">Events:</span><span class="stat-value" id="event-count">0</span></div>
    </div>
  </div>

  <script>
    const eventsDiv = document.getElementById('events');
    const statusEl = document.getElementById('status');
    let eventCount = 0;

    function connect() {
      const ws = new WebSocket('ws://localhost:8080');

      ws.onopen = () => {
        statusEl.textContent = 'Connected';
        statusEl.className = 'stat-value connected';
        eventsDiv.innerHTML = '';
      };

      ws.onmessage = (msg) => {
        const data = JSON.parse(msg.data);

        if (data.type === 'initial_state') {
          data.events.forEach(renderEvent);
          updateStats(data.stats);
        } else if (data.type === 'event') {
          renderEvent(data.event);
          eventCount++;
          document.getElementById('event-count').textContent = eventCount;
        }
      };

      ws.onclose = () => {
        statusEl.textContent = 'Disconnected';
        statusEl.className = 'stat-value disconnected';
        setTimeout(connect, 3000);
      };
    }

    function renderEvent(event) {
      const div = document.createElement('div');
      div.className = 'event ' + (event.type || '');
      const time = event.timestamp ? new Date(event.timestamp).toLocaleTimeString() : '-';
      div.innerHTML = \`
        <span class="time">[\${time}]</span>
        <span class="type">\${event.type || 'unknown'}</span>
        \${event.phase ? ' - Phase ' + event.phase : ''}
        \${event.message ? '<div class="message">' + event.message + '</div>' : ''}
      \`;
      eventsDiv.insertBefore(div, eventsDiv.firstChild);
      eventCount++;
    }

    function updateStats(stats) {
      document.getElementById('phases-completed').textContent = stats.phases_completed || 0;
      document.getElementById('phases-failed').textContent = stats.phases_failed || 0;
      document.getElementById('checkpoints').textContent = stats.checkpoint_count || 0;
      eventCount = stats.total_events || 0;
      document.getElementById('event-count').textContent = eventCount;
    }

    connect();
  </script>
</body>
</html>
`;

/**
 * Start the dashboard server
 * @param {object} options - { httpPort, wsPort, logPath }
 */
function startDashboard(options = {}) {
  const httpPort = options.httpPort || 3000;
  const wsPort = options.wsPort || 8080;
  const logPath = options.logPath || '.planning/EXECUTION_LOG.md';

  // HTTP server for dashboard HTML
  httpServer = http.createServer((req, res) => {
    if (req.url === '/' || req.url === '/dashboard') {
      res.writeHead(200, { 'Content-Type': 'text/html' });
      res.end(DASHBOARD_HTML);
    } else if (req.url === '/health') {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'ok' }));
    } else {
      res.writeHead(404);
      res.end('Not Found');
    }
  });

  // WebSocket server for real-time updates
  wss = new WebSocket.Server({ port: wsPort });

  wss.on('connection', (ws) => {
    console.log('Dashboard client connected');

    // Send initial state
    try {
      const events = getHistory(process.cwd());
      const stats = getExecutionStats(process.cwd());
      ws.send(JSON.stringify({
        type: 'initial_state',
        events,
        stats
      }));
    } catch (error) {
      console.error('Error sending initial state:', error.message);
    }

    ws.on('close', () => {
      console.log('Dashboard client disconnected');
    });
  });

  // Watch log file for changes
  if (fs.existsSync(logPath)) {
    let lastSize = fs.statSync(logPath).size;

    fileWatcher = fs.watch(logPath, (eventType) => {
      if (eventType === 'change') {
        const currentSize = fs.statSync(logPath).size;

        if (currentSize > lastSize) {
          // Read new content
          const stream = fs.createReadStream(logPath, {
            start: lastSize,
            encoding: 'utf8'
          });

          let buffer = '';
          stream.on('data', (chunk) => {
            buffer += chunk;
            const lines = buffer.split('\\n');
            buffer = lines.pop();

            lines.forEach(line => {
              if (line.trim() && !line.startsWith('#') && !line.startsWith('---')) {
                try {
                  const event = JSON.parse(line);
                  // Broadcast to all connected clients
                  wss.clients.forEach(client => {
                    if (client.readyState === WebSocket.OPEN) {
                      client.send(JSON.stringify({ type: 'event', event }));
                    }
                  });
                } catch (err) {
                  // Skip invalid JSON lines
                }
              }
            });
          });

          stream.on('end', () => {
            lastSize = currentSize;
          });
        }
      }
    });
  }

  httpServer.listen(httpPort, () => {
    console.log(\`Dashboard: http://localhost:\${httpPort}\`);
    console.log(\`WebSocket: ws://localhost:\${wsPort}\`);
  });

  return { httpPort, wsPort };
}

/**
 * Stop the dashboard server
 */
function stopDashboard() {
  if (fileWatcher) {
    fileWatcher.close();
    fileWatcher = null;
  }
  if (wss) {
    wss.close();
    wss = null;
  }
  if (httpServer) {
    httpServer.close();
    httpServer = null;
  }
  console.log('Dashboard stopped');
}

module.exports = {
  startDashboard,
  stopDashboard,
  DASHBOARD_HTML
};
```
  </action>
  <verify>
```bash
node -e "const ds = require('./get-shit-done/bin/dashboard-server.js'); console.log(typeof ds.startDashboard, typeof ds.stopDashboard)"
```
Output: `function function`
  </verify>
  <done>Dashboard server streams EXECUTION_LOG.md events via WebSocket with HTML UI</done>
</task>

<task type="auto">
  <name>Task 2: Create savings-report.js for token cost analysis</name>
  <files>get-shit-done/bin/savings-report.js</files>
  <action>
Create token savings calculation and reporting module:

```javascript
/**
 * Token Savings Report
 *
 * Calculates cost savings from auto mode vs fixed profiles.
 * Compares actual usage against hypothetical all-Opus baseline.
 * Source: Phase 8 Research - OBSV-05
 */

const fs = require('fs');
const path = require('path');
const { CLAUDE_PRICING } = require('./llm-metrics.js');

/**
 * Calculate savings comparing auto mode to all-Opus baseline
 * @param {object} usageData - Token usage data by model tier
 * @returns {object} - Savings breakdown
 */
function calculateSavings(usageData) {
  // usageData format: { haiku: { input, output }, sonnet: { input, output }, opus: { input, output } }

  let actualCost = 0;
  let totalInputTokens = 0;
  let totalOutputTokens = 0;

  const breakdown = {};

  for (const [model, usage] of Object.entries(usageData)) {
    const pricing = CLAUDE_PRICING[model] || CLAUDE_PRICING['opus'];
    const inputCost = (usage.input || 0) / 1000000 * pricing.input;
    const outputCost = (usage.output || 0) / 1000000 * pricing.output;
    const modelCost = inputCost + outputCost;

    actualCost += modelCost;
    totalInputTokens += usage.input || 0;
    totalOutputTokens += usage.output || 0;

    breakdown[model] = {
      input_tokens: usage.input || 0,
      output_tokens: usage.output || 0,
      input_cost: inputCost,
      output_cost: outputCost,
      total_cost: modelCost
    };
  }

  // Calculate hypothetical all-Opus cost
  const opusPricing = CLAUDE_PRICING['opus'];
  const opusInputCost = totalInputTokens / 1000000 * opusPricing.input;
  const opusOutputCost = totalOutputTokens / 1000000 * opusPricing.output;
  const opusBaseline = opusInputCost + opusOutputCost;

  const savings = opusBaseline - actualCost;
  const savingsPercent = opusBaseline > 0 ? (savings / opusBaseline * 100) : 0;

  return {
    total_tokens: {
      input: totalInputTokens,
      output: totalOutputTokens,
      total: totalInputTokens + totalOutputTokens
    },
    actual_cost: actualCost,
    opus_baseline: opusBaseline,
    savings_usd: savings,
    savings_percent: savingsPercent,
    model_breakdown: breakdown
  };
}

/**
 * Generate formatted savings report from token_budget.json
 * @param {string} budgetPath - Path to token_budget.json
 * @returns {object} - Full report
 */
function generateReport(budgetPath = '.planning/token_budget.json') {
  if (!fs.existsSync(budgetPath)) {
    return { error: 'No budget data available' };
  }

  const data = JSON.parse(fs.readFileSync(budgetPath, 'utf8'));

  // Aggregate usage by model from phase breakdown
  const usageByModel = {
    haiku: { input: 0, output: 0 },
    sonnet: { input: 0, output: 0 },
    opus: { input: 0, output: 0 }
  };

  // Parse phase usage if available
  const phaseUsage = data.phaseUsage || {};
  for (const [phase, usage] of Object.entries(phaseUsage)) {
    // Default to opus if model not specified
    const model = data.model || 'opus';
    if (!usageByModel[model]) usageByModel[model] = { input: 0, output: 0 };

    // Assume 70/30 input/output split if only total available
    if (typeof usage === 'number') {
      usageByModel[model].input += Math.floor(usage * 0.7);
      usageByModel[model].output += Math.floor(usage * 0.3);
    } else if (usage.input !== undefined) {
      usageByModel[model].input += usage.input;
      usageByModel[model].output += usage.output || 0;
    }
  }

  // If we have model-specific tracking, use that
  if (data.modelUsage) {
    for (const [model, usage] of Object.entries(data.modelUsage)) {
      if (!usageByModel[model]) usageByModel[model] = { input: 0, output: 0 };
      usageByModel[model].input += usage.input || 0;
      usageByModel[model].output += usage.output || 0;
    }
  }

  const savings = calculateSavings(usageByModel);

  return {
    report_generated: new Date().toISOString(),
    session: {
      model: data.model,
      max_tokens: data.maxTokens,
      current_usage: data.currentUsage
    },
    ...savings,
    recommendations: generateRecommendations(savings)
  };
}

/**
 * Generate optimization recommendations based on usage patterns
 */
function generateRecommendations(savings) {
  const recommendations = [];

  const breakdown = savings.model_breakdown || {};

  // Check if Opus usage is high
  if (breakdown.opus && breakdown.opus.total_cost > savings.actual_cost * 0.8) {
    recommendations.push('High Opus usage detected. Consider tuning auto mode routing rules for simpler tasks.');
  }

  // Check if Haiku usage is low
  if (!breakdown.haiku || breakdown.haiku.total_cost < savings.actual_cost * 0.1) {
    recommendations.push('Low Haiku utilization. Simple tasks may be over-routed to stronger models.');
  }

  // Good savings
  if (savings.savings_percent > 40) {
    recommendations.push(\`Excellent savings (\${savings.savings_percent.toFixed(1)}%). Auto mode routing is effective.\`);
  } else if (savings.savings_percent > 20) {
    recommendations.push(\`Good savings (\${savings.savings_percent.toFixed(1)}%). Consider adjusting routing thresholds for more aggressive optimization.\`);
  } else if (savings.savings_percent > 0) {
    recommendations.push(\`Moderate savings (\${savings.savings_percent.toFixed(1)}%). Review routing patterns for optimization opportunities.\`);
  }

  return recommendations;
}

/**
 * Format report as table for CLI display
 */
function formatReportTable(report) {
  if (report.error) return report.error;

  const lines = [
    '='.repeat(60),
    'TOKEN SAVINGS REPORT',
    '='.repeat(60),
    '',
    'SUMMARY',
    '-'.repeat(40),
    \`Total Tokens:      \${report.total_tokens.total.toLocaleString()}\`,
    \`  Input:           \${report.total_tokens.input.toLocaleString()}\`,
    \`  Output:          \${report.total_tokens.output.toLocaleString()}\`,
    '',
    \`Actual Cost:       $\${report.actual_cost.toFixed(4)}\`,
    \`Opus Baseline:     $\${report.opus_baseline.toFixed(4)}\`,
    \`Savings:           $\${report.savings_usd.toFixed(4)} (\${report.savings_percent.toFixed(1)}%)\`,
    '',
    'MODEL BREAKDOWN',
    '-'.repeat(40),
  ];

  for (const [model, data] of Object.entries(report.model_breakdown)) {
    if (data.total_cost > 0) {
      lines.push(\`\${model.toUpperCase().padEnd(10)} \${data.input_tokens.toLocaleString().padStart(12)} in / \${data.output_tokens.toLocaleString().padStart(12)} out  $\${data.total_cost.toFixed(4)}\`);
    }
  }

  if (report.recommendations && report.recommendations.length > 0) {
    lines.push('');
    lines.push('RECOMMENDATIONS');
    lines.push('-'.repeat(40));
    report.recommendations.forEach(r => lines.push(\`* \${r}\`));
  }

  lines.push('');
  lines.push(\`Report generated: \${report.report_generated}\`);

  return lines.join('\\n');
}

module.exports = {
  calculateSavings,
  generateReport,
  formatReportTable,
  generateRecommendations
};
```
  </action>
  <verify>
```bash
node -e "const sr = require('./get-shit-done/bin/savings-report.js'); const s = sr.calculateSavings({haiku: {input: 50000, output: 10000}, opus: {input: 100000, output: 50000}}); console.log(s.savings_percent > 0)"
```
Output: `true`
  </verify>
  <done>Savings calculation compares auto mode to opus baseline, generates recommendations</done>
</task>

<task type="auto">
  <name>Task 3: Add dashboard and savings CLI commands to gsd-tools.js</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add dashboard and savings command handlers to gsd-tools.js:

1. Create cmdDashboard handler:
   ```javascript
   async function cmdDashboard(args) {
     const subcommand = args[0];
     const { startDashboard, stopDashboard } = require('./dashboard-server.js');

     switch (subcommand) {
       case 'start':
         const httpPort = parseInt(args[args.indexOf('--http') + 1]) || 3000;
         const wsPort = parseInt(args[args.indexOf('--ws') + 1]) || 8080;
         startDashboard({ httpPort, wsPort });
         console.log('Dashboard server running. Press Ctrl+C to stop.');
         // Keep process alive
         await new Promise(() => {}); // Never resolves
         break;

       case 'stop':
         stopDashboard();
         break;

       default:
         console.log('Usage: dashboard start [--http PORT] [--ws PORT] | stop');
     }
   }
   ```

2. Create cmdSavings handler:
   ```javascript
   function cmdSavings(args) {
     const subcommand = args[0] || 'report';
     const { generateReport, formatReportTable, calculateSavings } = require('./savings-report.js');

     switch (subcommand) {
       case 'report':
         const report = generateReport();
         if (args.includes('--json')) {
           console.log(JSON.stringify(report, null, 2));
         } else {
           console.log(formatReportTable(report));
         }
         break;

       case 'calculate':
         // Manual calculation: savings calculate --haiku 50000 --sonnet 100000 --opus 20000
         const haiku = parseInt(args[args.indexOf('--haiku') + 1]) || 0;
         const sonnet = parseInt(args[args.indexOf('--sonnet') + 1]) || 0;
         const opus = parseInt(args[args.indexOf('--opus') + 1]) || 0;

         const result = calculateSavings({
           haiku: { input: Math.floor(haiku * 0.7), output: Math.floor(haiku * 0.3) },
           sonnet: { input: Math.floor(sonnet * 0.7), output: Math.floor(sonnet * 0.3) },
           opus: { input: Math.floor(opus * 0.7), output: Math.floor(opus * 0.3) }
         });

         console.log(JSON.stringify(result, null, 2));
         break;

       default:
         console.log('Usage: savings report [--json] | calculate --haiku N --sonnet N --opus N');
     }
   }
   ```

3. Add to command router:
   ```javascript
   case 'dashboard':
     await cmdDashboard(args.slice(1));
     break;
   case 'savings':
     cmdSavings(args.slice(1));
     break;
   ```

4. Add to help text:
   ```
   dashboard start|stop             Real-time execution progress dashboard
   savings report|calculate         Token savings analysis vs all-Opus baseline
   ```
  </action>
  <verify>
```bash
node get-shit-done/bin/gsd-tools.js savings calculate --haiku 100000 --sonnet 50000 --opus 10000 | grep -c "savings_percent"
```
Output: `1`
  </verify>
  <done>Dashboard and savings CLI commands work, report shows savings vs Opus baseline</done>
</task>

</tasks>

<verification>
Phase verification criteria:
1. `node get-shit-done/bin/gsd-tools.js dashboard start` launches HTTP and WebSocket servers
2. Visiting http://localhost:3000 shows dashboard HTML
3. `node get-shit-done/bin/gsd-tools.js savings report` shows formatted savings table
4. `node get-shit-done/bin/gsd-tools.js savings calculate --haiku 100000` calculates savings correctly
</verification>

<success_criteria>
- dashboard-server.js provides WebSocket streaming of execution log
- Dashboard HTML displays live events and statistics
- savings-report.js calculates cost savings vs all-Opus baseline
- CLI commands provide access to dashboard and savings features
- Report includes recommendations based on usage patterns
</success_criteria>

<output>
After completion, create `.planning/phases/08-notifications-and-observability/08-05-SUMMARY.md`
</output>
