---
phase: 08-notifications-and-observability
plan: 04
type: execute
wave: 2
depends_on: ["08-01", "08-03"]
files_modified:
  - get-shit-done/bin/graduated-alerts.js
  - get-shit-done/bin/token-monitor.js
  - get-shit-done/bin/gsd-tools.js
autonomous: true

must_haves:
  truths:
    - "Budget alerts fire at 50%, 80%, 90%, 100% thresholds"
    - "Each threshold triggers only once per session"
    - "90% threshold sends Telegram notification to user"
    - "100% threshold halts execution and saves checkpoint"
  artifacts:
    - path: "get-shit-done/bin/graduated-alerts.js"
      provides: "GraduatedBudgetMonitor extending TokenBudgetMonitor"
      exports: ["GraduatedBudgetMonitor", "GRADUATED_THRESHOLDS"]
    - path: "get-shit-done/bin/token-monitor.js"
      provides: "Base TokenBudgetMonitor (unchanged)"
      exports: ["TokenBudgetMonitor"]
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "alerts commands"
      contains: "alerts"
  key_links:
    - from: "graduated-alerts.js"
      to: "token-monitor.js"
      via: "extends TokenBudgetMonitor class"
      pattern: "extends TokenBudgetMonitor"
    - from: "graduated-alerts.js"
      to: "telegram-bot.js"
      via: "sends Telegram notification at 90%"
      pattern: "require.*telegram"
---

<objective>
Implement graduated budget alerts (50%, 80%, 90%, 100%) with Telegram notification at escalation threshold

Purpose: Provide progressive warnings during autonomous execution to prevent context exhaustion. Early warnings (50%) allow planning, mid-stage (80%) triggers compression, escalation (90%) notifies user via Telegram, and halt (100%) prevents mid-operation failures.

Output: GraduatedBudgetMonitor class that extends existing TokenBudgetMonitor with graduated thresholds and Telegram integration.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-notifications-and-observability/08-RESEARCH.md
@.planning/phases/07-autonomous-execution-optimization/07-01-SUMMARY.md
@.planning/phases/08-notifications-and-observability/08-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create graduated-alerts.js module</name>
  <files>get-shit-done/bin/graduated-alerts.js</files>
  <action>
Create graduated budget monitor extending existing TokenBudgetMonitor:

```javascript
/**
 * Graduated Budget Alerts
 *
 * Extends TokenBudgetMonitor with 50/80/90/100% thresholds.
 * Pattern: Progressive alerts with escalating actions
 * Source: Phase 8 Research - Pattern 4
 */

const { TokenBudgetMonitor } = require('./token-monitor.js');

const GRADUATED_THRESHOLDS = {
  early_warning: 0.50,      // 100k tokens - log warning
  compression_trigger: 0.80, // 160k tokens - trigger context compression
  escalation: 0.90,          // 180k tokens - notify user via Telegram
  halt: 1.00                 // 200k tokens - stop execution
};

class GraduatedBudgetMonitor extends TokenBudgetMonitor {
  constructor(model = 'opus', maxTokens = 200000, options = {}) {
    super(model, maxTokens);
    this.telegramEnabled = options.telegramEnabled || false;
    this.thresholdsPassed = new Set();
    this.graduatedAlerts = [];
  }

  /**
   * Override recordUsage to check graduated thresholds
   */
  recordUsage(actualTokens, phase) {
    super.recordUsage(actualTokens, phase);
    this.checkGraduatedThresholds(phase);
  }

  /**
   * Check all graduated thresholds after usage recording
   */
  checkGraduatedThresholds(phase) {
    const utilization = this.currentUsage / this.maxTokens;

    // Check each threshold in order (only trigger once)
    if (utilization >= GRADUATED_THRESHOLDS.early_warning &&
        !this.thresholdsPassed.has('early_warning')) {
      this.thresholdsPassed.add('early_warning');
      this.handleEarlyWarning(utilization, phase);
    }

    if (utilization >= GRADUATED_THRESHOLDS.compression_trigger &&
        !this.thresholdsPassed.has('compression_trigger')) {
      this.thresholdsPassed.add('compression_trigger');
      this.handleCompressionTrigger(utilization, phase);
    }

    if (utilization >= GRADUATED_THRESHOLDS.escalation &&
        !this.thresholdsPassed.has('escalation')) {
      this.thresholdsPassed.add('escalation');
      this.handleEscalation(utilization, phase);
    }

    if (utilization >= GRADUATED_THRESHOLDS.halt &&
        !this.thresholdsPassed.has('halt')) {
      this.thresholdsPassed.add('halt');
      this.handleHalt(utilization, phase);
    }
  }

  handleEarlyWarning(utilization, phase) {
    const alert = {
      level: 'INFO',
      threshold: '50%',
      action: 'Log warning',
      utilization: `${(utilization * 100).toFixed(1)}%`,
      tokens_used: this.currentUsage,
      tokens_remaining: this.maxTokens - this.currentUsage,
      phase,
      timestamp: new Date().toISOString()
    };

    this.graduatedAlerts.push(alert);
    console.log(`[BUDGET] 50% threshold reached (${this.currentUsage}/${this.maxTokens} tokens)`);
  }

  handleCompressionTrigger(utilization, phase) {
    const alert = {
      level: 'WARN',
      threshold: '80%',
      action: 'Trigger context compression for next phase',
      utilization: `${(utilization * 100).toFixed(1)}%`,
      tokens_used: this.currentUsage,
      tokens_remaining: this.maxTokens - this.currentUsage,
      phase,
      timestamp: new Date().toISOString()
    };

    this.graduatedAlerts.push(alert);
    console.warn(`[BUDGET] 80% threshold - context compression recommended`);
  }

  async handleEscalation(utilization, phase) {
    const alert = {
      level: 'CRITICAL',
      threshold: '90%',
      action: 'Notify user via Telegram',
      utilization: `${(utilization * 100).toFixed(1)}%`,
      tokens_used: this.currentUsage,
      tokens_remaining: this.maxTokens - this.currentUsage,
      phase,
      timestamp: new Date().toISOString()
    };

    this.graduatedAlerts.push(alert);
    console.error(`[BUDGET] 90% threshold reached - escalating to user`);

    // Send Telegram notification if enabled
    if (this.telegramEnabled) {
      try {
        const { sendBlockingQuestion } = require('./telegram-bot.js');
        await sendBlockingQuestion(
          `Token Budget Alert (90%)\n\n` +
          `Usage: ${this.currentUsage} / ${this.maxTokens} tokens\n` +
          `Phase: ${phase}\n\n` +
          `Options:\n` +
          `1. Continue (may fail if next phase is large)\n` +
          `2. Pause and checkpoint\n` +
          `3. Restart with fresh context`,
          { choices: ['Continue', 'Pause', 'Restart'] }
        );
      } catch (error) {
        console.error('Failed to send Telegram alert:', error.message);
      }
    }
  }

  handleHalt(utilization, phase) {
    const alert = {
      level: 'STOP',
      threshold: '100%',
      action: 'Halt execution, checkpoint state',
      utilization: `${(utilization * 100).toFixed(1)}%`,
      tokens_used: this.currentUsage,
      tokens_remaining: 0,
      phase,
      timestamp: new Date().toISOString()
    };

    this.graduatedAlerts.push(alert);
    console.error(`[BUDGET] 100% limit reached - halting execution`);

    throw new Error(
      `Token budget exhausted (${this.currentUsage}/${this.maxTokens}). ` +
      `Checkpoint saved. Resume with fresh context.`
    );
  }

  /**
   * Get graduated alerts report
   */
  getGraduatedReport() {
    return {
      ...super.getReport(),
      graduated_thresholds: GRADUATED_THRESHOLDS,
      thresholds_passed: Array.from(this.thresholdsPassed),
      graduated_alerts: this.graduatedAlerts
    };
  }

  /**
   * Reset including graduated state
   */
  reset() {
    super.reset();
    this.thresholdsPassed.clear();
    this.graduatedAlerts = [];
  }

  /**
   * Serialize to JSON including graduated state
   */
  toJSON() {
    return {
      ...super.toJSON(),
      thresholdsPassed: Array.from(this.thresholdsPassed),
      graduatedAlerts: this.graduatedAlerts,
      telegramEnabled: this.telegramEnabled
    };
  }

  /**
   * Restore from JSON including graduated state
   */
  static fromJSON(data) {
    const monitor = new GraduatedBudgetMonitor(data.model, data.maxTokens, {
      telegramEnabled: data.telegramEnabled
    });
    monitor.currentUsage = data.currentUsage || 0;
    monitor.phaseUsage = new Map(Object.entries(data.phaseUsage || {}));
    monitor.alerts = data.alerts || [];
    monitor.thresholdsPassed = new Set(data.thresholdsPassed || []);
    monitor.graduatedAlerts = data.graduatedAlerts || [];
    return monitor;
  }
}

module.exports = {
  GraduatedBudgetMonitor,
  GRADUATED_THRESHOLDS
};
```
  </action>
  <verify>
```bash
node -e "const ga = require('./get-shit-done/bin/graduated-alerts.js'); const m = new ga.GraduatedBudgetMonitor(); m.recordUsage(120000, 'test'); console.log(m.thresholdsPassed.has('early_warning'))"
```
Output: `true`
  </verify>
  <done>GraduatedBudgetMonitor triggers alerts at 50/80/90/100% thresholds, each only once</done>
</task>

<task type="auto">
  <name>Task 2: Add alerts CLI commands to gsd-tools.js</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add alerts command handler to gsd-tools.js:

1. Create cmdAlerts handler with subcommands:
   - `alerts status` - show current threshold status and alerts fired
   - `alerts test <utilization>` - simulate threshold checks for given utilization %
   - `alerts reset` - clear threshold state for new session
   - `alerts history` - show all graduated alerts in table/JSON format

2. Add to command router:
   ```javascript
   case 'alerts':
     await cmdAlerts(args.slice(1));
     break;
   ```

3. Add to help text:
   ```
   alerts status|test|reset|history  Graduated budget alert operations
   ```

4. Implementation:
   ```javascript
   async function cmdAlerts(args) {
     const subcommand = args[0];
     const { GraduatedBudgetMonitor, GRADUATED_THRESHOLDS } = require('./graduated-alerts.js');
     const fs = require('fs');
     const budgetPath = '.planning/token_budget.json';

     switch (subcommand) {
       case 'status':
         // Load existing budget state if available
         let monitor;
         if (fs.existsSync(budgetPath)) {
           const data = JSON.parse(fs.readFileSync(budgetPath, 'utf8'));
           monitor = GraduatedBudgetMonitor.fromJSON(data);
         } else {
           monitor = new GraduatedBudgetMonitor();
         }

         const utilization = monitor.currentUsage / monitor.maxTokens;
         console.log(JSON.stringify({
           current_usage: monitor.currentUsage,
           max_tokens: monitor.maxTokens,
           utilization_percent: (utilization * 100).toFixed(1),
           thresholds: GRADUATED_THRESHOLDS,
           thresholds_passed: Array.from(monitor.thresholdsPassed),
           alerts_fired: monitor.graduatedAlerts.length
         }, null, 2));
         break;

       case 'test':
         const utilizationPercent = parseFloat(args[1]) || 0;
         const testMonitor = new GraduatedBudgetMonitor('opus', 200000);
         const testTokens = Math.floor(200000 * (utilizationPercent / 100));

         console.log(`Testing ${utilizationPercent}% utilization (${testTokens} tokens)...`);
         try {
           testMonitor.recordUsage(testTokens, 'test-phase');
         } catch (error) {
           console.log(`Halt triggered: ${error.message}`);
         }

         console.log(JSON.stringify({
           utilization_tested: `${utilizationPercent}%`,
           thresholds_triggered: Array.from(testMonitor.thresholdsPassed),
           alerts: testMonitor.graduatedAlerts
         }, null, 2));
         break;

       case 'reset':
         if (fs.existsSync(budgetPath)) {
           const data = JSON.parse(fs.readFileSync(budgetPath, 'utf8'));
           data.thresholdsPassed = [];
           data.graduatedAlerts = [];
           fs.writeFileSync(budgetPath, JSON.stringify(data, null, 2));
           console.log('Graduated alert state reset');
         } else {
           console.log('No budget file to reset');
         }
         break;

       case 'history':
         if (fs.existsSync(budgetPath)) {
           const data = JSON.parse(fs.readFileSync(budgetPath, 'utf8'));
           const alerts = data.graduatedAlerts || [];

           if (args.includes('--json')) {
             console.log(JSON.stringify(alerts, null, 2));
           } else {
             if (alerts.length === 0) {
               console.log('No graduated alerts recorded');
             } else {
               console.log('Level      | Threshold | Utilization | Phase        | Timestamp');
               console.log('-'.repeat(75));
               alerts.forEach(a => {
                 console.log(`${a.level.padEnd(10)} | ${a.threshold.padEnd(9)} | ${a.utilization.padEnd(11)} | ${(a.phase || '').padEnd(12)} | ${a.timestamp}`);
               });
             }
           }
         } else {
           console.log('No budget history available');
         }
         break;

       default:
         console.log('Usage: alerts status|test|reset|history');
     }
   }
   ```
  </action>
  <verify>
```bash
node get-shit-done/bin/gsd-tools.js alerts test 85
```
Output contains: `"thresholds_triggered"` and `["early_warning","compression_trigger"]`
  </verify>
  <done>Alerts CLI commands work, test shows correct threshold triggering</done>
</task>

<task type="auto">
  <name>Task 3: Update token commands to use GraduatedBudgetMonitor</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Update existing token commands to optionally use GraduatedBudgetMonitor:

1. In `token init` command, add `--graduated` flag:
   ```javascript
   case 'init':
     const model = args[1] || 'opus';
     const graduated = args.includes('--graduated');
     const telegramEnabled = args.includes('--telegram');

     let monitor;
     if (graduated) {
       const { GraduatedBudgetMonitor } = require('./graduated-alerts.js');
       monitor = new GraduatedBudgetMonitor(model, 200000, { telegramEnabled });
     } else {
       const { TokenBudgetMonitor } = require('./token-monitor.js');
       monitor = new TokenBudgetMonitor(model, 200000);
     }

     fs.writeFileSync(budgetPath, JSON.stringify(monitor.toJSON(), null, 2));
     console.log(`Token budget initialized (graduated=${graduated}, telegram=${telegramEnabled})`);
     break;
   ```

2. In `token record` command, use correct monitor class:
   ```javascript
   case 'record':
     const data = JSON.parse(fs.readFileSync(budgetPath, 'utf8'));

     // Detect if graduated state exists
     let monitor;
     if (data.thresholdsPassed !== undefined) {
       const { GraduatedBudgetMonitor } = require('./graduated-alerts.js');
       monitor = GraduatedBudgetMonitor.fromJSON(data);
     } else {
       const { TokenBudgetMonitor } = require('./token-monitor.js');
       monitor = TokenBudgetMonitor.fromJSON(data);
     }

     const tokens = parseInt(args[1]) || 0;
     const phase = args[2] || 'unknown';
     monitor.recordUsage(tokens, phase);
     fs.writeFileSync(budgetPath, JSON.stringify(monitor.toJSON(), null, 2));
     console.log(`Recorded ${tokens} tokens for ${phase}`);
     break;
   ```

3. In `token report` command, show graduated info if available:
   ```javascript
   case 'report':
     const data = JSON.parse(fs.readFileSync(budgetPath, 'utf8'));

     if (data.thresholdsPassed !== undefined) {
       const { GraduatedBudgetMonitor } = require('./graduated-alerts.js');
       const monitor = GraduatedBudgetMonitor.fromJSON(data);
       console.log(JSON.stringify(monitor.getGraduatedReport(), null, 2));
     } else {
       const { TokenBudgetMonitor } = require('./token-monitor.js');
       const monitor = TokenBudgetMonitor.fromJSON(data);
       console.log(JSON.stringify(monitor.getReport(), null, 2));
     }
     break;
   ```

4. Update help text:
   ```
   token init [model] [--graduated] [--telegram]  Initialize token budget
   ```
  </action>
  <verify>
```bash
node get-shit-done/bin/gsd-tools.js token init opus --graduated && node get-shit-done/bin/gsd-tools.js token record 120000 test-phase && node get-shit-done/bin/gsd-tools.js token report | grep -c "thresholds_passed"
```
Output: `1`
  </verify>
  <done>Token commands work with graduated alerts, threshold state persisted correctly</done>
</task>

</tasks>

<verification>
Phase verification criteria:
1. `node get-shit-done/bin/gsd-tools.js alerts test 55` triggers only early_warning
2. `node get-shit-done/bin/gsd-tools.js alerts test 95` triggers early_warning, compression_trigger, and escalation
3. `node get-shit-done/bin/gsd-tools.js alerts test 105` triggers all thresholds including halt
4. Threshold state persists across commands via token_budget.json
</verification>

<success_criteria>
- graduated-alerts.js extends TokenBudgetMonitor with 4 thresholds
- Each threshold triggers only once per session
- 90% threshold attempts Telegram notification (if enabled)
- 100% threshold throws error to halt execution
- token init --graduated enables graduated monitoring
- alerts CLI commands provide visibility into threshold state
</success_criteria>

<output>
After completion, create `.planning/phases/08-notifications-and-observability/08-04-SUMMARY.md`
</output>
