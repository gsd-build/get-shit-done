---
phase: 08-notifications-and-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/telegram-bot.js
  - get-shit-done/bin/telegram-conversation.js
  - get-shit-done/bin/gsd-tools.js
autonomous: true
user_setup:
  - service: telegram
    why: "Bot token for sending/receiving messages"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Telegram @BotFather -> /newbot -> copy token"
      - name: TELEGRAM_OWNER_ID
        source: "Send /start to @userinfobot to get your chat ID"
    dashboard_config:
      - task: "Create Telegram bot via @BotFather"
        location: "Telegram app -> search @BotFather -> /newbot"

must_haves:
  truths:
    - "Claude can send blocking questions to user via Telegram"
    - "User can respond to questions via text message"
    - "Claude receives user's response and can resume execution"
    - "Bot gracefully handles missing credentials"
  artifacts:
    - path: "get-shit-done/bin/telegram-bot.js"
      provides: "Telegraf bot server with message handlers"
      min_lines: 100
    - path: "get-shit-done/bin/telegram-conversation.js"
      provides: "Conversation state FSM for blocking questions"
      exports: ["askUser", "handleResponse", "getPendingQuestions"]
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "telegram commands"
      contains: "telegram"
  key_links:
    - from: "get-shit-done/bin/telegram-conversation.js"
      to: "telegram-bot.js"
      via: "message handlers import conversation module"
      pattern: "require.*telegram-conversation"
    - from: "telegram-bot.js"
      to: "TELEGRAM_BOT_TOKEN env var"
      via: "Telegraf initialization"
      pattern: "new Telegraf.*process\\.env"
---

<objective>
Create Telegram bot infrastructure for human-in-the-loop intervention during autonomous execution

Purpose: Enable Claude to send blocking questions to users via Telegram when human input is required (ambiguous requirements, security decisions, architecture tradeoffs), and resume execution after receiving the response.

Output: Working Telegram bot that can send questions, await responses, and unblock execution.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-notifications-and-observability/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create telegram-conversation.js module</name>
  <files>get-shit-done/bin/telegram-conversation.js</files>
  <action>
Create conversation state management module with:

1. In-memory question storage (Map for single user):
   - `pendingQuestions = new Map()` keyed by questionId
   - Each entry: `{ resolve, reject, question, askedAt, context }`

2. Core functions:
   - `generateQuestionId()` - return `q_${Date.now()}_${Math.random().toString(36).slice(2,8)}`
   - `askUser(question, options)` - create Promise, store in pendingQuestions, return questionId
     - options.choices: array of inline keyboard buttons
     - options.timeout: custom timeout (default 3600000ms = 1 hour)
   - `handleResponse(questionId, response)` - resolve matching promise, delete from map
   - `getPendingQuestions()` - return array of pending question objects
   - `cancelQuestion(questionId)` - reject with cancellation error, delete from map

3. Timeout handling:
   - Start timeout on question creation
   - Reject with TimeoutError after timeout period
   - Clean up from map on timeout

4. Export format: `module.exports = { askUser, handleResponse, getPendingQuestions, cancelQuestion, generateQuestionId }`

Use Pattern 1 from 08-RESEARCH.md as reference.
  </action>
  <verify>
```bash
node -e "const tc = require('./get-shit-done/bin/telegram-conversation.js'); console.log(typeof tc.askUser, typeof tc.handleResponse, typeof tc.getPendingQuestions)"
```
Output: `function function function`
  </verify>
  <done>Module exports all required functions, question timeout works correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create telegram-bot.js server</name>
  <files>get-shit-done/bin/telegram-bot.js</files>
  <action>
Create Telegraf bot server with:

1. Dependencies and initialization:
   - `const { Telegraf } = require('telegraf')` (install: npm install telegraf)
   - Load dotenv for env vars
   - Check TELEGRAM_BOT_TOKEN exists, exit gracefully with instruction if not
   - `const bot = new Telegraf(process.env.TELEGRAM_BOT_TOKEN)`

2. Command handlers:
   - `/start` - reply with welcome message, store chat ID
   - `/status` - show pending questions count
   - `/pending` - list all pending questions with IDs

3. Message handlers:
   - `bot.on('text')` - detect question ID in message (format: q_timestamp_random)
     - If questionId found in pendingQuestions, resolve with { type: 'text', content: message }
     - Reply with confirmation: "Got it! Resuming execution..."
     - If no pending question, reply with "No pending question. Send /pending to see active questions."

   - `bot.on('callback_query')` - handle inline keyboard button presses
     - Extract questionId from callback data or active question
     - Resolve with { type: 'button', content: buttonText }

4. Blocking question sender function:
   - `sendBlockingQuestion(question, options)` - import from telegram-conversation.js
     - Call `askUser(question, options)` to get questionId and promise
     - Format message with question text and questionId for reference
     - Build inline keyboard if options.choices provided
     - Send via `bot.telegram.sendMessage(TELEGRAM_OWNER_ID, ...)`
     - Await and return response

5. Bot lifecycle:
   - `startBot()` - call `bot.launch()` with polling mode (webhooks deferred to production)
   - `stopBot()` - call `bot.stop()`
   - Graceful shutdown on SIGINT/SIGTERM

6. Export: `module.exports = { sendBlockingQuestion, startBot, stopBot, bot }`

Include fallback for missing TELEGRAM_BOT_TOKEN:
```javascript
if (!process.env.TELEGRAM_BOT_TOKEN) {
  console.log('TELEGRAM_BOT_TOKEN not set. Telegram notifications disabled.');
  module.exports = {
    sendBlockingQuestion: async () => ({ type: 'disabled', content: 'Telegram not configured' }),
    startBot: () => {},
    stopBot: () => {}
  };
  return;
}
```
  </action>
  <verify>
```bash
# Verify module loads without error (no token = graceful fallback)
node -e "const tb = require('./get-shit-done/bin/telegram-bot.js'); console.log(typeof tb.sendBlockingQuestion)"
```
Output: `function`
  </verify>
  <done>Bot module loads correctly, handles missing token gracefully, exports required functions</done>
</task>

<task type="auto">
  <name>Task 3: Add telegram CLI commands to gsd-tools.js</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add telegram command handler to gsd-tools.js:

1. Add require at top (lazy-load pattern like other modules):
   ```javascript
   // In cmdTelegram handler, not at top level
   const telegram = require('./telegram-bot.js');
   const conversation = require('./telegram-conversation.js');
   ```

2. Create cmdTelegram handler with subcommands:
   - `telegram start` - start bot polling, show "Bot started, listening..."
   - `telegram stop` - stop bot gracefully
   - `telegram test <message>` - send test message to owner, await response, show result
   - `telegram ask <question>` - send blocking question, await response, print result
   - `telegram pending` - show pending questions in table/JSON format
   - `telegram status` - show bot status (connected/disconnected, pending count)

3. Add to command router:
   ```javascript
   case 'telegram':
     await cmdTelegram(args.slice(1));
     break;
   ```

4. Add to help text:
   ```
   telegram start|stop|test|ask|pending|status  Telegram bot operations
   ```

5. Example cmdTelegram implementation:
   ```javascript
   async function cmdTelegram(args) {
     const subcommand = args[0];

     switch (subcommand) {
       case 'start':
         const telegram = require('./telegram-bot.js');
         await telegram.startBot();
         console.log('Telegram bot started');
         break;
       case 'stop':
         const telegram = require('./telegram-bot.js');
         telegram.stopBot();
         console.log('Telegram bot stopped');
         break;
       case 'test':
         const message = args.slice(1).join(' ');
         const telegram = require('./telegram-bot.js');
         const response = await telegram.sendBlockingQuestion(`Test: ${message}`, {});
         console.log(JSON.stringify(response));
         break;
       // ... other subcommands
     }
   }
   ```
  </action>
  <verify>
```bash
node get-shit-done/bin/gsd-tools.js help | grep telegram
```
Output contains: `telegram start|stop|test|ask|pending|status`
  </verify>
  <done>All telegram subcommands work, help text updated</done>
</task>

<task type="auto">
  <name>Task 4: Verify Telegram bot module integration</name>
  <files>get-shit-done/bin/telegram-bot.js, get-shit-done/bin/telegram-conversation.js</files>
  <action>
Verify all bot components work correctly without requiring user Telegram credentials:

1. Test module loading and graceful fallback:
   ```bash
   # Without credentials - should load with fallback exports
   unset TELEGRAM_BOT_TOKEN
   node -e "const tb = require('./get-shit-done/bin/telegram-bot.js'); console.log('sendBlockingQuestion:', typeof tb.sendBlockingQuestion, '| startBot:', typeof tb.startBot)"
   ```
   Expected: `sendBlockingQuestion: function | startBot: function`

2. Test conversation module independently:
   ```bash
   node -e "
     const tc = require('./get-shit-done/bin/telegram-conversation.js');
     const qid = tc.generateQuestionId();
     console.log('Generated ID format valid:', /^q_\\d+_[a-z0-9]+$/.test(qid));
     console.log('Pending initially:', tc.getPendingQuestions().length);
   "
   ```
   Expected: `Generated ID format valid: true` and `Pending initially: 0`

3. Test gsd-tools telegram commands registered:
   ```bash
   node get-shit-done/bin/gsd-tools.js telegram status 2>&1 || echo "Command exists"
   ```
   Expected: Either status output or graceful error (not "Unknown command")

4. Test conversation round-trip (mock):
   ```bash
   node -e "
     const tc = require('./get-shit-done/bin/telegram-conversation.js');
     // Start async question
     const promise = tc.askUser('Test question', { timeout: 5000 });
     const pending = tc.getPendingQuestions();
     console.log('Pending after ask:', pending.length);
     // Simulate response
     tc.handleResponse(pending[0].questionId, { type: 'text', content: 'test response' });
     promise.then(r => console.log('Response received:', r.content));
   "
   ```
   Expected: `Pending after ask: 1` then `Response received: test response`

All tests pass without requiring actual Telegram credentials.
  </action>
  <verify>
```bash
# All module integrations work
node -e "const tb = require('./get-shit-done/bin/telegram-bot.js'); const tc = require('./get-shit-done/bin/telegram-conversation.js'); console.log('Bot:', typeof tb.sendBlockingQuestion === 'function', '| Conv:', typeof tc.askUser === 'function')"
```
Output: `Bot: true | Conv: true`
  </verify>
  <done>All modules load correctly, conversation round-trip works in mock mode, graceful fallback when credentials missing</done>
</task>

</tasks>

<verification>
Phase verification criteria:
1. `node get-shit-done/bin/gsd-tools.js telegram status` works without error
2. Missing TELEGRAM_BOT_TOKEN results in graceful fallback, not crash
3. Question/response round-trip works end-to-end
</verification>

<success_criteria>
- telegram-bot.js and telegram-conversation.js created with all required exports
- gsd-tools.js has telegram command with 6 subcommands
- Bot handles missing credentials gracefully
- Blocking question flow works: send question -> user responds -> execution resumes
</success_criteria>

<output>
After completion, create `.planning/phases/08-notifications-and-observability/08-01-SUMMARY.md`
</output>
