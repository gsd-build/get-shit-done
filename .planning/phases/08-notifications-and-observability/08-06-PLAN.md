---
phase: 08-notifications-and-observability
plan: 06
type: gap_closure
wave: 3
gap_closure: true
depends_on: ["08-01", "08-02"]
files_modified:
  - get-shit-done/bin/telegram-bot.js
  - get-shit-done/bin/telegram-haiku-monitor.js
  - get-shit-done/bin/telegram-requirement-gatherer.js
  - get-shit-done/bin/telegram-session-logger.js
  - get-shit-done/bin/gsd-tools.js
  - get-shit-done/bin/dashboard-server.js
autonomous: true

must_haves:
  truths:
    - "Bot starts via /gsd:telegram start with Haiku monitoring continuously"
    - "Menu buttons: Status, Pending Questions, New Requirements"
    - "Single pending question auto-matches user response without ID"
    - "New Requirements flow: Haiku asks questions, decides phase/todo/future"
    - "Haiku uses subagent for requirement gathering to preserve context"
    - "All bot activity logged to .planning/telegram-sessions/"
    - "Dashboard uses ports 8765/8766 instead of 3000/8080"
  artifacts:
    - path: "get-shit-done/bin/telegram-haiku-monitor.js"
      provides: "Main Haiku agent monitoring Telegram bot continuously"
      exports: ["startHaikuMonitor", "stopHaikuMonitor", "getMonitorStatus"]
    - path: "get-shit-done/bin/telegram-requirement-gatherer.js"
      provides: "Subagent for gathering requirements via conversation"
      exports: ["gatherRequirements", "askClarifyingQuestion", "decideDestination"]
    - path: "get-shit-done/bin/telegram-session-logger.js"
      provides: "Session logging for all bot activity"
      exports: ["logMessage", "logDecision", "getSessionPath"]
    - path: "get-shit-done/bin/telegram-bot.js"
      provides: "Updated bot with menu keyboard and auto-matching"
      contains: "Markup.inlineKeyboard"
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "telegram start|stop|status|logs commands"
      contains: "cmdTelegram.*start"
  key_links:
    - from: "telegram-haiku-monitor.js"
      to: "telegram-bot.js"
      via: "registers message handlers for menu interactions"
      pattern: "bot.on.*callback_query"
    - from: "telegram-requirement-gatherer.js"
      to: "Claude API"
      via: "spawns Haiku subagent via anthropic SDK"
      pattern: "anthropic.messages.create"
    - from: "telegram-session-logger.js"
      to: ".planning/telegram-sessions/"
      via: "appends JSONL logs"
      pattern: "fs.appendFileSync"
---

<objective>
Transform Telegram bot from simple relay to intelligent assistant with Haiku monitor, conversational requirement gathering, and seamless integration with GSD commands.

Purpose: Enable users to start GSD bot via `/gsd:telegram start`, interact via menu buttons, and have Haiku intelligently route requirements to appropriate GSD commands while logging everything for audit trail.

Output: Production-ready Telegram bot with AI-powered requirement gathering and automated decision-making.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-notifications-and-observability/08-01-SUMMARY.md
@.planning/phases/08-notifications-and-observability/08-02-SUMMARY.md
@.planning/phases/08-notifications-and-observability/08-VERIFICATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create telegram-session-logger.js module</name>
  <files>get-shit-done/bin/telegram-session-logger.js</files>
  <action>
Create session logging module for audit trail:

```javascript
/**
 * Telegram Session Logger
 *
 * Logs all bot activity (messages, questions, decisions) to JSONL files.
 * One file per bot session in .planning/telegram-sessions/
 */

const fs = require('fs');
const path = require('path');

let currentSessionPath = null;
let sessionStartTime = null;

/**
 * Start new session log
 */
function startSession() {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  const sessionsDir = path.join(process.cwd(), '.planning', 'telegram-sessions');

  if (!fs.existsSync(sessionsDir)) {
    fs.mkdirSync(sessionsDir, { recursive: true });
  }

  currentSessionPath = path.join(sessionsDir, `${timestamp}.jsonl`);
  sessionStartTime = Date.now();

  logEvent({
    type: 'session_start',
    timestamp: new Date().toISOString()
  });

  return currentSessionPath;
}

/**
 * Log any event to current session
 */
function logEvent(event) {
  if (!currentSessionPath) {
    startSession();
  }

  const entry = {
    ...event,
    session_time_ms: Date.now() - sessionStartTime,
    timestamp: event.timestamp || new Date().toISOString()
  };

  fs.appendFileSync(currentSessionPath, JSON.stringify(entry) + '\n');
}

/**
 * Log user message
 */
function logMessage(userId, username, messageType, content) {
  logEvent({
    type: 'user_message',
    user_id: userId,
    username,
    message_type: messageType, // 'text', 'voice', 'button'
    content: messageType === 'voice' ? `[voice:${content.duration}s]` : content
  });
}

/**
 * Log bot response
 */
function logBotResponse(content, messageType = 'text') {
  logEvent({
    type: 'bot_response',
    message_type: messageType,
    content
  });
}

/**
 * Log Haiku decision
 */
function logDecision(decisionType, reasoning, action) {
  logEvent({
    type: 'haiku_decision',
    decision_type: decisionType, // 'add_phase', 'insert_phase', 'add_todo', 'add_future'
    reasoning,
    action
  });
}

/**
 * Log blocking question
 */
function logBlockingQuestion(questionId, question, source) {
  logEvent({
    type: 'blocking_question',
    question_id: questionId,
    question,
    source // 'coordinator', 'executor', etc.
  });
}

/**
 * Log blocking question response
 */
function logBlockingResponse(questionId, response) {
  logEvent({
    type: 'blocking_response',
    question_id: questionId,
    response
  });
}

/**
 * End current session
 */
function endSession() {
  if (currentSessionPath) {
    logEvent({
      type: 'session_end',
      duration_ms: Date.now() - sessionStartTime
    });
  }

  const path = currentSessionPath;
  currentSessionPath = null;
  sessionStartTime = null;
  return path;
}

/**
 * Get current session path
 */
function getSessionPath() {
  return currentSessionPath;
}

/**
 * Get all session files
 */
function getAllSessions() {
  const sessionsDir = path.join(process.cwd(), '.planning', 'telegram-sessions');
  if (!fs.existsSync(sessionsDir)) return [];

  return fs.readdirSync(sessionsDir)
    .filter(f => f.endsWith('.jsonl'))
    .map(f => path.join(sessionsDir, f))
    .sort()
    .reverse(); // Most recent first
}

/**
 * Read session log
 */
function readSession(sessionPath) {
  const content = fs.readFileSync(sessionPath, 'utf8');
  return content.split('\n')
    .filter(line => line.trim())
    .map(line => JSON.parse(line));
}

module.exports = {
  startSession,
  endSession,
  logEvent,
  logMessage,
  logBotResponse,
  logDecision,
  logBlockingQuestion,
  logBlockingResponse,
  getSessionPath,
  getAllSessions,
  readSession
};
```
  </action>
  <verify>
```bash
node -e "const logger = require('./get-shit-done/bin/telegram-session-logger.js'); logger.startSession(); logger.logMessage(123, 'test', 'text', 'hello'); console.log('Logged to:', logger.getSessionPath())"
```
Output contains: `.planning/telegram-sessions/`
  </verify>
  <done>Session logger creates JSONL files, logs all event types</done>
</task>

<task type="auto">
  <name>Task 2: Create telegram-requirement-gatherer.js subagent module</name>
  <files>get-shit-done/bin/telegram-requirement-gatherer.js</files>
  <action>
Create requirement gathering subagent that uses Haiku to clarify requirements and decide destination:

```javascript
/**
 * Telegram Requirement Gatherer
 *
 * Haiku-powered subagent for gathering requirements via conversation.
 * Asks clarifying questions until requirements are clear, then decides:
 * - Add as new phase (/gsd:add-phase or /gsd:insert-phase)
 * - Add to .planning/todo/ideas.md (future ideas)
 * - Add to .planning/todo/next-milestone.md (next milestone features)
 */

const Anthropic = require('@anthropic-ai/sdk');
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { logDecision, logBotResponse } = require('./telegram-session-logger.js');

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

/**
 * Gather requirements from user via multi-turn conversation
 * @param {function} sendMessage - Function to send message to user
 * @param {function} waitForResponse - Function to wait for user response (returns promise)
 * @param {string} initialMessage - User's initial requirement message
 * @returns {object} - { destination, content, reasoning }
 */
async function gatherRequirements(sendMessage, waitForResponse, initialMessage) {
  const conversationHistory = [
    {
      role: 'user',
      content: initialMessage
    }
  ];

  // Load current project context
  const projectContext = loadProjectContext();

  const systemPrompt = `You are a requirement gathering assistant for GSD (Get Shit Done) autonomous development system.

Your job: Clarify user requirements through conversation, then decide where to route them.

Current Project Context:
${projectContext}

Conversation Protocol:
1. Ask clarifying questions ONE AT A TIME until requirements are clear
2. Focus on: What, Why, Priority, Dependencies, Scope
3. Keep questions short and specific
4. When requirements are clear, respond with DECISION format (see below)

DECISION Format (use when ready):
<decision>
<destination>add_phase|insert_phase|todo_ideas|todo_next_milestone</destination>
<position>end|after:3|before:5</position>
<title>Short phase/feature title</title>
<reasoning>Why this destination and position</reasoning>
<content>
Full requirement description
</content>
</decision>

Destination Rules:
- add_phase: New phase at END of current milestone (use when: fits current milestone scope, logical next step)
- insert_phase: New phase at SPECIFIC position (use when: urgent, must happen before existing phase)
- todo_ideas: Future ideas (use when: interesting but not for current milestone, needs more research)
- todo_next_milestone: Next milestone feature (use when: clear value but beyond current milestone scope)

Continue asking questions until you're confident about destination.`;

  let turn = 0;
  const maxTurns = 10;

  while (turn < maxTurns) {
    turn++;

    // Call Haiku
    const response = await anthropic.messages.create({
      model: 'claude-haiku-4',
      max_tokens: 1000,
      system: systemPrompt,
      messages: conversationHistory
    });

    const assistantMessage = response.content[0].text;

    // Check if decision made
    if (assistantMessage.includes('<decision>')) {
      const decision = parseDecision(assistantMessage);
      logDecision(decision.destination, decision.reasoning, decision.title);
      return decision;
    }

    // Send question to user
    await sendMessage(assistantMessage);
    logBotResponse(assistantMessage);

    // Wait for user response
    const userResponse = await waitForResponse();

    // Check if user wants to end
    if (/^(done|finish|end|stop|cancel)$/i.test(userResponse.trim())) {
      await sendMessage("Requirements gathering cancelled. No changes made.");
      return null;
    }

    // Add to conversation history
    conversationHistory.push({
      role: 'assistant',
      content: assistantMessage
    });
    conversationHistory.push({
      role: 'user',
      content: userResponse
    });
  }

  // Max turns reached
  await sendMessage("Reached conversation limit. Please try again with more specific requirements.");
  return null;
}

/**
 * Load project context for Haiku
 */
function loadProjectContext() {
  const parts = [];

  // Load current milestone info
  try {
    const roadmap = fs.readFileSync('.planning/ROADMAP.md', 'utf8');
    const milestoneMatch = roadmap.match(/## Overview\n\n([\s\S]*?)\n\n##/);
    if (milestoneMatch) {
      parts.push(`Milestone Overview:\n${milestoneMatch[1]}`);
    }

    // Extract current phases
    const phasesMatch = roadmap.match(/## Phases\n\n([\s\S]*?)\n\n## Phase Details/);
    if (phasesMatch) {
      parts.push(`Current Phases:\n${phasesMatch[1]}`);
    }
  } catch (err) {
    parts.push('ROADMAP.md not found');
  }

  // Load STATE.md position
  try {
    const state = fs.readFileSync('.planning/STATE.md', 'utf8');
    const positionMatch = state.match(/## Current Position\n\n([\s\S]*?)\n\n##/);
    if (positionMatch) {
      parts.push(`Current Position:\n${positionMatch[1]}`);
    }
  } catch (err) {
    parts.push('STATE.md not found');
  }

  return parts.join('\n\n');
}

/**
 * Parse decision from Haiku response
 */
function parseDecision(text) {
  const destinationMatch = text.match(/<destination>(.*?)<\/destination>/);
  const positionMatch = text.match(/<position>(.*?)<\/position>/);
  const titleMatch = text.match(/<title>(.*?)<\/title>/);
  const reasoningMatch = text.match(/<reasoning>([\s\S]*?)<\/reasoning>/);
  const contentMatch = text.match(/<content>([\s\S]*?)<\/content>/);

  return {
    destination: destinationMatch?.[1] || 'todo_ideas',
    position: positionMatch?.[1] || 'end',
    title: titleMatch?.[1] || 'New Feature',
    reasoning: reasoningMatch?.[1]?.trim() || 'No reasoning provided',
    content: contentMatch?.[1]?.trim() || 'No content provided'
  };
}

/**
 * Execute decision by calling appropriate GSD command
 */
async function executeDecision(decision, sendMessage) {
  const { destination, position, title, content } = decision;

  try {
    switch (destination) {
      case 'add_phase':
        // Call /gsd:add-phase
        execSync(`node get-shit-done/bin/gsd-tools.js add-phase "${title}" "${content}"`);
        await sendMessage(`‚úÖ Added as new phase: "${title}"\n\nRun /gsd:plan-phase <phase> to create execution plan.`);
        break;

      case 'insert_phase':
        // Parse position (e.g., "after:3" or "before:5")
        const posMatch = position.match(/(after|before):(\d+)/);
        if (posMatch) {
          const [, placement, phaseNum] = posMatch;
          // Call /gsd:insert-phase
          execSync(`node get-shit-done/bin/gsd-tools.js insert-phase ${phaseNum} "${title}" "${content}"`);
          await sendMessage(`‚úÖ Inserted as phase ${placement} ${phaseNum}: "${title}"\n\nRun /gsd:plan-phase <phase> to create execution plan.`);
        } else {
          throw new Error('Invalid position format');
        }
        break;

      case 'todo_ideas':
        // Append to .planning/todo/ideas.md
        appendToFile('.planning/todo/ideas.md', `## ${title}\n\n${content}\n\n*Added: ${new Date().toISOString().split('T')[0]}*\n\n---\n\n`);
        await sendMessage(`üí° Added to future ideas: "${title}"\n\nSee .planning/todo/ideas.md`);
        break;

      case 'todo_next_milestone':
        // Append to .planning/todo/next-milestone.md
        appendToFile('.planning/todo/next-milestone.md', `## ${title}\n\n${content}\n\n*Added: ${new Date().toISOString().split('T')[0]}*\n\n---\n\n`);
        await sendMessage(`üìã Added to next milestone: "${title}"\n\nSee .planning/todo/next-milestone.md`);
        break;

      default:
        await sendMessage(`‚ùå Unknown destination: ${destination}`);
    }
  } catch (error) {
    await sendMessage(`‚ùå Error executing decision: ${error.message}`);
    throw error;
  }
}

/**
 * Append content to file
 */
function appendToFile(filePath, content) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  if (!fs.existsSync(filePath)) {
    fs.writeFileSync(filePath, `# ${path.basename(filePath, '.md').replace(/-/g, ' ').toUpperCase()}\n\n`);
  }

  fs.appendFileSync(filePath, content);
}

module.exports = {
  gatherRequirements,
  executeDecision,
  loadProjectContext
};
```
  </action>
  <verify>
```bash
node -e "const rg = require('./get-shit-done/bin/telegram-requirement-gatherer.js'); console.log(typeof rg.gatherRequirements, typeof rg.executeDecision)"
```
Output: `function function`
  </verify>
  <done>Requirement gatherer uses Haiku for conversation, decides destination, executes GSD commands</done>
</task>

<task type="auto">
  <name>Task 3: Create telegram-haiku-monitor.js main agent</name>
  <files>get-shit-done/bin/telegram-haiku-monitor.js</files>
  <action>
Create main Haiku monitor that handles menu interactions and routes to appropriate handlers:

```javascript
/**
 * Telegram Haiku Monitor
 *
 * Main Haiku agent that monitors Telegram bot continuously.
 * Handles menu interactions, routes to subagents, provides status.
 */

const { Markup } = require('telegraf');
const { gatherRequirements, executeDecision } = require('./telegram-requirement-gatherer.js');
const { logMessage, logBotResponse } = require('./telegram-session-logger.js');
const { getPendingQuestions } = require('./telegram-conversation.js');

let monitorActive = false;
let currentConversationMode = null; // 'requirements', 'pending', null
let requirementGatheringActive = false;

/**
 * Main menu keyboard
 */
const MAIN_MENU = Markup.inlineKeyboard([
  [
    Markup.button.callback('üìä Status', 'menu:status'),
    Markup.button.callback('‚ùì Pending', 'menu:pending'),
    Markup.button.callback('‚ú® New Requirements', 'menu:requirements')
  ]
]);

/**
 * Start Haiku monitor
 */
function startHaikuMonitor(bot) {
  if (monitorActive) {
    console.log('Haiku monitor already running');
    return;
  }

  monitorActive = true;
  console.log('Haiku monitor started');

  // Register menu button handlers
  bot.action('menu:status', handleStatusMenu);
  bot.action('menu:pending', handlePendingMenu);
  bot.action('menu:requirements', handleRequirementsMenu);

  // Register back button
  bot.action('back:main', async (ctx) => {
    currentConversationMode = null;
    requirementGatheringActive = false;
    await ctx.editMessageText('Main Menu:', MAIN_MENU);
  });

  // Override text handler to route based on mode
  bot.on('text', async (ctx) => {
    const text = ctx.message.text;
    const userId = ctx.from.id;
    const username = ctx.from.username;

    logMessage(userId, username, 'text', text);

    // Route based on current mode
    if (currentConversationMode === 'requirements' && requirementGatheringActive) {
      // Handled by requirement gathering flow
      return;
    }

    // Check for pending questions (auto-match if only 1)
    const pending = getPendingQuestions();
    if (pending.length === 1) {
      // Auto-match to single pending question
      const conversation = require('./telegram-conversation.js');
      conversation.handleResponse(pending[0].questionId, {
        type: 'text',
        content: text
      });
      await ctx.reply(`‚úÖ Response recorded for: "${pending[0].question.slice(0, 50)}..."\n\nResuming execution...`);
      logBotResponse('Response auto-matched to pending question');
      return;
    } else if (pending.length > 1) {
      // Multiple pending - show menu
      await showPendingQuestionsMenu(ctx);
      return;
    }

    // No pending questions, no active conversation - show main menu
    await ctx.reply('What would you like to do?', MAIN_MENU);
  });

  // Override voice handler
  bot.on('voice', async (ctx) => {
    const userId = ctx.from.id;
    const username = ctx.from.username;
    const duration = ctx.message.voice.duration;

    logMessage(userId, username, 'voice', { duration });

    if (currentConversationMode === 'requirements' && requirementGatheringActive) {
      // Transcribe and continue requirement gathering
      const { transcribeAudio, checkWhisperModel } = require('./whisper-transcribe.js');

      const modelStatus = await checkWhisperModel();
      if (!modelStatus.available) {
        await ctx.reply(`‚ùå Voice not available: ${modelStatus.message}`);
        return;
      }

      await ctx.reply('üé§ Transcribing voice message...');
      const fileLink = await ctx.telegram.getFileLink(ctx.message.voice.file_id);
      const transcription = await transcribeAudio(fileLink.href);
      await ctx.reply(`Transcribed: "${transcription}"`);

      // Continue with transcribed text
      return;
    }

    // Check for pending questions
    const pending = getPendingQuestions();
    if (pending.length > 0) {
      // Transcribe for blocking question response
      // ... (similar to text handler)
    }

    await ctx.reply('Please select an option:', MAIN_MENU);
  });
}

/**
 * Stop Haiku monitor
 */
function stopHaikuMonitor() {
  monitorActive = false;
  currentConversationMode = null;
  requirementGatheringActive = false;
  console.log('Haiku monitor stopped');
}

/**
 * Handle Status menu
 */
async function handleStatusMenu(ctx) {
  await ctx.answerCbQuery();

  // Load current execution status
  let statusText = 'üìä **Current Status**\n\n';

  try {
    const state = require('fs').readFileSync('.planning/STATE.md', 'utf8');
    const positionMatch = state.match(/## Current Position\n\n([\s\S]*?)\n\n##/);
    if (positionMatch) {
      statusText += positionMatch[1].slice(0, 200);
    }
  } catch (err) {
    statusText += 'No active execution';
  }

  const backButton = Markup.inlineKeyboard([
    Markup.button.callback('¬´ Back to Menu', 'back:main')
  ]);

  await ctx.editMessageText(statusText, { parse_mode: 'Markdown', ...backButton });
  logBotResponse(statusText);
}

/**
 * Handle Pending Questions menu
 */
async function handlePendingMenu(ctx) {
  await ctx.answerCbQuery();

  const pending = getPendingQuestions();

  if (pending.length === 0) {
    const backButton = Markup.inlineKeyboard([
      Markup.button.callback('¬´ Back to Menu', 'back:main')
    ]);
    await ctx.editMessageText('No pending questions.', backButton);
    return;
  }

  await showPendingQuestionsMenu(ctx, true);
}

/**
 * Show pending questions with buttons
 */
async function showPendingQuestionsMenu(ctx, isEdit = false) {
  const pending = getPendingQuestions();

  let text = `‚ùì **Pending Questions** (${pending.length})\n\nClick to respond:\n\n`;

  const buttons = pending.map((q, idx) => {
    const preview = q.question.slice(0, 40);
    return [Markup.button.callback(`${idx + 1}. ${preview}...`, `answer:${q.questionId}`)];
  });

  buttons.push([Markup.button.callback('¬´ Back to Menu', 'back:main')]);

  const keyboard = Markup.inlineKeyboard(buttons);

  if (isEdit) {
    await ctx.editMessageText(text, { parse_mode: 'Markdown', ...keyboard });
  } else {
    await ctx.reply(text, { parse_mode: 'Markdown', ...keyboard });
  }

  // Register answer handlers
  pending.forEach(q => {
    ctx.telegram.bot.action(`answer:${q.questionId}`, async (answerCtx) => {
      await answerCtx.answerCbQuery();
      await answerCtx.reply(`**Question:** ${q.question}\n\nSend your response (text or voice):`);

      // Set up one-time handler for next message
      const conversation = require('./telegram-conversation.js');
      const originalHandler = ctx.telegram.bot.on('text');

      ctx.telegram.bot.once('text', async (responseCtx) => {
        const response = responseCtx.message.text;
        conversation.handleResponse(q.questionId, { type: 'text', content: response });
        await responseCtx.reply(`‚úÖ Response recorded!\n\nResuming execution...`);
        logBotResponse('Response matched to selected question');
      });
    });
  });
}

/**
 * Handle New Requirements menu
 */
async function handleRequirementsMenu(ctx) {
  await ctx.answerCbQuery();
  currentConversationMode = 'requirements';
  requirementGatheringActive = true;

  await ctx.editMessageText(
    '‚ú® **New Requirements**\n\n' +
    'Describe what you want to build. I\'ll ask clarifying questions.\n\n' +
    'Send your first message or type "cancel" to abort.'
  );

  logBotResponse('Started requirement gathering mode');

  // Set up requirement gathering flow
  const sendMessage = async (text) => {
    await ctx.telegram.sendMessage(ctx.from.id, text);
  };

  const waitForResponse = () => {
    return new Promise((resolve) => {
      const handler = (responseCtx) => {
        const text = responseCtx.message.text;
        logMessage(responseCtx.from.id, responseCtx.from.username, 'text', text);
        ctx.telegram.bot.removeListener('text', handler);
        resolve(text);
      };
      ctx.telegram.bot.once('text', handler);
    });
  };

  // Wait for first message
  const initialMessage = await waitForResponse();

  if (/^cancel$/i.test(initialMessage.trim())) {
    await sendMessage('‚ùå Cancelled.');
    requirementGatheringActive = false;
    currentConversationMode = null;
    await ctx.telegram.sendMessage(ctx.from.id, 'Main Menu:', MAIN_MENU);
    return;
  }

  // Start requirement gathering
  try {
    const decision = await gatherRequirements(sendMessage, waitForResponse, initialMessage);

    if (decision) {
      await executeDecision(decision, sendMessage);
    }
  } catch (error) {
    await sendMessage(`‚ùå Error: ${error.message}`);
  } finally {
    requirementGatheringActive = false;
    currentConversationMode = null;
    await ctx.telegram.sendMessage(ctx.from.id, 'Main Menu:', MAIN_MENU);
  }
}

/**
 * Get monitor status
 */
function getMonitorStatus() {
  return {
    active: monitorActive,
    conversation_mode: currentConversationMode,
    requirement_gathering: requirementGatheringActive
  };
}

module.exports = {
  startHaikuMonitor,
  stopHaikuMonitor,
  getMonitorStatus,
  MAIN_MENU
};
```
  </action>
  <verify>
```bash
node -e "const monitor = require('./get-shit-done/bin/telegram-haiku-monitor.js'); console.log(typeof monitor.startHaikuMonitor, typeof monitor.getMonitorStatus)"
```
Output: `function function`
  </verify>
  <done>Haiku monitor handles menu interactions, routes to requirement gathering, manages conversation modes</done>
</task>

<task type="auto">
  <name>Task 4: Update telegram-bot.js with menu and auto-matching</name>
  <files>get-shit-done/bin/telegram-bot.js</files>
  <action>
Update telegram-bot.js to integrate Haiku monitor and add auto-matching:

1. Add menu keyboard to /start command:
```javascript
bot.command('start', async (ctx) => {
  const chatId = ctx.from.id;
  const username = ctx.from.username;

  // Store chat ID for owner verification
  if (!process.env.TELEGRAM_OWNER_ID || chatId.toString() === process.env.TELEGRAM_OWNER_ID) {
    await ctx.reply(
      `üëã Welcome ${username}!\n\n` +
      `I'm your GSD assistant powered by Haiku.\n\n` +
      `Use the menu below to:\n` +
      `‚Ä¢ Check execution status\n` +
      `‚Ä¢ Respond to pending questions\n` +
      `‚Ä¢ Add new requirements\n\n` +
      `Voice messages are supported! üé§`,
      require('./telegram-haiku-monitor.js').MAIN_MENU
    );
  } else {
    await ctx.reply('Unauthorized. This bot is private.');
  }
});
```

2. Import and start Haiku monitor in startBot():
```javascript
async function startBot() {
  if (botStarted) {
    console.log('Bot already running');
    return;
  }

  const { startSession } = require('./telegram-session-logger.js');
  const { startHaikuMonitor } = require('./telegram-haiku-monitor.js');

  // Start session logging
  const sessionPath = startSession();
  console.log(`Session log: ${sessionPath}`);

  // Start Haiku monitor
  startHaikuMonitor(bot);

  await bot.launch();
  botStarted = true;
  console.log('Telegram bot started with Haiku monitor');
}
```

3. Stop Haiku monitor in stopBot():
```javascript
function stopBot() {
  if (!botStarted) return;

  const { stopHaikuMonitor } = require('./telegram-haiku-monitor.js');
  const { endSession } = require('./telegram-session-logger.js');

  stopHaikuMonitor();
  const sessionPath = endSession();
  console.log(`Session ended: ${sessionPath}`);

  bot.stop();
  botStarted = false;
  console.log('Telegram bot stopped');
}
```

4. Remove old text/voice handlers (now handled by Haiku monitor)
  </action>
  <verify>
```bash
grep -c "startHaikuMonitor" get-shit-done/bin/telegram-bot.js
```
Output: `1` or more
  </verify>
  <done>Bot integrates Haiku monitor, shows menu on /start, logs sessions</done>
</task>

<task type="auto">
  <name>Task 5: Update gsd-tools.js telegram commands</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Update telegram commands in gsd-tools.js:

1. Modify `telegram start` command:
```javascript
case 'start':
  const telegram = require('./telegram-bot.js');
  console.log('Starting Telegram bot with Haiku monitor...');
  await telegram.startBot();
  console.log('\nBot running! Press Ctrl+C to stop.\n');
  console.log('üì± Send /start to your bot in Telegram to see the menu.');

  // Keep process alive
  await new Promise(() => {}); // Never resolves
  break;
```

2. Add `telegram logs` command:
```javascript
case 'logs':
  const logger = require('./telegram-session-logger.js');
  const sessions = logger.getAllSessions();

  if (sessions.length === 0) {
    console.log('No session logs found');
    break;
  }

  if (args[1] === '--latest' || !args[1]) {
    // Show latest session
    const events = logger.readSession(sessions[0]);
    console.log(JSON.stringify(events, null, 2));
  } else if (args[1] === '--list') {
    // List all sessions
    console.log('Session logs:');
    sessions.forEach((s, i) => {
      const basename = require('path').basename(s);
      console.log(`  ${i + 1}. ${basename}`);
    });
  } else {
    // Show specific session by index
    const idx = parseInt(args[1]) - 1;
    if (idx >= 0 && idx < sessions.length) {
      const events = logger.readSession(sessions[idx]);
      console.log(JSON.stringify(events, null, 2));
    } else {
      console.log('Invalid session index');
    }
  }
  break;
```

3. Update help text:
```javascript
telegram start|stop|status|logs  Telegram bot with Haiku monitor
  logs [--latest|--list|N]       Show session logs
```
  </action>
  <verify>
```bash
node get-shit-done/bin/gsd-tools.js help | grep "telegram start"
```
Output contains: `telegram start`
  </verify>
  <done>GSD commands updated with Haiku monitor integration and logs command</done>
</task>

<task type="auto">
  <name>Task 6: Fix dashboard ports and update telegram-bot.js graceful fallback</name>
  <files>get-shit-done/bin/dashboard-server.js, get-shit-done/bin/telegram-bot.js</files>
  <action>
1. Update dashboard-server.js default ports:
```javascript
function startDashboard(options = {}) {
  const httpPort = options.httpPort || 8765;  // Changed from 3000
  const wsPort = options.wsPort || 8766;      // Changed from 8080
  // ... rest of function
}
```

2. Update telegram-bot.js to remove graceful fallback that returns fake functions.

Replace the graceful fallback section with:
```javascript
if (!process.env.TELEGRAM_BOT_TOKEN) {
  console.error('[ERROR] TELEGRAM_BOT_TOKEN not set. Set it in .env file.');
  console.error('To create a bot: Message @BotFather on Telegram -> /newbot');
  process.exit(1);
}
```

This ensures the bot fails fast if credentials are missing, rather than silently returning no-op functions.
  </action>
  <verify>
```bash
grep -c "8765" get-shit-done/bin/dashboard-server.js && grep -c "process.exit" get-shit-done/bin/telegram-bot.js
```
Output: `1` and `1` (or more)
  </verify>
  <done>Dashboard uses ports 8765/8766, bot fails fast without credentials</done>
</task>

<task type="auto">
  <name>Task 7: Install @anthropic-ai/sdk dependency</name>
  <files>get-shit-done/package.json</files>
  <action>
Install Anthropic SDK for Haiku subagent:

```bash
cd get-shit-done && npm install @anthropic-ai/sdk
```

Verify it's added to package.json dependencies.
  </action>
  <verify>
```bash
grep -c "@anthropic-ai/sdk" get-shit-done/package.json
```
Output: `1`
  </verify>
  <done>Anthropic SDK installed for Haiku API calls</done>
</task>

</tasks>

<verification>
Phase verification criteria:
1. `node get-shit-done/bin/gsd-tools.js telegram start` launches bot with Haiku monitor
2. /start in Telegram shows menu with 3 buttons
3. Clicking "New Requirements" starts Haiku conversation
4. Haiku asks clarifying questions until requirements clear
5. Haiku decides destination and executes appropriate command
6. Single pending question auto-matches response without ID
7. Multiple pending questions show button list
8. Session logs created in .planning/telegram-sessions/
9. Dashboard uses ports 8765/8766 instead of 3000/8080
</verification>

<success_criteria>
- Haiku monitor runs continuously behind bot
- Menu system with 3 buttons working
- Requirement gathering uses Haiku subagent with multi-turn conversation
- Auto-matching for single pending questions
- Session logging captures all activity
- Integration with GSD commands (add-phase, insert-phase, todos)
- Dashboard port conflicts resolved
</success_criteria>

<output>
After completion, create `.planning/phases/08-notifications-and-observability/08-06-SUMMARY.md`
</output>
