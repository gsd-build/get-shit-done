---
phase: 10.1-multi-instance-mcp-safety
plan: 03
type: execute
wave: 3
depends_on: ["10.1-02"]
files_modified:
  - mcp-servers/telegram-mcp/src/tools/ask-question.ts
  - mcp-servers/telegram-mcp/src/tools/check-answers.ts
  - mcp-servers/telegram-mcp/src/tools/mark-answered.ts
  - mcp-servers/telegram-mcp/src/index.ts
autonomous: true

must_haves:
  truths:
    - "MCP server creates a session on startup and manages its lifecycle"
    - "ask_blocking_question writes to the server's own session file"
    - "check_question_answers polls only the server's own session"
    - "Heartbeat updates every 5 minutes while server runs"
    - "Session is closed and cleaned up on graceful shutdown"
    - "mark_question_answered archives within the session file (no separate archive)"
  artifacts:
    - path: "mcp-servers/telegram-mcp/src/tools/ask-question.ts"
      provides: "Session-aware question creation"
      exports: ["askBlockingQuestionHandler", "ASK_QUESTION_TOOL_DEF"]
    - path: "mcp-servers/telegram-mcp/src/tools/check-answers.ts"
      provides: "Session-scoped answer polling"
      exports: ["checkQuestionAnswersHandler", "CHECK_ANSWERS_TOOL_DEF"]
    - path: "mcp-servers/telegram-mcp/src/tools/mark-answered.ts"
      provides: "Session-scoped question archival"
      exports: ["markQuestionAnsweredHandler", "MARK_ANSWERED_TOOL_DEF"]
    - path: "mcp-servers/telegram-mcp/src/index.ts"
      provides: "Session lifecycle in MCP server (create, heartbeat, cleanup, close)"
      exports: ["main"]
  key_links:
    - from: "mcp-servers/telegram-mcp/src/index.ts"
      to: "mcp-servers/telegram-mcp/src/storage/session-manager.ts"
      via: "createSession, cleanupStaleSessions, updateHeartbeat, closeSession"
      pattern: "import.*session-manager"
    - from: "mcp-servers/telegram-mcp/src/tools/ask-question.ts"
      to: "mcp-servers/telegram-mcp/src/storage/question-queue.ts"
      via: "appendQuestion(sessionId, ...)"
      pattern: "appendQuestion.*sessionId"
---

<objective>
Update MCP tools and server entry point for session-aware operation with heartbeat and lifecycle management.

Purpose: Wire the session infrastructure into the MCP server so each Claude Code instance operates within its own session with proper lifecycle (create on start, heartbeat during run, close on shutdown).
Output: Updated tool handlers using session-scoped storage, server entry with session lifecycle.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/10.1-multi-instance-mcp-safety-robust-concurrent-claude-code-support-with-per-session-storage-file-locking-and-proper-answer-routing/10.1-02-SUMMARY.md
@mcp-servers/telegram-mcp/src/tools/ask-question.ts
@mcp-servers/telegram-mcp/src/tools/check-answers.ts
@mcp-servers/telegram-mcp/src/tools/mark-answered.ts
@mcp-servers/telegram-mcp/src/index.ts
@mcp-servers/telegram-mcp/src/storage/question-queue.ts
@mcp-servers/telegram-mcp/src/storage/session-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update MCP tools for session-scoped operation</name>
  <files>
    mcp-servers/telegram-mcp/src/tools/ask-question.ts
    mcp-servers/telegram-mcp/src/tools/check-answers.ts
    mcp-servers/telegram-mcp/src/tools/mark-answered.ts
  </files>
  <action>
    All three tools need access to the current session ID. Use a module-level variable set by the server entry point.

    **Create a session state module** (or add to existing): Export `let currentSessionId: string | null = null` and `setCurrentSessionId(id: string)` / `getCurrentSessionId(): string` functions. Place this in a shared location the tools can import (e.g., add to `tools/index.ts` or create a small `session-state.ts` in storage/).

    **ask-question.ts changes:**
    - Import getCurrentSessionId
    - In handler: get sessionId from getCurrentSessionId() (throw if null - server not initialized)
    - Call appendQuestion(sessionId, { question, context }) instead of appendQuestion({ question, context })
    - Update formatQuestionMessage to show session label instead of PID: use metadata.label or sessionId.slice(0,8)
    - Output stays the same (question_id, asked_at, status)

    **check-answers.ts changes:**
    - Import getCurrentSessionId
    - Remove process.pid-based session filtering (mySessionId = process.pid)
    - Use getCurrentSessionId() to get session ID
    - In pollForAnswers: call loadPendingQuestions(sessionId) instead of global loadPendingQuestions()
    - The function now only sees questions from its own session (isolation by design, not by filtering)
    - Simplify: no need to filter by session_id since loadPendingQuestions already scopes to one session
    - But we need to detect "answered" - since markAnswered updates in-place in session file, we need to load ALL entries (not just pending) and check for answered status
    - Actually: loadPendingQuestions only returns pending. For answered detection, add logic: load full session JSONL, find question entries where status=answered AND matching question_ids filter

    **mark-answered.ts changes:**
    - Import getCurrentSessionId
    - Update to call getPendingById(questionId, sessionId) with session scope
    - Remove archiveQuestion call (answered questions stay in session file per user decision)
    - Update output: archived_to becomes session file path instead of daily log path
    - Actually rethink: mark_question_answered is called by Claude AFTER getting the answer via check_answers. The bot already wrote the answer to the session file. This tool just confirms Claude received it. Update to simply return success with session path.
  </action>
  <verify>
    - `cd mcp-servers/telegram-mcp && npx tsc --noEmit` compiles
    - No references to process.pid for session identification in tool files
    - All tools use getCurrentSessionId() for session scoping
  </verify>
  <done>All three MCP tools operate within current session scope, no cross-session data leakage</done>
</task>

<task type="auto">
  <name>Task 2: Add session lifecycle to MCP server entry point</name>
  <files>mcp-servers/telegram-mcp/src/index.ts</files>
  <action>
    Update index.ts to manage session lifecycle:

    **On startup (in main()):**
    1. Run cleanupStaleSessions() (opportunistic, catch errors)
    2. Create session: `const sessionId = await createSession()` - no label for now (label is optional/contextual)
    3. Set session ID for tools: `setCurrentSessionId(sessionId)`
    4. Start heartbeat interval: `setInterval(() => updateHeartbeat(sessionId).catch(err => console.error('[MCP] Heartbeat error:', err)), 5 * 60 * 1000)` (every 5 minutes)
    5. Log session ID to stderr: `[MCP] Session: ${sessionId}`

    **On shutdown (SIGINT/SIGTERM handlers):**
    1. Clear heartbeat interval
    2. Close session: `await closeSession(sessionId)` (catch errors, don't block shutdown)
    3. Stop bot
    4. process.exit(0)

    **Import additions:**
    - Import createSession, cleanupStaleSessions, updateHeartbeat, closeSession from storage/session-manager
    - Import setCurrentSessionId from wherever the session state is defined

    **Keep everything else the same:** Tool registration, resource handlers, bot startup, error handling.
  </action>
  <verify>
    - `cd mcp-servers/telegram-mcp && npx tsc --noEmit` compiles
    - index.ts imports session-manager functions
    - Heartbeat interval created in main()
    - SIGINT/SIGTERM handlers close session before exit
  </verify>
  <done>MCP server creates session on startup, heartbeats every 5 minutes, closes session on shutdown</done>
</task>

</tasks>

<verification>
- `cd mcp-servers/telegram-mcp && npx tsc --noEmit` full project compiles
- ask-question uses session-scoped appendQuestion
- check-answers polls session-scoped questions only
- Server creates session and starts heartbeat on startup
- Server closes session on SIGINT/SIGTERM
</verification>

<success_criteria>
MCP server operates within an isolated session. Questions are written to session-specific files. Polling reads only from the current session. Heartbeat keeps session alive. Clean shutdown closes the session.
</success_criteria>

<output>
After completion, create `.planning/phases/10.1-multi-instance-mcp-safety-robust-concurrent-claude-code-support-with-per-session-storage-file-locking-and-proper-answer-routing/10.1-03-SUMMARY.md`
</output>
