---
phase: 10.1-multi-instance-mcp-safety
plan: 02
type: execute
wave: 2
depends_on: ["10.1-01"]
files_modified:
  - mcp-servers/telegram-mcp/src/storage/question-queue.ts
  - mcp-servers/telegram-mcp/src/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "Questions are stored in per-session JSONL files, not global pending.jsonl"
    - "Each question entry includes session_id linking it to the correct session"
    - "Loading pending questions scans only the specified session file"
    - "Marking a question answered updates in-place within session file using file lock"
    - "All file operations use withLock for concurrent access safety"
  artifacts:
    - path: "mcp-servers/telegram-mcp/src/storage/question-queue.ts"
      provides: "Session-scoped question CRUD operations"
      exports: ["appendQuestion", "loadPendingQuestions", "markAnswered", "getPendingById", "loadAllPendingQuestions"]
    - path: "mcp-servers/telegram-mcp/src/storage/index.ts"
      provides: "Re-exports storage modules including session-manager"
      exports: ["session-manager exports", "question-queue exports", "message-queue exports"]
  key_links:
    - from: "mcp-servers/telegram-mcp/src/storage/question-queue.ts"
      to: "mcp-servers/telegram-mcp/src/storage/session-manager.ts"
      via: "import getSessionPath, loadSessionJSONL, appendToSession"
      pattern: "import.*session-manager"
    - from: "mcp-servers/telegram-mcp/src/storage/question-queue.ts"
      to: "mcp-servers/telegram-mcp/src/storage/file-lock.ts"
      via: "import withLock for atomic question updates"
      pattern: "import.*file-lock"
---

<objective>
Refactor question-queue.ts to use per-session JSONL storage instead of global pending.jsonl.

Purpose: Core data layer change that makes questions session-scoped. All question operations now target a specific session file, enabling multi-instance isolation.
Output: Refactored `question-queue.ts` with session-aware CRUD, updated `index.ts` re-exports.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/10.1-multi-instance-mcp-safety-robust-concurrent-claude-code-support-with-per-session-storage-file-locking-and-proper-answer-routing/10.1-01-SUMMARY.md
@mcp-servers/telegram-mcp/src/storage/question-queue.ts
@mcp-servers/telegram-mcp/src/storage/session-manager.ts
@mcp-servers/telegram-mcp/src/storage/file-lock.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor question-queue.ts for session-scoped storage</name>
  <files>mcp-servers/telegram-mcp/src/storage/question-queue.ts</files>
  <action>
    Rewrite question-queue.ts to use per-session JSONL files. The module now requires a session_id parameter for most operations.

    **Keep the PendingQuestion interface** but update session_id type from `number` (PID) to `string` (UUID session ID).

    **Refactored functions:**

    1. `appendQuestion(sessionId: string, question: { question: string, context?: string }): Promise<PendingQuestion>`
       - Build question entry: { type: 'question', id: randomUUID(), session_id: sessionId, question, context, status: 'pending', created_at: ISO }
       - Use appendToSession(sessionId, entry) from session-manager (already handles locking)
       - Return the question object

    2. `loadPendingQuestions(sessionId: string): Promise<PendingQuestion[]>`
       - Load session JSONL via loadSessionJSONL(getSessionPath(sessionId))
       - Filter for type === 'question' && status === 'pending'
       - Return array of PendingQuestion

    3. `loadAllPendingQuestions(): Promise<Array<PendingQuestion & { session_id: string }>>` (NEW)
       - Discover all sessions via discoverSessions()
       - For each session, load pending questions
       - Return flat array with session_id attached to each question
       - This is used by Telegram bot to show all pending questions across sessions

    4. `markAnswered(sessionId: string, questionId: string, answer: string): Promise<void>`
       - Use withLock on session file path
       - Load all entries from session JSONL
       - Find question entry by id, update: status='answered', answer=answer, answered_at=ISO
       - Also append an answer event: { type: 'answer', question_id, answer, answered_at: ISO }
       - Atomic rewrite via temp file + rename (same pattern as existing code)
       - Keep answered question IN the session file (per user decision: complete history in one file)

    5. `getPendingById(questionId: string, sessionId?: string): Promise<PendingQuestion | null>`
       - If sessionId provided, search only that session
       - If not provided, search all sessions (for backward compat / bot use)
       - Return first match or null

    **Remove:** archiveQuestion function (archiving is now session-level, handled by session-manager), PENDING_FILE constant, old QUESTIONS_DIR-based logic.

    **Keep:** getProjectRoot(), writeAtomic() (used for session file rewrite in markAnswered).

    **Backward compatibility:** The old `.planning/telegram-questions/pending.jsonl` path is no longer used. Questions using the old format with numeric session_id (PID) won't be loaded since they're in a different location. This is acceptable per user decision (sessions can't be resumed, old questions are effectively abandoned).
  </action>
  <verify>
    - TypeScript compiles: `cd mcp-servers/telegram-mcp && npx tsc --noEmit`
    - Exports: appendQuestion, loadPendingQuestions, loadAllPendingQuestions, markAnswered, getPendingById
    - No references to PENDING_FILE or old pending.jsonl path
  </verify>
  <done>question-queue.ts uses per-session JSONL files for all question operations, PendingQuestion.session_id is string (UUID)</done>
</task>

<task type="auto">
  <name>Task 2: Update storage index to export session-manager</name>
  <files>mcp-servers/telegram-mcp/src/storage/index.ts</files>
  <action>
    Update `storage/index.ts` to re-export from both existing modules AND the new session-manager and file-lock modules:

    ```
    export * from './question-queue.js';
    export * from './message-queue.js';
    export * from './session-manager.js';
    export * from './file-lock.js';
    ```

    This ensures downstream consumers can import from `../storage/index.js` to get all storage functionality.
  </action>
  <verify>
    - `cd mcp-servers/telegram-mcp && npx tsc --noEmit` compiles
    - index.ts has 4 re-export lines
  </verify>
  <done>Storage index re-exports all modules including session-manager and file-lock</done>
</task>

</tasks>

<verification>
- `cd mcp-servers/telegram-mcp && npx tsc --noEmit` compiles full project
- question-queue.ts functions accept sessionId parameter
- loadAllPendingQuestions() discovers and aggregates across sessions
- No references to old pending.jsonl storage path in question-queue.ts
</verification>

<success_criteria>
Question storage is fully session-scoped. Each Claude Code instance's questions live in its own session file. Cross-session aggregation available for Telegram bot. File locking protects all write operations.
</success_criteria>

<output>
After completion, create `.planning/phases/10.1-multi-instance-mcp-safety-robust-concurrent-claude-code-support-with-per-session-storage-file-locking-and-proper-answer-routing/10.1-02-SUMMARY.md`
</output>
