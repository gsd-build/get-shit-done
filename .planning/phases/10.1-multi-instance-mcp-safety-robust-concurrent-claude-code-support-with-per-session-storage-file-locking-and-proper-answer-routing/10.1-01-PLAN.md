---
phase: 10.1-multi-instance-mcp-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp-servers/telegram-mcp/package.json
  - mcp-servers/telegram-mcp/src/storage/file-lock.ts
  - mcp-servers/telegram-mcp/src/storage/session-manager.ts
autonomous: true

must_haves:
  truths:
    - "File locking with exponential backoff prevents concurrent write corruption"
    - "Session creation produces isolated JSONL file with metadata as first line"
    - "Stale session detection uses both PID check and heartbeat TTL"
    - "Session archiving moves files to date-based archive folders"
    - "Corrupted JSONL files are handled gracefully without crashing"
  artifacts:
    - path: "mcp-servers/telegram-mcp/src/storage/file-lock.ts"
      provides: "withLock() wrapper using proper-lockfile with retry+backoff"
      exports: ["withLock"]
    - path: "mcp-servers/telegram-mcp/src/storage/session-manager.ts"
      provides: "Session lifecycle (create, discover, cleanup, archive, heartbeat, isAlive)"
      exports: ["createSession", "discoverSessions", "cleanupStaleSessions", "archiveSession", "isSessionAlive", "loadSessionJSONL", "appendToSession", "getSessionPath", "SESSIONS_DIR"]
  key_links:
    - from: "mcp-servers/telegram-mcp/src/storage/session-manager.ts"
      to: "mcp-servers/telegram-mcp/src/storage/file-lock.ts"
      via: "import withLock"
      pattern: "withLock.*file-lock"
---

<objective>
Create session management infrastructure and file locking for multi-instance Claude Code support.

Purpose: Foundation layer that enables per-session JSONL storage with proper concurrent access protection. All subsequent plans depend on this infrastructure.
Output: `file-lock.ts` (locking abstraction) and `session-manager.ts` (session lifecycle management) plus npm dependencies installed.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@mcp-servers/telegram-mcp/package.json
@mcp-servers/telegram-mcp/src/storage/question-queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create file locking module</name>
  <files>
    mcp-servers/telegram-mcp/package.json
    mcp-servers/telegram-mcp/src/storage/file-lock.ts
  </files>
  <action>
    Install new dependencies: `npm install proper-lockfile uuid` and `npm install -D @types/proper-lockfile` in mcp-servers/telegram-mcp/.

    Create `file-lock.ts` with a single exported function:

    `withLock<T>(filePath: string, operation: () => Promise<T>): Promise<T>`

    Implementation details:
    - Use proper-lockfile (import { lock } from 'proper-lockfile')
    - Retry with exponential backoff: 3 retries at 100ms, 200ms, 400ms delays
    - Stale lock threshold: 10000ms (10 seconds)
    - On successful lock acquisition, run operation(), then release lock in finally block
    - If all retries fail, throw descriptive error with attempt count and last error message
    - Log lock acquisition failures to stderr for debugging (console.error with [file-lock] prefix)

    Do NOT use process-exists yet (session-manager will handle that). UUID will be used in session-manager.
  </action>
  <verify>
    - `npm ls proper-lockfile` shows installed version
    - `npm ls uuid` shows installed version
    - File exists: `mcp-servers/telegram-mcp/src/storage/file-lock.ts`
    - TypeScript compiles: `cd mcp-servers/telegram-mcp && npx tsc --noEmit src/storage/file-lock.ts`
  </verify>
  <done>withLock function exported, proper-lockfile and uuid installed, TypeScript compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create session manager with lifecycle operations</name>
  <files>mcp-servers/telegram-mcp/src/storage/session-manager.ts</files>
  <action>
    Create `session-manager.ts` that manages the full session lifecycle. Uses `.planning/telegram-sessions/<session-id>.jsonl` for storage.

    **Constants:**
    - SESSIONS_DIR: `path.join(PROJECT_ROOT, '.planning/telegram-sessions')` using same PROJECT_ROOT pattern as question-queue.ts
    - ARCHIVE_DIR: `path.join(SESSIONS_DIR, 'archive')`
    - HEARTBEAT_TTL_HOURS: 24
    - Export SESSIONS_DIR for use by other modules

    **Interfaces:**
    - SessionMetadata: { type: 'session_metadata', session_id: string, pid: number, cwd: string, start_time: string, last_heartbeat: string, label?: string, tasks: any[] }
    - SessionEntry: { type: string, [key: string]: any } (generic JSONL entry)
    - SessionInfo: { id: string, path: string, metadata: SessionMetadata | null }

    **Functions to implement:**

    1. `getSessionPath(sessionId: string): string` - Returns full path to session JSONL file

    2. `loadSessionJSONL(filePath: string): Promise<any[]>` - Self-healing JSONL reader:
       - Return [] if file doesn't exist
       - Parse each line individually, skip corrupted lines with console.warn
       - Log warning if >10% lines corrupted
       - On total read failure, return []

    3. `appendToSession(sessionId: string, entry: any): Promise<void>` - Locked append:
       - Use withLock from file-lock.ts around appendFile
       - Append JSON.stringify(entry) + '\n'

    4. `createSession(label?: string): Promise<string>` - Creates new session:
       - Generate UUID v4 via `import { v4 as uuidv4 } from 'uuid'`
       - Create SessionMetadata as first line
       - Ensure SESSIONS_DIR exists (mkdir -p)
       - Trigger cleanupStaleSessions() opportunistically (catch errors, don't block)
       - Return session ID

    5. `discoverSessions(): Promise<SessionInfo[]>` - Directory scan:
       - Read SESSIONS_DIR, filter *.jsonl files (not starting with '.')
       - For each, load first line to get metadata (or null if corrupted)
       - Return array of SessionInfo

    6. `isSessionAlive(metadata: SessionMetadata): Promise<boolean>` - Dual detection:
       - Check PID exists: use `process.kill(metadata.pid, 0)` in try/catch (signal 0 = existence check, no external dep needed)
       - Check heartbeat freshness: last_heartbeat within HEARTBEAT_TTL_HOURS
       - Return true only if BOTH checks pass

    7. `cleanupStaleSessions(): Promise<void>` - Opportunistic cleanup:
       - Discover all sessions
       - For each, check isSessionAlive
       - Archive dead sessions

    8. `archiveSession(sessionPath: string): Promise<void>` - Move to archive:
       - Compute archive path: `ARCHIVE_DIR/YYYY-MM-DD/<session-id>.jsonl`
       - mkdir -p the date directory
       - fs.rename(sessionPath, archivePath)
       - Log to stderr

    9. `updateHeartbeat(sessionId: string): Promise<void>` - Update heartbeat:
       - Append heartbeat entry { type: 'heartbeat', timestamp: ISO string } to session file

    10. `closeSession(sessionId: string): Promise<void>` - Explicit close:
        - Append { type: 'session_close', timestamp: ISO string } to session file

    NOTE: Use `process.kill(pid, 0)` for PID check instead of process-exists package (simpler, no extra dependency, works on macOS/Linux). The try/catch around process.kill handles "process not found" gracefully.
  </action>
  <verify>
    - File exists: `mcp-servers/telegram-mcp/src/storage/session-manager.ts`
    - TypeScript compiles: `cd mcp-servers/telegram-mcp && npx tsc --noEmit src/storage/session-manager.ts`
    - Exports: createSession, discoverSessions, cleanupStaleSessions, archiveSession, isSessionAlive, loadSessionJSONL, appendToSession, getSessionPath, SESSIONS_DIR
  </verify>
  <done>Session manager with full lifecycle (create, discover, cleanup, archive, heartbeat, close) implemented and compiling</done>
</task>

</tasks>

<verification>
- `cd mcp-servers/telegram-mcp && npx tsc --noEmit` compiles entire project
- proper-lockfile, uuid packages in node_modules
- file-lock.ts exports withLock
- session-manager.ts exports all 9 functions + SESSIONS_DIR constant
</verification>

<success_criteria>
Session infrastructure ready for question-queue refactor. File locking protects concurrent access. Session manager handles full lifecycle from creation through archival.
</success_criteria>

<output>
After completion, create `.planning/phases/10.1-multi-instance-mcp-safety-robust-concurrent-claude-code-support-with-per-session-storage-file-locking-and-proper-answer-routing/10.1-01-SUMMARY.md`
</output>
