---
phase: 10.1-multi-instance-mcp-safety
plan: 04
type: execute
wave: 4
depends_on: ["10.1-03"]
files_modified:
  - mcp-servers/telegram-mcp/src/bot/telegram-bot.ts
  - .planning/.gitignore
autonomous: true

must_haves:
  truths:
    - "Telegram bot shows pending questions from ALL active sessions with session labels"
    - "Clicking a question button routes answer to the correct session file"
    - "Session label or ID prefix shown in Telegram messages for identification"
    - "Single pending question still auto-matches for convenience"
    - "Archive directory is gitignored"
    - "System works correctly when only one instance is running"
  artifacts:
    - path: "mcp-servers/telegram-mcp/src/bot/telegram-bot.ts"
      provides: "Multi-session Telegram UI with button-based answer routing"
    - path: ".planning/.gitignore"
      provides: "Gitignore rules for session archive and session files"
  key_links:
    - from: "mcp-servers/telegram-mcp/src/bot/telegram-bot.ts"
      to: "mcp-servers/telegram-mcp/src/storage/question-queue.ts"
      via: "loadAllPendingQuestions, markAnswered(sessionId, questionId, answer)"
      pattern: "loadAllPendingQuestions|markAnswered"
    - from: "mcp-servers/telegram-mcp/src/bot/telegram-bot.ts"
      to: "mcp-servers/telegram-mcp/src/storage/session-manager.ts"
      via: "discoverSessions for session metadata/labels"
      pattern: "discoverSessions|loadSessionJSONL"
---

<objective>
Update Telegram bot for multi-session question routing with button-based UI, and configure gitignore for session files.

Purpose: The user-facing Telegram interface must handle questions from multiple simultaneous Claude Code instances, routing answers to the correct session file. This is the final integration piece that makes multi-instance operation visible and functional.
Output: Updated `telegram-bot.ts` with multi-session UI, `.planning/.gitignore` with archive rules.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/10.1-multi-instance-mcp-safety-robust-concurrent-claude-code-support-with-per-session-storage-file-locking-and-proper-answer-routing/10.1-03-SUMMARY.md
@mcp-servers/telegram-mcp/src/bot/telegram-bot.ts
@mcp-servers/telegram-mcp/src/storage/question-queue.ts
@mcp-servers/telegram-mcp/src/storage/session-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Telegram bot for multi-session question routing</name>
  <files>mcp-servers/telegram-mcp/src/bot/telegram-bot.ts</files>
  <action>
    Update the bot to handle questions from multiple sessions.

    **Import changes:**
    - Import loadAllPendingQuestions (new), markAnswered (now takes sessionId) from question-queue
    - Import discoverSessions, loadSessionJSONL from session-manager
    - Remove import of loadPendingQuestions (replaced by loadAllPendingQuestions for bot context)

    **Update menu:pending handler (`botInstance.action('menu:pending', ...)`):**
    - Call loadAllPendingQuestions() to get questions across ALL sessions
    - For each question, get session metadata to display label
    - Build button text: `"N. [label] preview..."` where label = metadata.label || sessionId.slice(0,8)
    - Button callback data: `answer:<sessionId>:<questionId>` (include both session and question ID)
    - Show count: "Pending Questions (N from M sessions)"

    **Update answer button handler (`botInstance.action(/^answer:(.+)$/, ...)`):**
    - Change regex to capture both session ID and question ID: `/^answer:([^:]+):(.+)$/`
    - Extract sessionId = ctx.match[1], questionId = ctx.match[2]
    - Store both in session state: `ctx.session.awaitingQuestionResponse = questionId`, add `ctx.session.awaitingSessionId = sessionId`
    - Update SessionData interface to include awaitingSessionId: string | null

    **Update text message handler:**
    - When awaitingQuestionResponse is set, also use awaitingSessionId
    - Call markAnswered(sessionId, questionId, text) with session ID
    - For auto-match (single pending question): use loadAllPendingQuestions(), if exactly 1, auto-match with its session_id

    **Update voice message handler:**
    - Same changes as text handler: use awaitingSessionId, pass sessionId to markAnswered
    - For auto-match: same as text handler

    **Update sendBlockingQuestion function:**
    - This function is called by the bot module itself (not MCP tools). Update it to accept sessionId parameter if needed, or note that it may be deprecated since MCP tools now handle question creation. If the function is still used, pass session ID through.

    **Question format in Telegram messages:**
    - When ask-question sends notification, format includes session label: `"[feature-auth] Question from Claude: ..."`
    - If no label: `"[abc12345] Question from Claude: ..."` (session ID prefix)
  </action>
  <verify>
    - `cd mcp-servers/telegram-mcp && npx tsc --noEmit` compiles
    - Button callback data includes session ID: `answer:<sessionId>:<questionId>`
    - SessionData interface has awaitingSessionId field
    - markAnswered calls include sessionId parameter
    - loadAllPendingQuestions used for cross-session question listing
  </verify>
  <done>Telegram bot routes answers to correct session files, shows session labels in question list, handles multi-session and single-session scenarios</done>
</task>

<task type="auto">
  <name>Task 2: Configure gitignore for session files and archive</name>
  <files>.planning/.gitignore</files>
  <action>
    Create or update `.planning/.gitignore` to exclude session runtime data while keeping the directory structure trackable.

    Add rules:
    ```
    # Telegram session files (runtime, per-instance)
    telegram-sessions/*.jsonl
    telegram-sessions/**/*.lock
    telegram-sessions/archive/

    # Legacy question queue (replaced by per-session storage)
    telegram-questions/

    # Telegram queue (runtime)
    telegram-queue/
    ```

    If `.planning/.gitignore` already exists, append these rules. If not, create it.

    Also verify that the main project `.gitignore` doesn't conflict (it should be fine since `.planning/` is generally tracked).
  </action>
  <verify>
    - `.planning/.gitignore` exists with session-related rules
    - `git status .planning/telegram-sessions/` shows files as ignored (after creating a test session file)
  </verify>
  <done>Session JSONL files and archive directory properly gitignored, directory structure maintained</done>
</task>

</tasks>

<verification>
- `cd mcp-servers/telegram-mcp && npx tsc --noEmit` full project compiles
- `cd mcp-servers/telegram-mcp && npm run build` succeeds
- Telegram bot pending menu handles multi-session questions
- Answer routing includes session ID in callback data
- .planning/.gitignore excludes session runtime files
</verification>

<success_criteria>
End-to-end multi-instance flow works: multiple MCP servers create separate sessions, Telegram bot shows all pending questions with session identification, user answers route to correct session file, single-instance operation has zero overhead. Session files and archives are properly gitignored.
</success_criteria>

<output>
After completion, create `.planning/phases/10.1-multi-instance-mcp-safety-robust-concurrent-claude-code-support-with-per-session-storage-file-locking-and-proper-answer-routing/10.1-04-SUMMARY.md`
</output>
