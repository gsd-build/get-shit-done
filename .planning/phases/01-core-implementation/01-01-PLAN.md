---
phase: 01-core-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/install.js
autonomous: true

must_haves:
  truths:
    - "claudeToCursorTools mapping object exists with all PascalCase→snake_case mappings"
    - "convertCursorToolName() function correctly converts tool names"
    - "convertClaudeToCursorFrontmatter() function converts frontmatter format"
    - "Tool names in body text are replaced (not just frontmatter)"
    - "Color names are converted to hex values"
  artifacts:
    - path: "bin/install.js"
      provides: "Cursor conversion functions"
      contains: "claudeToCursorTools"
      exports: ["convertCursorToolName", "convertClaudeToCursorFrontmatter"]
  key_links:
    - from: "convertClaudeToCursorFrontmatter"
      to: "convertCursorToolName"
      via: "tool name conversion in frontmatter"
      pattern: "convertCursorToolName\\("
    - from: "convertClaudeToCursorFrontmatter"
      to: "colorNameToHex"
      via: "color conversion lookup"
      pattern: "colorNameToHex\\["
---

<objective>
Implement Cursor-specific conversion functions for tool names and frontmatter format.

Purpose: These conversion functions are the foundation for all Cursor runtime support. Without them, commands and agents won't load correctly in Cursor IDE.

Output: Three new functions/objects in bin/install.js:
1. `claudeToCursorTools` - Tool name mapping object
2. `convertCursorToolName()` - Tool name conversion function  
3. `convertClaudeToCursorFrontmatter()` - Frontmatter conversion with body text replacement
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/research/FEATURES.md
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tool name mapping and conversion function</name>
  <files>bin/install.js</files>
  <action>
Add the Cursor tool name mapping object and conversion function after the existing `claudeToGeminiTools` object (around line 308).

**Add `claudeToCursorTools` mapping object:**
```javascript
// Tool name mapping from Claude Code to Cursor
// Cursor uses snake_case tool names like OpenCode
const claudeToCursorTools = {
  Read: 'read',
  Write: 'write',
  Edit: 'edit',
  Bash: 'bash',
  Glob: 'glob',
  Grep: 'grep',
  LS: 'ls',
  MultiEdit: 'multi_edit',
  AskUserQuestion: 'ask_question',
  TodoWrite: 'todo_write',
  WebFetch: 'web_fetch',
  WebSearch: 'web_search',
};
```

**Add `convertCursorToolName()` function after the mapping:**
```javascript
/**
 * Convert a Claude Code tool name to Cursor format
 * - Applies Claude→Cursor mapping (AskUserQuestion→ask_question, etc.)
 * - Excludes Task tool — Cursor uses subagent mechanism
 * - MCP tools (mcp__*) keep their format
 * @returns {string|null} Cursor tool name, or null if tool should be excluded
 */
function convertCursorToolName(claudeTool) {
  // Task: exclude — Cursor uses subagent mechanism, not Task tool
  if (claudeTool === 'Task') {
    return null;
  }
  // MCP tools: keep format as-is
  if (claudeTool.startsWith('mcp__')) {
    return claudeTool;
  }
  // Check for explicit mapping first
  if (claudeToCursorTools[claudeTool]) {
    return claudeToCursorTools[claudeTool];
  }
  // Default: convert PascalCase to snake_case
  return claudeTool.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
}
```

Place these after line 308 (after `claudeToGeminiTools`) and before `convertToolName()`.
  </action>
  <verify>
Search for `claudeToCursorTools` and `convertCursorToolName` in bin/install.js - both should exist.
Run `node -c bin/install.js` to verify syntax.
  </verify>
  <done>
- `claudeToCursorTools` object exists with 12 tool mappings
- `convertCursorToolName()` function exists and handles Task exclusion, MCP tools, and snake_case conversion
- No syntax errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add frontmatter conversion function with body text handling</name>
  <files>bin/install.js</files>
  <action>
Add the `convertClaudeToCursorFrontmatter()` function after the existing `convertClaudeToGeminiAgent()` function (around line 438).

**Requirements to implement:**
1. CONV-03: Frontmatter conversion (allowed-tools array OR tools string → tools object with boolean values)
2. CONV-04: Color name to hex conversion (reuse existing `colorNameToHex` mapping)
3. CONV-05: Tool name replacement in body text (not just frontmatter)
4. PATH-03: Path reference replacement (`~/.claude/` → `~/.cursor/`)
5. PATH-04: Command format conversion (`/gsd:` → `/gsd-`)

**Add this function:**
```javascript
/**
 * Convert Claude Code frontmatter to Cursor format
 * - Converts allowed-tools array or tools string to tools object with boolean values
 * - Converts color names to hex values
 * - Replaces tool name references in body text
 * - Replaces path references (~/.claude/ → ~/.cursor/)
 * - Replaces command format (/gsd: → /gsd-)
 * @param {string} content - Markdown file content with YAML frontmatter
 * @returns {string} - Content with converted frontmatter
 */
function convertClaudeToCursorFrontmatter(content) {
  // Replace tool name references in body text
  let convertedContent = content;
  
  // Replace PascalCase tool names with snake_case equivalents
  for (const [claude, cursor] of Object.entries(claudeToCursorTools)) {
    // Use word boundaries to avoid partial replacements
    const regex = new RegExp(`\\b${claude}\\b`, 'g');
    convertedContent = convertedContent.replace(regex, cursor);
  }
  
  // Replace /gsd: with /gsd- for Cursor command format
  convertedContent = convertedContent.replace(/\/gsd:/g, '/gsd-');
  
  // Replace ~/.claude/ with ~/.cursor/
  convertedContent = convertedContent.replace(/~\/\.claude\//g, '~/.cursor/');
  
  // Check if content has frontmatter
  if (!convertedContent.startsWith('---')) {
    return convertedContent;
  }

  // Find the end of frontmatter
  const endIndex = convertedContent.indexOf('---', 3);
  if (endIndex === -1) {
    return convertedContent;
  }

  const frontmatter = convertedContent.substring(3, endIndex).trim();
  const body = convertedContent.substring(endIndex + 3);

  // Parse frontmatter line by line
  const lines = frontmatter.split('\n');
  const newLines = [];
  let inAllowedTools = false;
  const allowedTools = [];

  for (const line of lines) {
    const trimmed = line.trim();

    // Detect start of allowed-tools array
    if (trimmed.startsWith('allowed-tools:')) {
      inAllowedTools = true;
      continue;
    }

    // Detect inline tools: field (comma-separated string)
    if (trimmed.startsWith('tools:')) {
      const toolsValue = trimmed.substring(6).trim();
      if (toolsValue) {
        // Parse comma-separated tools
        const tools = toolsValue.split(',').map(t => t.trim()).filter(t => t);
        allowedTools.push(...tools);
      } else {
        // tools: with no value means YAML array follows
        inAllowedTools = true;
      }
      continue;
    }

    // Remove name: field - Cursor uses filename for command name
    if (trimmed.startsWith('name:')) {
      continue;
    }

    // Convert color names to hex for Cursor
    if (trimmed.startsWith('color:')) {
      const colorValue = trimmed.substring(6).trim().replace(/['"]/g, '').toLowerCase();
      const hexColor = colorNameToHex[colorValue];
      if (hexColor) {
        newLines.push(`color: "${hexColor}"`);
      } else if (colorValue.startsWith('#')) {
        // Validate hex color format (#RGB or #RRGGBB)
        if (/^#[0-9a-f]{3}$|^#[0-9a-f]{6}$/i.test(colorValue)) {
          newLines.push(`color: "${colorValue}"`);
        }
        // Skip invalid hex colors
      }
      // Skip unknown color names
      continue;
    }

    // Collect allowed-tools items
    if (inAllowedTools) {
      if (trimmed.startsWith('- ')) {
        allowedTools.push(trimmed.substring(2).trim());
        continue;
      } else if (trimmed && !trimmed.startsWith('-')) {
        // End of array, new field started
        inAllowedTools = false;
      }
    }

    // Keep other fields
    if (!inAllowedTools) {
      newLines.push(line);
    }
  }

  // Add tools object if we had allowed-tools or tools
  if (allowedTools.length > 0) {
    newLines.push('tools:');
    for (const tool of allowedTools) {
      const cursorTool = convertCursorToolName(tool);
      if (cursorTool) {
        newLines.push(`  ${cursorTool}: true`);
      }
    }
  }

  // Rebuild frontmatter
  const newFrontmatter = newLines.join('\n').trim();
  return `---\n${newFrontmatter}\n---${body}`;
}
```

Place this after `convertClaudeToGeminiAgent()` function (around line 438).
  </action>
  <verify>
Search for `convertClaudeToCursorFrontmatter` in bin/install.js - should exist.
Run `node -c bin/install.js` to verify syntax.
Test the function manually:
```javascript
// Quick test (run in node REPL after requiring the module functions)
const testContent = `---
name: test
allowed-tools:
  - Read
  - AskUserQuestion
color: yellow
---
Use the Read tool to check files.
Run /gsd:help for more info.
Check ~/.claude/get-shit-done/templates/`;

// Expected output should have:
// - tools: { read: true, ask_question: true }
// - color: "#FFFF00"
// - "read tool" (lowercase)
// - "/gsd-help"
// - "~/.cursor/get-shit-done/templates/"
```
  </verify>
  <done>
- `convertClaudeToCursorFrontmatter()` function exists
- Converts `allowed-tools:` array to `tools:` object with boolean values
- Converts `tools:` comma-separated string to `tools:` object
- Converts color names to hex using existing `colorNameToHex` mapping
- Replaces tool names in body text (Read → read, AskUserQuestion → ask_question, etc.)
- Replaces `/gsd:` → `/gsd-` in content
- Replaces `~/.claude/` → `~/.cursor/` in content
- No syntax errors
  </done>
</task>

</tasks>

<verification>
1. `node -c bin/install.js` passes (no syntax errors)
2. Grep for `claudeToCursorTools` - object exists
3. Grep for `convertCursorToolName` - function exists  
4. Grep for `convertClaudeToCursorFrontmatter` - function exists
5. Functions are placed in correct location (after Gemini conversion functions)
</verification>

<success_criteria>
- [ ] `claudeToCursorTools` mapping object added with 12 tool mappings
- [ ] `convertCursorToolName()` function added with Task exclusion and MCP handling
- [ ] `convertClaudeToCursorFrontmatter()` function added with all 5 conversion requirements
- [ ] `node -c bin/install.js` passes without errors
- [ ] CONV-01 through CONV-05 requirements implemented
- [ ] PATH-03 and PATH-04 requirements implemented (in the conversion function)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-implementation/01-01-SUMMARY.md`
</output>
