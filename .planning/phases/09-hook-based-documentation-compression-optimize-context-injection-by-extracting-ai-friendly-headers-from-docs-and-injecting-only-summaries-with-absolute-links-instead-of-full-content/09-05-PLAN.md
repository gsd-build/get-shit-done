---
phase: 09-hook-based-documentation-compression
plan: 05
type: execute
wave: 4
depends_on: ["09-04"]
files_modified:
  - /Users/ollorin/.claude/get-shit-done/bin/token-monitor.js
  - /Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "TokenBudgetMonitor triggers compression recommendations at 80% utilization"
    - "Existing token_budget.json state is preserved on module load"
    - "Token recommendations integrate bidirectionally with compress commands"
  artifacts:
    - path: "/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js"
      provides: "TokenBudgetMonitor class with reserve/record/report methods"
      exports: ["TokenBudgetMonitor"]
    - path: "/Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js"
      provides: "Token CLI commands"
      exports: ["token init", "token reserve", "token record", "token report", "token reset"]
  key_links:
    - from: "token-monitor.js"
      to: ".planning/token_budget.json"
      via: "JSON file persistence with migration"
      pattern: "fs\\.readFileSync.*token_budget"
    - from: "gsd-tools.js"
      to: "token-monitor.js"
      via: "require('./token-monitor')"
      pattern: "require.*token-monitor"
    - from: "token-monitor.js reserve()"
      to: "gsd-tools.js compress enable"
      via: "80% threshold recommendation"
      pattern: "recommendation.*compress.*enable"
    - from: "gsd-tools.js compress status"
      to: "token-monitor.js"
      via: "token budget triggered compression reporting"
      pattern: "token.*trigger|budget.*enabled"
---

<objective>
Close the gap identified in 09-VERIFICATION.md: Success Criterion 7 requires TokenBudgetMonitor to trigger compression recommendations at 80% utilization.

Purpose: Connect token budget monitoring with compression system to proactively recommend enabling compression when context usage is high.

Output: Working token monitoring with CLI commands and bidirectional compression integration.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-hook-based-documentation-compression-optimize-context-injection-by-extracting-ai-friendly-headers-from-docs-and-injecting-only-summaries-with-absolute-links-instead-of-full-content/09-VERIFICATION.md
@.planning/phases/07-autonomous-execution-optimization/07-RESEARCH.md (Pattern 1: Token Budget Monitoring)
@.planning/phases/09-hook-based-documentation-compression-optimize-context-injection-by-extracting-ai-friendly-headers-from-docs-and-injecting-only-summaries-with-absolute-links-instead-of-full-content/09-04-SUMMARY.md (compress enable/disable/status commands)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TokenBudgetMonitor module with existing state migration</name>
  <files>/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js</files>
  <action>
Create token-monitor.js implementing TokenBudgetMonitor class based on Pattern 1 from 07-RESEARCH.md.

CRITICAL: .planning/token_budget.json already exists with data:
```json
{
  "model": "opus",
  "maxTokens": 200000,
  "currentUsage": 120000,
  "phaseUsage": { "test-phase": 120000 },
  "alerts": [],
  "thresholdsPassed": ["early_warning"],
  "graduatedAlerts": [...],
  "telegramEnabled": false
}
```

The static load() method MUST:
1. Read existing JSON file if present
2. Preserve all existing fields (currentUsage, phaseUsage, graduatedAlerts, etc.)
3. Handle missing fields gracefully with defaults
4. NOT reset or overwrite existing usage data

```javascript
const fs = require('fs');
const path = require('path');

const TOKEN_LIMITS = {
  haiku: 200000,
  sonnet: 200000,
  opus: 200000
};

const ALERT_THRESHOLDS = {
  warn: 0.80,      // 80% - trigger compression recommendation
  critical: 0.90,  // 90% - escalate warnings
  stop: 0.95       // 95% - halt execution
};

class TokenBudgetMonitor {
  constructor(model = 'opus', maxTokens = 200000) {
    this.model = model;
    this.maxTokens = maxTokens;
    this.currentUsage = 0;
    this.phaseUsage = new Map();
    this.alerts = [];
    this.thresholdsPassed = [];
    this.graduatedAlerts = [];
    this.telegramEnabled = false;
  }

  // Reserve tokens before operation, returns { canProceed, utilization, recommendation }
  reserve(estimatedTokens, operation) {
    const projectedUsage = this.currentUsage + estimatedTokens;
    const utilization = projectedUsage / this.maxTokens;

    let recommendation = null;
    let canProceed = true;

    // At 80% utilization: recommend compression
    if (utilization >= ALERT_THRESHOLDS.warn) {
      recommendation = 'Token budget at ' + Math.round(utilization * 100) + '%. Consider enabling compression: `node /Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js compress enable`';
    }

    // At 95%: block execution
    if (utilization >= ALERT_THRESHOLDS.stop) {
      canProceed = false;
    }

    return { canProceed, utilization, recommendation, operation, projectedTokens: projectedUsage };
  }

  // Record actual token usage after operation
  recordUsage(actualTokens, phase) {
    this.currentUsage += actualTokens;
    const existing = this.phaseUsage.get(phase) || 0;
    this.phaseUsage.set(phase, existing + actualTokens);

    // Check for graduated alerts
    const utilization = this.currentUsage / this.maxTokens;
    this._checkGraduatedAlerts(utilization, phase);

    return { recorded: actualTokens, phase, newUtilization: utilization };
  }

  _checkGraduatedAlerts(utilization, phase) {
    const levels = [
      { threshold: 0.50, level: 'INFO', action: 'Log warning' },
      { threshold: 0.65, level: 'INFO', action: 'Monitor closely' },
      { threshold: 0.80, level: 'WARN', action: 'Enable compression' },
      { threshold: 0.90, level: 'ERROR', action: 'Prepare to halt' },
      { threshold: 0.95, level: 'CRITICAL', action: 'Stop execution' }
    ];

    for (const alert of levels) {
      const key = Math.round(alert.threshold * 100) + '%';
      if (utilization >= alert.threshold && !this.thresholdsPassed.includes(key)) {
        this.thresholdsPassed.push(key);
        this.graduatedAlerts.push({
          level: alert.level,
          threshold: key,
          action: alert.action,
          utilization: (utilization * 100).toFixed(1) + '%',
          tokens_used: this.currentUsage,
          tokens_remaining: this.maxTokens - this.currentUsage,
          phase,
          timestamp: new Date().toISOString()
        });
      }
    }
  }

  // Get usage report
  getReport() {
    const utilization = this.currentUsage / this.maxTokens;
    const phaseBreakdown = {};
    for (const [phase, tokens] of this.phaseUsage) {
      phaseBreakdown[phase] = tokens;
    }

    return {
      model: this.model,
      current_usage: this.currentUsage,
      max_tokens: this.maxTokens,
      utilization_percent: (utilization * 100).toFixed(1) + '%',
      remaining_tokens: this.maxTokens - this.currentUsage,
      phase_breakdown: phaseBreakdown,
      active_alerts: this.graduatedAlerts.filter(a => a.level !== 'INFO'),
      thresholds_passed: this.thresholdsPassed
    };
  }

  // Persist to JSON
  toJSON() {
    const phaseUsage = {};
    for (const [k, v] of this.phaseUsage) {
      phaseUsage[k] = v;
    }
    return {
      model: this.model,
      maxTokens: this.maxTokens,
      currentUsage: this.currentUsage,
      phaseUsage,
      alerts: this.alerts,
      thresholdsPassed: this.thresholdsPassed,
      graduatedAlerts: this.graduatedAlerts,
      telegramEnabled: this.telegramEnabled
    };
  }

  static fromJSON(data) {
    const monitor = new TokenBudgetMonitor(data.model || 'opus', data.maxTokens || 200000);
    // CRITICAL: Preserve existing state
    monitor.currentUsage = data.currentUsage || 0;
    monitor.alerts = data.alerts || [];
    monitor.thresholdsPassed = data.thresholdsPassed || [];
    monitor.graduatedAlerts = data.graduatedAlerts || [];
    monitor.telegramEnabled = data.telegramEnabled || false;

    // Convert phaseUsage object to Map
    if (data.phaseUsage) {
      for (const [k, v] of Object.entries(data.phaseUsage)) {
        monitor.phaseUsage.set(k, v);
      }
    }
    return monitor;
  }

  save(projectPath) {
    const filePath = path.join(projectPath, '.planning', 'token_budget.json');
    fs.writeFileSync(filePath, JSON.stringify(this.toJSON(), null, 2));
    return filePath;
  }

  static load(projectPath, model = 'opus') {
    const filePath = path.join(projectPath, '.planning', 'token_budget.json');
    try {
      if (fs.existsSync(filePath)) {
        const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
        // Preserve existing state - do NOT reset
        return TokenBudgetMonitor.fromJSON(data);
      }
    } catch (e) {
      // File missing or corrupt - create new
    }
    return new TokenBudgetMonitor(model, TOKEN_LIMITS[model] || 200000);
  }

  static selfTest() {
    // See Task 3 for implementation
  }
}

module.exports = { TokenBudgetMonitor, TOKEN_LIMITS, ALERT_THRESHOLDS };
```

Key requirements:
1. At 80% utilization in reserve(), include recommendation with exact compress enable command
2. Preserve existing .planning/token_budget.json data on load()
3. Track per-phase usage in phaseUsage Map
4. Support graduated alerts (50%, 65%, 80%, 90%, 95%)
5. Export TokenBudgetMonitor class
  </action>
  <verify>
```bash
# Verify module loads
node -e "const { TokenBudgetMonitor } = require('/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js'); console.log('TokenBudgetMonitor loaded:', typeof TokenBudgetMonitor)"

# Verify existing state is preserved on load
cd /Users/ollorin/get-shit-done
node -e "
const { TokenBudgetMonitor } = require('/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js');
const monitor = TokenBudgetMonitor.load('.');
console.log('Loaded currentUsage:', monitor.currentUsage);
console.log('Loaded phaseUsage:', Object.fromEntries(monitor.phaseUsage));
if (monitor.currentUsage === 0) {
  console.error('ERROR: Existing state was reset instead of preserved');
  process.exit(1);
}
console.log('SUCCESS: Existing token_budget.json state preserved');
"

# Verify 80% threshold recommendation
node -e "
const { TokenBudgetMonitor } = require('/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js');
const monitor = new TokenBudgetMonitor('opus', 200000);
monitor.currentUsage = 150000; // 75%
const result = monitor.reserve(12000, 'test'); // Would push to 81%
console.log('At 81% utilization, recommendation:', result.recommendation);
if (!result.recommendation || !result.recommendation.includes('compress enable')) {
  console.error('ERROR: Missing compression recommendation at 80%+');
  process.exit(1);
}
console.log('SUCCESS: 80% threshold triggers compression recommendation');
"
```
  </verify>
  <done>TokenBudgetMonitor class exists with reserve() method that recommends compression at 80% utilization, preserving existing token_budget.json state</done>
</task>

<task type="auto">
  <name>Task 2: Add token CLI commands to gsd-tools.js</name>
  <files>/Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add 'token' case to the main switch statement in gsd-tools.js with these subcommands:

1. `token init <model>` - Initialize token budget for model (opus|sonnet|haiku)
   - Creates new TokenBudgetMonitor with model's limit
   - Saves to .planning/token_budget.json
   - Output: { initialized: true, model, maxTokens }

2. `token reserve <tokens> <operation>` - Check if operation can proceed
   - Loads existing budget, calls reserve()
   - Exit code 0 if can proceed, 1 if blocked
   - Output: { canProceed, utilization, recommendation, operation }
   - CRITICAL: At 80%+, output MUST include recommendation field

3. `token record <tokens> <phase>` - Record actual usage
   - Loads budget, calls recordUsage(), saves
   - Output: { recorded, phase, newUtilization }

4. `token report` - Display current budget status
   - Loads budget, calls getReport()
   - Output: { current_usage, max_tokens, utilization_percent, remaining_tokens, phase_breakdown, active_alerts }

5. `token reset` - Reset budget for new session
   - Creates fresh TokenBudgetMonitor, saves
   - Output: { reset: true, model }

Add require at top of file:
```javascript
const { TokenBudgetMonitor } = require('./token-monitor');
```

Add case in switch statement (near other CLI commands like 'compress'):
```javascript
case 'token': {
  const subcommand = args[1];
  const cwd = process.cwd();

  switch (subcommand) {
    case 'init': {
      const model = args[2] || 'opus';
      const monitor = new TokenBudgetMonitor(model);
      monitor.save(cwd);
      console.log(JSON.stringify({ initialized: true, model, maxTokens: monitor.maxTokens }));
      break;
    }
    case 'reserve': {
      const tokens = parseInt(args[2], 10) || 0;
      const operation = args[3] || 'unknown';
      const monitor = TokenBudgetMonitor.load(cwd);
      const result = monitor.reserve(tokens, operation);
      console.log(JSON.stringify(result));
      process.exit(result.canProceed ? 0 : 1);
      break;
    }
    case 'record': {
      const tokens = parseInt(args[2], 10) || 0;
      const phase = args[3] || 'unknown';
      const monitor = TokenBudgetMonitor.load(cwd);
      const result = monitor.recordUsage(tokens, phase);
      monitor.save(cwd);
      console.log(JSON.stringify(result));
      break;
    }
    case 'report': {
      const monitor = TokenBudgetMonitor.load(cwd);
      console.log(JSON.stringify(monitor.getReport(), null, 2));
      break;
    }
    case 'reset': {
      const model = args[2] || 'opus';
      const monitor = new TokenBudgetMonitor(model);
      monitor.save(cwd);
      console.log(JSON.stringify({ reset: true, model }));
      break;
    }
    default:
      console.error(JSON.stringify({ error: 'Unknown token subcommand. Use: init, reserve, record, report, reset' }));
      process.exit(1);
  }
  break;
}
```

Update error message for unknown commands to include 'token' in available commands list.
  </action>
  <verify>
```bash
# Test each command
cd /Users/ollorin/get-shit-done

# Test report (uses existing data)
node /Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js token report

# Test reserve at current utilization
node /Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js token reserve 10000 test-op

# Test reserve at high utilization
node -e "
const fs = require('fs');
const budget = JSON.parse(fs.readFileSync('.planning/token_budget.json', 'utf-8'));
const savedUsage = budget.currentUsage;
budget.currentUsage = 165000; // 82.5%
fs.writeFileSync('.planning/token_budget.json', JSON.stringify(budget, null, 2));
"
RESULT=$(node /Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js token reserve 1000 test-op)
echo "$RESULT"
echo "$RESULT" | grep -q 'compress enable' && echo "SUCCESS: Recommendation includes compress enable" || echo "ERROR: Missing compress enable in recommendation"

# Restore original state
node -e "
const fs = require('fs');
const budget = JSON.parse(fs.readFileSync('.planning/token_budget.json', 'utf-8'));
budget.currentUsage = 120000;
fs.writeFileSync('.planning/token_budget.json', JSON.stringify(budget, null, 2));
"
```
  </verify>
  <done>Token CLI commands (init, reserve, record, report, reset) work via gsd-tools.js with compression recommendation at 80%</done>
</task>

<task type="auto">
  <name>Task 3: Add selfTest() method with threshold verification</name>
  <files>/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js</files>
  <action>
Add selfTest() static method to TokenBudgetMonitor class that verifies threshold behavior:

```javascript
static selfTest() {
  const results = [];

  // Test 1: Below threshold - no recommendation
  const monitor1 = new TokenBudgetMonitor('opus', 200000);
  monitor1.currentUsage = 150000; // 75%
  const below = monitor1.reserve(1000, 'test1'); // 75.5%
  results.push({
    test: 'Below 80% threshold',
    passed: !below.recommendation,
    utilization: below.utilization,
    recommendation: below.recommendation
  });

  // Test 2: At 80% - must recommend compression
  const monitor2 = new TokenBudgetMonitor('opus', 200000);
  monitor2.currentUsage = 159000; // 79.5%
  const at80 = monitor2.reserve(2000, 'test2'); // Would push to 80.5%
  results.push({
    test: 'At 80% threshold',
    passed: at80.recommendation && at80.recommendation.includes('compress'),
    utilization: at80.utilization,
    recommendation: at80.recommendation
  });

  // Test 3: Verify exact command in recommendation
  results.push({
    test: 'Recommendation includes compress enable command',
    passed: at80.recommendation && at80.recommendation.includes('compress enable'),
    recommendation: at80.recommendation
  });

  // Test 4: State preservation (simulate load/save cycle)
  const monitor3 = new TokenBudgetMonitor('opus', 200000);
  monitor3.currentUsage = 50000;
  monitor3.phaseUsage.set('test-phase', 50000);
  const json = monitor3.toJSON();
  const restored = TokenBudgetMonitor.fromJSON(json);
  results.push({
    test: 'State preserved through JSON cycle',
    passed: restored.currentUsage === 50000 && restored.phaseUsage.get('test-phase') === 50000,
    currentUsage: restored.currentUsage,
    phaseUsage: Object.fromEntries(restored.phaseUsage)
  });

  const allPassed = results.every(r => r.passed);
  return {
    passed: allPassed,
    tests: results.length,
    results,
    error: allPassed ? null : results.find(r => !r.passed)?.test
  };
}
```

Export selfTest in module.exports.
  </action>
  <verify>
```bash
# Run self-test
node -e "
const { TokenBudgetMonitor } = require('/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js');
const result = TokenBudgetMonitor.selfTest();
console.log(JSON.stringify(result, null, 2));
if (!result.passed) {
  console.error('SELF-TEST FAILED:', result.error);
  process.exit(1);
}
console.log('SUCCESS: All threshold tests passed');
"
```
  </verify>
  <done>selfTest() method validates 80% threshold behavior and state preservation</done>
</task>

<task type="auto">
  <name>Task 4: Bidirectional integration verification with compress commands</name>
  <files>/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js</files>
  <action>
Add integrationTest() static method that verifies end-to-end integration with compress commands from 09-04:

```javascript
static integrationTest(projectPath = '.') {
  const fs = require('fs');
  const { execSync } = require('child_process');
  const gsdTools = '/Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js';

  const results = [];

  // Test 1: reserve() at 80%+ returns recommendation with compress command
  const monitor = new TokenBudgetMonitor('opus', 200000);
  monitor.currentUsage = 165000; // 82.5%
  const reserveResult = monitor.reserve(1000, 'integration-test');

  results.push({
    test: 'reserve() returns compress command at 80%',
    passed: reserveResult.recommendation && reserveResult.recommendation.includes('gsd-tools.js compress enable'),
    recommendation: reserveResult.recommendation
  });

  // Test 2: Recommended command is executable (compress enable exists)
  try {
    const statusBefore = execSync(`node ${gsdTools} compress status`, {
      cwd: projectPath,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
    results.push({
      test: 'compress status command exists',
      passed: true,
      output: statusBefore.trim().slice(0, 100)
    });
  } catch (e) {
    results.push({
      test: 'compress status command exists',
      passed: false,
      error: e.message
    });
  }

  // Test 3: Can execute compress enable (the recommended action)
  try {
    const enableResult = execSync(`node ${gsdTools} compress enable`, {
      cwd: projectPath,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
    const parsed = JSON.parse(enableResult);
    results.push({
      test: 'compress enable executes successfully',
      passed: parsed.enabled === true || parsed.compression_enabled === true,
      output: parsed
    });
  } catch (e) {
    results.push({
      test: 'compress enable executes successfully',
      passed: false,
      error: e.message
    });
  }

  // Test 4: After enabling, status reflects compression is on
  try {
    const statusAfter = execSync(`node ${gsdTools} compress status`, {
      cwd: projectPath,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
    const parsed = JSON.parse(statusAfter);
    results.push({
      test: 'compress status shows enabled after enable',
      passed: parsed.enabled === true || parsed.compression_enabled === true,
      status: parsed
    });
  } catch (e) {
    results.push({
      test: 'compress status shows enabled after enable',
      passed: false,
      error: e.message
    });
  }

  // Test 5: Disable compression to restore state
  try {
    execSync(`node ${gsdTools} compress disable`, {
      cwd: projectPath,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
    results.push({
      test: 'compress disable restores state',
      passed: true
    });
  } catch (e) {
    results.push({
      test: 'compress disable restores state',
      passed: false,
      error: e.message
    });
  }

  const allPassed = results.every(r => r.passed);
  return {
    passed: allPassed,
    tests: results.length,
    results,
    summary: allPassed
      ? 'Token budget and compression systems integrate correctly'
      : 'Integration issues detected - see results'
  };
}
```

Export integrationTest in module.exports.

This test proves the bidirectional integration:
1. TokenBudgetMonitor reserve() at 80% -> recommendation includes compress enable command
2. The recommended compress enable command -> actually executes and enables compression
3. compress status -> reflects that compression is now enabled
4. The full loop works: token pressure -> recommendation -> action -> state change
  </action>
  <verify>
```bash
cd /Users/ollorin/get-shit-done

# Run integration test
node -e "
const { TokenBudgetMonitor } = require('/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js');
const result = TokenBudgetMonitor.integrationTest('.');
console.log(JSON.stringify(result, null, 2));
if (!result.passed) {
  console.error('INTEGRATION TEST FAILED');
  result.results.filter(r => !r.passed).forEach(r => console.error('  -', r.test, ':', r.error || 'failed'));
  process.exit(1);
}
console.log('SUCCESS: Bidirectional integration verified');
"

# Verify the gap is closed - exact criterion from VERIFICATION.md
node -e "
const { TokenBudgetMonitor } = require('/Users/ollorin/.claude/get-shit-done/bin/token-monitor.js');
const monitor = new TokenBudgetMonitor('opus', 200000);
monitor.currentUsage = 160000; // 80%
const result = monitor.reserve(1, 'gap-test');
if (result.recommendation && result.recommendation.includes('compress')) {
  console.log('GAP CLOSED: TokenBudgetMonitor triggers compression recommendations at 80% utilization');
  console.log('Recommendation:', result.recommendation);
} else {
  console.error('GAP NOT CLOSED: Missing compression recommendation');
  process.exit(1);
}
"
```
  </verify>
  <done>Integration test proves end-to-end: token budget at 80% -> recommend compress enable -> execute compress enable -> compression becomes enabled</done>
</task>

</tasks>

<verification>
Gap closure verified when:
1. token-monitor.js exists and exports TokenBudgetMonitor
2. Existing token_budget.json state is preserved on load (not reset)
3. gsd-tools.js has working token commands (init, reserve, record, report, reset)
4. At 80% utilization, reserve() includes recommendation to enable compression
5. Recommendation text includes exact "gsd-tools.js compress enable" command
6. selfTest() passes confirming threshold behavior
7. integrationTest() passes confirming bidirectional integration with compress commands

Re-run verification:
```bash
node /Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js verify plan-structure .planning/phases/09-*/09-05-PLAN.md
```
</verification>

<success_criteria>
- [ ] TokenBudgetMonitor class implemented with 80/90/95% thresholds
- [ ] Existing token_budget.json state preserved on load
- [ ] reserve() method returns recommendation at 80%+ utilization
- [ ] Token CLI commands work in gsd-tools.js
- [ ] Recommendation message includes exact compress enable command path
- [ ] selfTest() validates threshold behavior
- [ ] integrationTest() validates bidirectional integration
- [ ] Success criterion 7 from 09-VERIFICATION.md satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/09-hook-based-documentation-compression-optimize-context-injection-by-extracting-ai-friendly-headers-from-docs-and-injecting-only-summaries-with-absolute-links-instead-of-full-content/09-05-SUMMARY.md`
</output>
