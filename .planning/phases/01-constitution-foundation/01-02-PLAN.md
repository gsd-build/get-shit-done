---
phase: 01-constitution-foundation
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
checkpoint: after_each_task
files_modified:
  - package.json
  - src/constitution/loader.js
  - src/constitution/__tests__/loader.test.js
autonomous: true

must_haves:
  truths:
    - "Tests written BEFORE loader implementation"
    - "Loader merges global + project rules correctly"
    - "Version conflicts detected (major mismatch throws)"
    - "Duplicate rule IDs prevented after merge"
    - "100% test coverage on loader code"
  artifacts:
    - path: "src/constitution/__tests__/loader.test.js"
      provides: "Loader tests with mock-fs"
      contains: "describe('ConstitutionLoader'"
      min_lines: 150
    - path: "src/constitution/loader.js"
      provides: "ConstitutionLoader class"
      exports: ["ConstitutionLoader"]
      min_lines: 100
  key_links:
    - from: "src/constitution/__tests__/loader.test.js"
      to: "src/constitution/loader.js"
      via: "require"
      pattern: "require.*loader"
---

<objective>
Implement constitution loader using strict TDD. Tests define ALL behavior before implementation.

Purpose: Core loading/merging module. TDD catches edge cases (YAML coercion, version comparison, duplicate IDs).
Output: 100% covered loader in repo source.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md

**TDD-FIRST (MANDATORY):**
1. RED: Write ALL tests first (5 categories below)
2. GREEN: Implement minimal code to pass
3. REFACTOR: Clean up if needed

**Test Categories (from RESEARCH.md):**
1. Parsing tests - YAML frontmatter, markdown sections, rule extraction
2. Validation tests - Version format, required fields
3. Merging tests - Global + project, array replacement
4. Error handling - Missing files, parse errors, version conflicts
5. Edge cases - Empty files, malformed YAML, duplicate IDs
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-constitution-foundation/01-RESEARCH.md
@.planning/phases/01-constitution-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies + write ALL tests (RED)</name>
  <files>
    package.json
    src/constitution/__tests__/loader.test.js
  </files>
  <action>
```bash
npm install gray-matter semver deepmerge
npm install --save-dev jest mock-fs
```

Write comprehensive test suite BEFORE any implementation:

```javascript
// src/constitution/__tests__/loader.test.js
const mock = require('mock-fs');
const path = require('path');

// Will fail until loader exists
const ConstitutionLoader = require('../loader');

const HOME = '/Users/testuser';
const GLOBAL_PATH = `${HOME}/.claude/get-shit-done/CONSTITUTION.md`;
const PROJECT_PATH = '/project/.planning/CONSTITUTION.md';

describe('ConstitutionLoader', () => {
  afterEach(() => mock.restore());

  // 1. PARSING TESTS
  describe('Parsing', () => {
    test('extracts version from YAML frontmatter', () => {
      mock({ [GLOBAL_PATH]: '---\nversion: "1.0.0"\n---\n# NON-NEGOTIABLE' });
      const loader = new ConstitutionLoader();
      expect(loader.load().version).toBe('1.0.0');
    });

    test('extracts rules by severity section', () => {
      mock({ [GLOBAL_PATH]: `---
version: "1.0.0"
---
# NON-NEGOTIABLE
### TDD-01: Test first
# ERROR
### SEC-03: Validate input
# WARNING
### SEC-06: Update deps` });
      const loader = new ConstitutionLoader();
      const config = loader.load();
      expect(config.rules['NON-NEGOTIABLE']).toHaveLength(1);
      expect(config.rules['ERROR']).toHaveLength(1);
      expect(config.rules['WARNING']).toHaveLength(1);
    });

    test('version remains string not number (YAML coercion)', () => {
      mock({ [GLOBAL_PATH]: '---\nversion: "1.0"\n---\n# NON-NEGOTIABLE' });
      const loader = new ConstitutionLoader();
      expect(typeof loader.load().version).toBe('string');
    });
  });

  // 2. VALIDATION TESTS
  describe('Validation', () => {
    test('throws when version missing', () => {
      mock({ [GLOBAL_PATH]: '---\nlastUpdated: "2026-01-19"\n---' });
      const loader = new ConstitutionLoader();
      expect(() => loader.load()).toThrow(/missing.*version/i);
    });

    test('throws when version invalid semver', () => {
      mock({ [GLOBAL_PATH]: '---\nversion: "not-valid"\n---' });
      const loader = new ConstitutionLoader();
      expect(() => loader.load()).toThrow(/invalid.*semver/i);
    });
  });

  // 3. MERGING TESTS
  describe('Merging', () => {
    test('merges global and project rules', () => {
      mock({
        [GLOBAL_PATH]: `---\nversion: "1.0.0"\n---\n# NON-NEGOTIABLE\n### TDD-01: Test first`,
        [PROJECT_PATH]: `---\nversion: "1.0.0"\n---\n# ERROR\n### PROJ-01: Custom rule`
      });
      const loader = new ConstitutionLoader();
      const config = loader.load();
      expect(config.rules['NON-NEGOTIABLE']).toHaveLength(1);
      expect(config.rules['ERROR']).toHaveLength(1);
    });

    test('project arrays replace global arrays (not concat)', () => {
      mock({
        [GLOBAL_PATH]: `---\nversion: "1.0.0"\n---\n# ERROR\n### SEC-03: Global`,
        [PROJECT_PATH]: `---\nversion: "1.0.0"\n---\n# ERROR\n### PROJ-01: Project`
      });
      const loader = new ConstitutionLoader();
      const config = loader.load();
      // Should have project rule only, not both
      expect(config.rules['ERROR']).toHaveLength(1);
      expect(config.rules['ERROR'][0].id).toBe('PROJ-01');
    });
  });

  // 4. ERROR HANDLING TESTS
  describe('Error Handling', () => {
    test('throws when no constitution files exist', () => {
      mock({});
      const loader = new ConstitutionLoader();
      expect(() => loader.load()).toThrow(/no constitution/i);
    });

    test('throws on major version mismatch', () => {
      mock({
        [GLOBAL_PATH]: '---\nversion: "2.0.0"\n---',
        [PROJECT_PATH]: '---\nversion: "1.0.0"\n---'
      });
      const loader = new ConstitutionLoader();
      expect(() => loader.load()).toThrow(/version mismatch/i);
    });

    test('loads global only when project missing', () => {
      mock({ [GLOBAL_PATH]: '---\nversion: "1.0.0"\n---\n# NON-NEGOTIABLE' });
      const loader = new ConstitutionLoader();
      expect(() => loader.load()).not.toThrow();
    });
  });

  // 5. EDGE CASE TESTS
  describe('Edge Cases', () => {
    test('throws on duplicate rule IDs after merge', () => {
      mock({
        [GLOBAL_PATH]: `---\nversion: "1.0.0"\n---\n# NON-NEGOTIABLE\n### TDD-01: Test`,
        [PROJECT_PATH]: `---\nversion: "1.0.0"\n---\n# NON-NEGOTIABLE\n### TDD-01: Override`
      });
      const loader = new ConstitutionLoader();
      expect(() => loader.load()).toThrow(/duplicate.*TDD-01/i);
    });

    test('handles empty severity sections', () => {
      mock({ [GLOBAL_PATH]: '---\nversion: "1.0.0"\n---\n# NON-NEGOTIABLE\n# ERROR\n# WARNING' });
      const loader = new ConstitutionLoader();
      const config = loader.load();
      expect(config.rules['NON-NEGOTIABLE']).toEqual([]);
    });

    test('allows same minor version', () => {
      mock({
        [GLOBAL_PATH]: '---\nversion: "1.5.0"\n---',
        [PROJECT_PATH]: '---\nversion: "1.2.0"\n---'
      });
      const loader = new ConstitutionLoader();
      expect(() => loader.load()).not.toThrow();
    });
  });
});
```

mkdir -p src/constitution/__tests__
  </action>
  <verify>
`npm test -- loader.test.js` runs and ALL tests FAIL (RED phase).
Dependencies installed in package.json.
  </verify>
  <done>
All tests written. Tests FAIL because loader doesn't exist.
RED phase complete for all 5 categories.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement loader to pass tests (GREEN)</name>
  <files>src/constitution/loader.js</files>
  <action>
Implement ConstitutionLoader class that passes ALL tests.

Key implementation points:
- Use gray-matter for YAML parsing
- Use semver for version comparison
- Use deepmerge with arrayMerge: replace strategy
- Use path.join + os.homedir for cross-platform paths
- Validate rule ID uniqueness with Set

```javascript
// src/constitution/loader.js
const fs = require('fs');
const path = require('path');
const os = require('os');
const matter = require('gray-matter');
const semver = require('semver');
const deepmerge = require('deepmerge');

class ConstitutionLoader {
  constructor() {
    this.globalPath = path.join(os.homedir(), '.claude', 'get-shit-done', 'CONSTITUTION.md');
    this.projectPath = path.join(process.cwd(), '.planning', 'CONSTITUTION.md');
  }

  load() {
    const globalContent = this._readFile(this.globalPath);
    const projectContent = this._readFile(this.projectPath);

    if (!globalContent && !projectContent) {
      throw new Error('No constitution files found');
    }

    const globalConfig = globalContent ? this._parse(globalContent) : null;
    const projectConfig = projectContent ? this._parse(projectContent) : null;

    if (globalConfig && projectConfig) {
      this._checkVersions(globalConfig.version, projectConfig.version);
    }

    const merged = this._merge(globalConfig, projectConfig);
    this._validateRuleIds(merged);

    return merged;
  }

  _readFile(filepath) {
    return fs.existsSync(filepath) ? fs.readFileSync(filepath, 'utf8') : null;
  }

  _parse(content) {
    const { data, content: markdown } = matter(content);

    if (!data.version) throw new Error('Constitution missing required field: version');
    if (!semver.valid(data.version)) throw new Error(`Invalid semver format: ${data.version}`);

    return {
      version: data.version,
      lastUpdated: data.lastUpdated,
      rules: {
        'NON-NEGOTIABLE': this._extractRules(markdown, 'NON-NEGOTIABLE'),
        'ERROR': this._extractRules(markdown, 'ERROR'),
        'WARNING': this._extractRules(markdown, 'WARNING')
      }
    };
  }

  _extractRules(markdown, severity) {
    const pattern = new RegExp(`# ${severity}([\\s\\S]*?)(?=# [A-Z]|$)`);
    const match = markdown.match(pattern);
    if (!match) return [];

    const rules = [];
    const rulePattern = /^### ([A-Z]+-\d+):\s*(.+)$/gm;
    let m;
    while ((m = rulePattern.exec(match[1])) !== null) {
      rules.push({ id: m[1], description: m[2], severity });
    }
    return rules;
  }

  _checkVersions(global, project) {
    if (semver.major(global) !== semver.major(project)) {
      throw new Error(`Constitution major version mismatch: global ${global}, project ${project}`);
    }
  }

  _merge(global, project) {
    if (!global) return project;
    if (!project) return global;
    return deepmerge(global, project, { arrayMerge: (t, s) => s, clone: true });
  }

  _validateRuleIds(config) {
    const seen = new Set();
    for (const sev of ['NON-NEGOTIABLE', 'ERROR', 'WARNING']) {
      for (const rule of config.rules[sev]) {
        if (seen.has(rule.id)) throw new Error(`Duplicate rule ID: ${rule.id}`);
        seen.add(rule.id);
      }
    }
  }
}

module.exports = { ConstitutionLoader };
```
  </action>
  <verify>
`npm test -- loader.test.js` ALL tests PASS (GREEN phase).
`npm test -- --coverage` shows 100% on loader.js.
  </verify>
  <done>
Loader implemented. All tests pass. 100% coverage.
GREEN phase complete.
  </done>
</task>

</tasks>

<verification>
- `npm test -- loader.test.js` passes all tests
- `npm test -- --coverage` shows 100% statements/branches/functions/lines
- Loader handles: parsing, validation, merging, errors, edge cases
</verification>

<success_criteria>
- [ ] Tests written FIRST covering all 5 categories (RED)
- [ ] ALL tests FAIL before implementation
- [ ] Loader passes all tests (GREEN)
- [ ] 100% test coverage
- [ ] gray-matter, semver, deepmerge, mock-fs installed
- [ ] Loader uses path.join (cross-platform)
</success_criteria>

<output>
Create `.planning/phases/01-constitution-foundation/01-02-SUMMARY.md`
Update `.planning/STATE.md` with task progress
</output>
