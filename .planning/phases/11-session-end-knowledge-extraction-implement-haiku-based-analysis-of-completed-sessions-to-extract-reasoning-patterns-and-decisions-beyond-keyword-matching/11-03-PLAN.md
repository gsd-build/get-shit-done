---
phase: 11-session-end-knowledge-extraction
plan: 03
type: execute
wave: 3
depends_on: ["11-01", "11-02"]
files_modified:
  - get-shit-done/bin/knowledge-writer.js
  - mcp-servers/telegram-mcp/src/index.ts
  - mcp-servers/telegram-mcp/src/storage/session-manager.ts
  - mcp-servers/telegram-mcp/src/bot/telegram-bot.ts
autonomous: true

must_haves:
  truths:
    - "Haiku-extracted insights are stored in Phase 3 knowledge database via CRUD with three-stage deduplication"
    - "Analysis runs BEFORE session close (not after) per locked user decision #6"
    - "Knowledge database auto-creates on first use if it does not exist per locked user decision #5"
    - "Conversation end is detected via explicit done command, /end, or 10-minute timeout"
    - "MCP server SIGINT/SIGTERM triggers analysis-then-close sequence"
  artifacts:
    - path: "get-shit-done/bin/knowledge-writer.js"
      provides: "Stores Haiku insights in Phase 3 knowledge DB with dedup and auto-init"
      contains: "storeInsights"
    - path: "mcp-servers/telegram-mcp/src/index.ts"
      provides: "Session-end analysis hook in SIGINT/SIGTERM handlers using closeSessionWithAnalysis"
      contains: "closeSessionWithAnalysis"
    - path: "mcp-servers/telegram-mcp/src/storage/session-manager.ts"
      provides: "closeSessionWithAnalysis function"
      contains: "closeSessionWithAnalysis"
    - path: "mcp-servers/telegram-mcp/src/bot/telegram-bot.ts"
      provides: "Conversation end detection via done/end commands and 10-minute inactivity timeout"
      contains: "closeSessionWithAnalysis"
  key_links:
    - from: "get-shit-done/bin/knowledge-writer.js"
      to: "get-shit-done/bin/knowledge-crud.js"
      via: "insertKnowledge for storing extracted insights"
      pattern: "insertKnowledge"
    - from: "get-shit-done/bin/knowledge-writer.js"
      to: "get-shit-done/bin/knowledge-dedup.js"
      via: "checkDuplicate before insertion"
      pattern: "checkDuplicate"
    - from: "mcp-servers/telegram-mcp/src/index.ts"
      to: "get-shit-done/bin/session-analyzer.js"
      via: "require for session analysis at shutdown"
      pattern: "session-analyzer"
---

<objective>
Wire the session analyzer to the Phase 3 knowledge system for persistent storage and integrate analysis into the MCP server shutdown lifecycle so sessions are analyzed BEFORE being closed.

Purpose: This is the integration plan that connects extraction (Plan 01) with storage (Phase 3) and triggers it at the right time (session end). Per locked decision #6, analysis must happen before session close to prevent data loss on crash.

Output: knowledge-writer.js (insight storage with dedup), updated index.ts (session-end hook), updated session-manager.ts (closeSessionWithAnalysis)
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-session-end-knowledge-extraction-implement-haiku-based-analysis-of-completed-sessions-to-extract-reasoning-patterns-and-decisions-beyond-keyword-matching/11-CONTEXT.md
@.planning/phases/11-session-end-knowledge-extraction-implement-haiku-based-analysis-of-completed-sessions-to-extract-reasoning-patterns-and-decisions-beyond-keyword-matching/11-01-SUMMARY.md
@.planning/phases/11-session-end-knowledge-extraction-implement-haiku-based-analysis-of-completed-sessions-to-extract-reasoning-patterns-and-decisions-beyond-keyword-matching/11-02-SUMMARY.md
@get-shit-done/bin/knowledge.js
@get-shit-done/bin/knowledge-crud.js
@get-shit-done/bin/knowledge-dedup.js
@get-shit-done/bin/knowledge-db.js
@get-shit-done/bin/session-analyzer.js
@get-shit-done/bin/session-quality-gates.js
@get-shit-done/bin/session-chunker.js
@mcp-servers/telegram-mcp/src/index.ts
@mcp-servers/telegram-mcp/src/storage/session-manager.ts
@mcp-servers/telegram-mcp/src/bot/telegram-bot.ts
@mcp-servers/telegram-mcp/src/storage/session-state.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create knowledge writer with deduplication and auto-init</name>
  <files>
    get-shit-done/bin/knowledge-writer.js
  </files>
  <action>
Create knowledge-writer.js (CommonJS) that bridges Haiku-extracted insights to the Phase 3 knowledge database:

**`storeInsights(insights, options)`** where insights is array of parsed Haiku output objects and options = `{sessionId, conversationId, scope: 'project'}`:

1. **Auto-initialize database** per locked decision #5: Use knowledge.js facade `getConnection(scope)`. If not available, attempt to create DB directory and open connection. If knowledge-db.js `openKnowledgeDB(scope)` is available, call it. If dependencies missing (better-sqlite3, sqlite-vec), log warning and return `{stored: 0, skipped: 0, errors: ['Knowledge DB unavailable']}`.

2. **Map insight types to knowledge types:**
   - `decision` -> knowledge type `decision`, TTL `long_term` (90 days)
   - `reasoning_pattern` -> knowledge type `lesson`, TTL `permanent`
   - `meta_knowledge` with category `preference` or `principle` -> knowledge type `lesson`, TTL `permanent`
   - `meta_knowledge` with category `constraint` -> knowledge type `decision`, TTL `long_term`
   - `meta_knowledge` with category `learning_pattern` -> knowledge type `summary`, TTL `short_term` (7 days)

3. **Deduplicate before insertion** using Phase 4 three-stage dedup (knowledge-dedup.js):
   - Call `checkDuplicate(db, content)` which checks content hash, canonical hash, then embedding similarity
   - If duplicate found (similarity > 0.88): skip, increment skipped counter
   - If near-duplicate (0.65-0.88): use knowledge-evolution.js `insertOrEvolve()` to update existing entry
   - If novel (< 0.65): insert via knowledge-crud.js `insertKnowledge()`

4. **Build knowledge entry** for insertion:
   - `content`: insight.decision or insight.description or insight.statement (depending on type)
   - `context`: JSON.stringify of {session_id, conversation_id, confidence, context_snippet, source: 'haiku-extraction'}
   - `scope`: options.scope (default 'project')
   - `type`: mapped type from step 2
   - `ttlCategory`: mapped TTL from step 2
   - Tags: `['haiku-extracted', insight.type]`

5. **Return summary:** `{stored: number, skipped: number, evolved: number, errors: string[]}`

**`ensureKnowledgeDB(scope)`** - Helper that ensures DB exists:
- Check if `.planning/knowledge/` directory exists, create if not
- Try `openKnowledgeDB(scope)`, which handles schema creation
- Return `{available: boolean, reason?: string}`

Handle all errors gracefully. Log to stderr. Never throw - always return error in result object.
  </action>
  <verify>
    node -e "const w = require('./get-shit-done/bin/knowledge-writer.js'); console.log(Object.keys(w)); console.log(typeof w.storeInsights === 'function', typeof w.ensureKnowledgeDB === 'function');"
  </verify>
  <done>
    knowledge-writer.js stores Haiku insights in Phase 3 knowledge DB with three-stage deduplication. Auto-initializes database on first use. Maps insight types to knowledge types with appropriate TTLs. Gracefully handles missing dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire session-end analysis hook into MCP server lifecycle and conversation end detection</name>
  <files>
    mcp-servers/telegram-mcp/src/storage/session-manager.ts
    mcp-servers/telegram-mcp/src/index.ts
    mcp-servers/telegram-mcp/src/bot/telegram-bot.ts
  </files>
  <action>
**session-manager.ts changes:**

Add new exported async function `closeSessionWithAnalysis(sessionId: string): Promise<{analyzed: boolean, reason: string}>`:

1. Load session entries via `loadSessionJSONL(getSessionPath(sessionId))`
2. Import quality gates: `const gates = require(path.resolve(PROJECT_ROOT, 'get-shit-done/bin/session-quality-gates.js'))`
3. Call `gates.shouldAnalyzeSession(entries)` - if analyze=false, skip to step 7
4. Call `gates.isAlreadyAnalyzed(sessionId, gates.getSessionContentHash(entries))` - if true, skip to step 7
5. Import analyzer: `const analyzer = require(path.resolve(PROJECT_ROOT, 'get-shit-done/bin/session-analyzer.js'))`
6. Call `analyzer.analyzeSession(entries)` to get extraction requests array. **Note: The actual Haiku Task() invocation happens in the calling GSD workflow, not here. This function prepares the analysis metadata and logs it to the session file as a `session_analysis_pending` entry for the GSD workflow to pick up.** Append entry: `{type: 'session_analysis_pending', extraction_requests: requests, timestamp: ISO, session_path: getSessionPath(sessionId)}`
7. Call existing `closeSession(sessionId)` to append session_close entry
8. Return `{analyzed: boolean, reason: string}`

Wrap everything in try/catch. If analysis fails, log error to stderr and close session anyway (analysis failure must never prevent session close).

**index.ts changes:**

Update both SIGINT and SIGTERM handlers to use `closeSessionWithAnalysis` instead of `closeSession`:

Replace:
```typescript
await closeSession(currentSessionId);
```
With:
```typescript
const { closeSessionWithAnalysis } = await import('./storage/session-manager.js');
const result = await closeSessionWithAnalysis(currentSessionId);
console.error(`[MCP] Session analysis: ${result.analyzed ? 'completed' : 'skipped'} (${result.reason})`);
```

Add import for `closeSessionWithAnalysis` at the top of the file alongside existing `closeSession` import.

Also add a 10-second timeout around the analysis to prevent hanging on shutdown:
```typescript
const analysisPromise = closeSessionWithAnalysis(currentSessionId);
const timeoutPromise = new Promise(resolve => setTimeout(() => resolve({analyzed: false, reason: 'timeout'}), 10000));
const result = await Promise.race([analysisPromise, timeoutPromise]);
```

**telegram-bot.ts changes (conversation end detection):**

Add conversation end detection to the bot's text message handler in `setupHandlers()`. This implements the must_have truth: "Conversation end is detected via explicit done command, /end, or 10-minute timeout."

1. **Add inactivity timer state** at module level (alongside the existing `bot`, `botStarted`, `ownerChatId` variables):
   ```typescript
   let inactivityTimer: NodeJS.Timeout | null = null;
   const INACTIVITY_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes
   ```

2. **Add helper function `resetInactivityTimer()`** that:
   - Clears any existing timer via `clearTimeout(inactivityTimer)`
   - Starts a new timer: `inactivityTimer = setTimeout(async () => { ... }, INACTIVITY_TIMEOUT_MS)`
   - When the timer fires:
     a. Import `closeSessionWithAnalysis` from `../storage/session-manager.js`
     b. Import `getCurrentSessionId` from `../storage/session-state.js`
     c. Get `sessionId = getCurrentSessionId()`
     d. If sessionId is not null, call `await closeSessionWithAnalysis(sessionId)`
     e. Send Telegram message to owner: "Session analysis triggered (10-minute inactivity timeout). Knowledge extracted."
     f. Log to stderr: `[telegram-bot] Inactivity timeout - session analysis triggered`

3. **Add /end command handler** in `setupHandlers()`:
   ```typescript
   botInstance.command('end', async (ctx) => {
     const { closeSessionWithAnalysis } = await import('../storage/session-manager.js');
     const { getCurrentSessionId } = await import('../storage/session-state.js');
     const sessionId = getCurrentSessionId();
     if (sessionId) {
       const result = await closeSessionWithAnalysis(sessionId);
       await ctx.reply(`Session analysis ${result.analyzed ? 'completed' : 'skipped'} (${result.reason}). Knowledge extracted.`);
     } else {
       await ctx.reply('No active session.');
     }
     // Clear inactivity timer since we explicitly ended
     if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; }
   });
   ```

4. **Add "done" text detection** in the existing text message handler. At the TOP of the `botInstance.on('text', ...)` handler, BEFORE the `/` command skip check, add:
   ```typescript
   const lowerText = text.trim().toLowerCase();
   if (lowerText === 'done') {
     const { closeSessionWithAnalysis } = await import('../storage/session-manager.js');
     const { getCurrentSessionId } = await import('../storage/session-state.js');
     const sessionId = getCurrentSessionId();
     if (sessionId) {
       const result = await closeSessionWithAnalysis(sessionId);
       await ctx.reply(`Session analysis ${result.analyzed ? 'completed' : 'skipped'} (${result.reason}). Knowledge extracted.`);
     } else {
       await ctx.reply('No active session to analyze.');
     }
     if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; }
     return;
   }
   ```

5. **Reset inactivity timer on every substantive message.** Call `resetInactivityTimer()` at the end of the text message handler and at the end of the voice message handler (after successful processing). This ensures the 10-minute window resets on each user interaction.

6. **Clear inactivity timer in `stopBot()`** to prevent firing after shutdown:
   ```typescript
   if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; }
   ```

After all TypeScript changes, rebuild: `cd mcp-servers/telegram-mcp && npm run build`
  </action>
  <verify>
    cd /Users/ollorin/get-shit-done/mcp-servers/telegram-mcp && npm run build 2>&1 | tail -5
  </verify>
  <done>
    MCP server runs session analysis BEFORE closing session on SIGINT/SIGTERM. Analysis is gated by quality checks and re-analysis prevention. Analysis failures do not prevent session close. 10-second timeout prevents hanging. Conversation end is detected via "done" text, /end command, or 10-minute inactivity timeout in telegram-bot.ts. All three triggers call closeSessionWithAnalysis. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `node -e "require('./get-shit-done/bin/knowledge-writer.js')"` loads without error
2. `cd mcp-servers/telegram-mcp && npm run build` compiles without errors
3. knowledge-writer.js uses Phase 3 dedup infrastructure (knowledge-dedup.js)
4. session-manager.ts exports closeSessionWithAnalysis
5. index.ts SIGINT/SIGTERM handlers call closeSessionWithAnalysis with timeout
6. No imports of `@anthropic-ai/sdk` in any new or modified files
7. Analysis happens BEFORE session_close entry is appended (locked decision #6)
8. telegram-bot.ts has /end command handler that calls closeSessionWithAnalysis
9. telegram-bot.ts text handler detects "done" (case-insensitive) and triggers analysis
10. telegram-bot.ts has 10-minute inactivity timer that auto-triggers analysis
</verification>

<success_criteria>
- Haiku insights flow through three-stage dedup before knowledge DB insertion
- Knowledge DB auto-initializes on first use without manual setup
- MCP session close triggers analysis before archiving (decision #6 honored)
- Analysis failures are logged but never prevent session close
- 10-second timeout prevents shutdown hangs
- Conversation end detected via "done" text, /end command, or 10-minute inactivity timeout
</success_criteria>

<output>
After completion, create `.planning/phases/11-session-end-knowledge-extraction-implement-haiku-based-analysis-of-completed-sessions-to-extract-reasoning-patterns-and-decisions-beyond-keyword-matching/11-03-SUMMARY.md`
</output>
