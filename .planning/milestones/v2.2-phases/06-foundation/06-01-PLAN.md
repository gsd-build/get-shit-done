---
phase: 06-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/adapters/codex.cjs
  - get-shit-done/bin/adapters/gemini.cjs
  - get-shit-done/bin/adapters/opencode.cjs
  - get-shit-done/templates/config.json
autonomous: true

must_haves:
  truths:
    - "Each adapter module exports detect() and invoke() functions conforming to the common contract"
    - "detect() returns { available, version, error } without ever throwing"
    - "invoke() returns { text, cli, duration, exitCode, error, errorType } without ever throwing"
    - "Error types are classified as NOT_FOUND, TIMEOUT, EXIT_ERROR, or PERMISSION"
    - "classifyError maps SIGTERM->TIMEOUT, ENOENT/127->NOT_FOUND, 126->PERMISSION, else->EXIT_ERROR"
    - "invoke() receives timeout via options.timeout and forwards it to execSync({timeout}), defaulting to 120000ms"
    - "Gemini adapter sanitizes environment by removing DEBUG before invocation"
    - "OpenCode adapter ignores stderr content when determining success (only checks exitCode)"
    - "Config template includes co_planners section with enabled:false and timeout_ms:120000"
  artifacts:
    - path: "get-shit-done/bin/adapters/codex.cjs"
      provides: "Codex CLI adapter with detect and invoke"
      exports: ["detect", "invoke", "CLI_NAME"]
    - path: "get-shit-done/bin/adapters/gemini.cjs"
      provides: "Gemini CLI adapter with detect and invoke"
      exports: ["detect", "invoke", "CLI_NAME"]
    - path: "get-shit-done/bin/adapters/opencode.cjs"
      provides: "OpenCode adapter with detect and invoke"
      exports: ["detect", "invoke", "CLI_NAME"]
    - path: "get-shit-done/templates/config.json"
      provides: "Config template with co_planners section"
      contains: "co_planners"
  key_links:
    - from: "get-shit-done/bin/adapters/codex.cjs"
      to: "child_process.execSync"
      via: "require('child_process')"
      pattern: "execSync"
    - from: "get-shit-done/bin/adapters/gemini.cjs"
      to: "child_process.execSync"
      via: "require('child_process')"
      pattern: "sanitizeEnv"
    - from: "get-shit-done/bin/adapters/opencode.cjs"
      to: "child_process.execSync"
      via: "require('child_process')"
      pattern: "execSync"
    - from: "get-shit-done/bin/adapters/*.cjs"
      to: "get-shit-done/bin/gsd-tools.cjs (Plan 02)"
      via: "require('./adapters/{cli}.cjs') â€” Plan 02 loads adapters via require()"
      pattern: "module\\.exports\\s*=\\s*\\{\\s*detect.*invoke.*CLI_NAME"
      note: "Integration contract: Plan 02 calls require() on each adapter file. Each adapter MUST export { detect, invoke, CLI_NAME } at module.exports. detect() is called with no arguments, invoke() with (prompt, { timeout, model }). Plan 02 owns the wiring; Plan 01 owns the contract."
---

<objective>
Create the three CLI adapter modules (codex, gemini, opencode) and update the config template with co-planner settings.

Purpose: Adapters are the atomic building blocks for Phase 6. Each encapsulates CLI-specific detection and invocation logic behind a common interface. The config template establishes the kill switch and timeout defaults. Plan 02 wires these into gsd-tools.cjs.

Output: Three adapter files in `get-shit-done/bin/adapters/` and updated `get-shit-done/templates/config.json`.
</objective>

<execution_context>
@/Users/zpyoung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zpyoung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-foundation/06-CONTEXT.md
@.planning/phases/06-foundation/06-RESEARCH.md
@get-shit-done/bin/gsd-tools.cjs (reference execGit pattern at line 225 and output/error helpers at line 469)
@get-shit-done/templates/config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create adapter modules with shared classifyError helper</name>
  <files>
    get-shit-done/bin/adapters/codex.cjs
    get-shit-done/bin/adapters/gemini.cjs
    get-shit-done/bin/adapters/opencode.cjs
  </files>
  <action>
Create the `get-shit-done/bin/adapters/` directory and three adapter files. Each adapter follows the same contract. Implementation has five distinct sub-steps -- complete all five for each adapter.

**Sub-step 1: classifyError helper (implement identically in each file)**

```javascript
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

function classifyError(err) {
  if (err.signal === 'SIGTERM') return 'TIMEOUT';
  if (err.code === 'ENOENT' || err.status === 127) return 'NOT_FOUND';
  if (err.status === 126) return 'PERMISSION';
  return 'EXIT_ERROR';
}
```

This mapping is the common error schema. All four types must be reachable code paths. Do NOT add types or change the mapping.

**Sub-step 2: detect() function (per-adapter)**

Each detect() runs `{CLI_NAME} --version` with 10s timeout, `stdio: 'pipe'`, `encoding: 'utf-8'`. Returns `{ available: true, version: stdout.trim(), error: null }` on success. On error, classifies via classifyError and returns `{ available: false, version: null, error: classifyError(err) }`. detect() MUST be wrapped in try/catch so it NEVER throws.

**Sub-step 3: invoke(prompt, options) function (per-adapter with CLI-specific quirks)**

Common contract: `invoke(prompt, options)` where `options = { timeout, model }`.
- `options.timeout` is forwarded directly to `execSync({timeout})`. Default: `options.timeout || 120000`. This is how the global timeout from config.json flows through -- Plan 02 reads `co_planners.timeout_ms` from config and passes it as `options.timeout`.
- Write prompt to temp file (`os.tmpdir()/gsd-{cli}-{Date.now()}.txt`), clean up in finally block.
- Return `{ text, cli: CLI_NAME, duration, exitCode, error, errorType }`. On success: `error: null, errorType: null`. On failure: `error: err.message, errorType: classifyError(err)`.
- invoke() MUST be wrapped in try/catch so it NEVER throws.

CLI-specific quirks within invoke():

*codex.cjs:*
- Command: `cat "{tmpFile}" | codex exec - --ephemeral --full-auto --skip-git-repo-check`
- Model flag: append ` -m "{model}"` if `options.model` provided
- `stdio: 'pipe'`, `maxBuffer: 10 * 1024 * 1024` (10MB)
- Prompt piped via stdin (cat of temp file)

*gemini.cjs:*
- Command: `cat "{tmpFile}" | gemini -p --output-format json`
- Model flag: append ` -m "{model}"` if `options.model` provided
- `stdio: 'pipe'`, `maxBuffer: 10 * 1024 * 1024`
- **Environment sanitization (Sub-step 4):** Pass `env: sanitizeEnv(process.env)` to execSync to prevent Gemini CLI freeze when DEBUG is set
- Parse JSON response: `JSON.parse(stdout)` then extract `parsed.response`. If JSON.parse fails, fall back to `stdout.trim()`

*opencode.cjs:*
- Command: `cat "{tmpFile}" | opencode run --format json`
- Model flag: append ` -m "{model}"` if `options.model` provided
- `stdio: 'pipe'`, `maxBuffer: 10 * 1024 * 1024`
- **Stderr filtering:** Only check exitCode for success/failure, NOT stderr content (OpenCode/Bun emits CPU warnings to stderr that are not errors)
- Parse JSON response via extractOpenCodeResponse(stdout) helper (Sub-step 5)

**Sub-step 4: sanitizeEnv helper (gemini.cjs only)**

```javascript
function sanitizeEnv(env) {
  const clean = { ...env };
  delete clean.DEBUG;
  return clean;
}
```

**Sub-step 5: extractOpenCodeResponse helper (opencode.cjs only)**

```javascript
function extractOpenCodeResponse(stdout) {
  try {
    const parsed = JSON.parse(stdout);
    // Extract text from response object -- exact field names TBD from live testing
    if (typeof parsed === 'string') return parsed;
    if (parsed.response) return parsed.response;
    if (parsed.text) return parsed.text;
    return stdout.trim();
  } catch {
    return stdout.trim();
  }
}
```

**Module exports (all three files):**
```javascript
module.exports = { detect, invoke, CLI_NAME };
```

**IMPORTANT:** Each adapter must NEVER throw. All errors must be caught and returned as structured objects with `errorType` classification.
  </action>
  <verify>
**Export verification (all three):**
```bash
node -e "const a = require('./get-shit-done/bin/adapters/codex.cjs'); console.log(Object.keys(a))"
node -e "const a = require('./get-shit-done/bin/adapters/gemini.cjs'); console.log(Object.keys(a))"
node -e "const a = require('./get-shit-done/bin/adapters/opencode.cjs'); console.log(Object.keys(a))"
```
Each must export `detect`, `invoke`, `CLI_NAME`.

**Syntax check (all three):**
```bash
node -c get-shit-done/bin/adapters/codex.cjs
node -c get-shit-done/bin/adapters/gemini.cjs
node -c get-shit-done/bin/adapters/opencode.cjs
```

**classifyError mapping verification (run on any one adapter, same logic in all):**
```bash
node -e "
  const a = require('./get-shit-done/bin/adapters/codex.cjs');
  // Simulate error objects matching each classification
  const cases = [
    [{ signal: 'SIGTERM' }, 'TIMEOUT'],
    [{ code: 'ENOENT' }, 'NOT_FOUND'],
    [{ status: 127 }, 'NOT_FOUND'],
    [{ status: 126 }, 'PERMISSION'],
    [{ status: 1 }, 'EXIT_ERROR'],
  ];
  // classifyError is internal, so test via detect() with a non-existent CLI
  // Just verify detect() returns without throwing
  const result = a.detect();
  console.log('detect returned:', JSON.stringify(result));
  console.assert(typeof result === 'object', 'detect must return object');
  console.assert('available' in result, 'must have available field');
  console.assert('version' in result, 'must have version field');
  console.assert('error' in result, 'must have error field');
  console.log('detect contract: PASS');
"
```

**Never-throws contract verification (all three):**
```bash
node -e "
  const adapters = ['codex', 'gemini', 'opencode'];
  for (const name of adapters) {
    const a = require('./get-shit-done/bin/adapters/' + name + '.cjs');
    // detect() must not throw even if CLI is missing
    try { a.detect(); } catch(e) { console.error(name + ' detect() THREW:', e.message); process.exit(1); }
    // invoke() must not throw even with bad input
    try { a.invoke('test', { timeout: 1 }); } catch(e) { console.error(name + ' invoke() THREW:', e.message); process.exit(1); }
    console.log(name + ': never-throws PASS');
  }
"
```
Note: invoke() with 1ms timeout will return a TIMEOUT errorType, which is the correct structured error behavior.

**Gemini sanitizeEnv verification:**
```bash
node -e "
  const g = require('./get-shit-done/bin/adapters/gemini.cjs');
  // Verify module loads without error (sanitizeEnv is internal)
  console.log('gemini adapter loaded, CLI_NAME:', g.CLI_NAME);
"
```
  </verify>
  <done>
Three adapter files exist in `get-shit-done/bin/adapters/`. Each exports `detect()`, `invoke(prompt, options)`, and `CLI_NAME`. All files pass Node.js syntax check. classifyError correctly maps SIGTERM->TIMEOUT, ENOENT/127->NOT_FOUND, 126->PERMISSION, else->EXIT_ERROR. detect() and invoke() never throw -- verified with missing CLIs and 1ms timeout. Gemini adapter includes sanitizeEnv. OpenCode adapter includes extractOpenCodeResponse. invoke() accepts `options.timeout` (default 120000ms) and forwards to execSync.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add co_planners section to config template</name>
  <files>get-shit-done/templates/config.json</files>
  <action>
Add a `co_planners` section to `get-shit-done/templates/config.json`:

```json
{
  "co_planners": {
    "enabled": false,
    "timeout_ms": 120000
  }
}
```

Place it immediately after the `adversary` section (currently ending at line 31 of config.json) and before the `gates` section (currently starting at line 32). Both `adversary` and `co_planners` are optional external review agents, making them conceptual neighbors. The default MUST be `enabled: false` (opt-in, not opt-out) per locked user decision.

Do NOT add per-checkpoint configuration, per-CLI agent lists, or any Phase 7+ config. Keep it minimal: just the kill switch and global timeout.

Note on timeout_ms: This value is the global default that Plan 02 will read via `config.co_planners.timeout_ms` and pass to each adapter's `invoke(prompt, { timeout: timeout_ms })`. Adapters do not read config directly -- they receive timeout as a parameter.
  </action>
  <verify>
Run `node -e "const c = require('./get-shit-done/templates/config.json'); console.log(c.co_planners)"` -- should print `{ enabled: false, timeout_ms: 120000 }`. Verify `co_planners.enabled === false` (not undefined, not null).

Verify placement: `node -e "const keys = Object.keys(require('./get-shit-done/templates/config.json')); const ai = keys.indexOf('adversary'); const ci = keys.indexOf('co_planners'); const gi = keys.indexOf('gates'); console.log('adversary:', ai, 'co_planners:', ci, 'gates:', gi); console.assert(ci === ai + 1, 'co_planners must follow adversary'); console.assert(gi === ci + 1, 'gates must follow co_planners');"` -- co_planners must be between adversary and gates.
  </verify>
  <done>
Config template contains `co_planners.enabled: false` and `co_planners.timeout_ms: 120000`. No extra fields beyond these two. Section is placed between `adversary` and `gates`.
  </done>
</task>

</tasks>

<verification>
1. All three adapter files exist: `ls get-shit-done/bin/adapters/`
2. Each adapter exports the correct interface: `detect`, `invoke`, `CLI_NAME`
3. No adapter throws on `require()` -- all load cleanly
4. detect() never throws, even when CLIs are missing (returns structured error)
5. invoke() never throws, even with 1ms timeout (returns structured TIMEOUT error)
6. classifyError produces correct mapping for all four error types
7. Gemini adapter has sanitizeEnv removing DEBUG from environment
8. OpenCode adapter has extractOpenCodeResponse for defensive JSON parsing
9. Config template has `co_planners` section with correct defaults, positioned after `adversary`
10. Syntax check passes: `node -c` on all three adapter files
</verification>

<success_criteria>
- Three adapter files in `get-shit-done/bin/adapters/` each exporting `detect()`, `invoke(prompt, options)`, `CLI_NAME`
- All adapters conform to common return schema `{ text, cli, duration, exitCode, error, errorType }`
- invoke() accepts `options.timeout` (default 120000ms) forwarded to execSync
- classifyError maps: SIGTERM->TIMEOUT, ENOENT/127->NOT_FOUND, 126->PERMISSION, else->EXIT_ERROR
- detect() and invoke() never throw under any input or error condition
- Config template has `co_planners: { enabled: false, timeout_ms: 120000 }`
- Zero new npm dependencies
- Integration contract for Plan 02: adapters loaded via `require('./adapters/{cli}.cjs')`, each exports `{ detect, invoke, CLI_NAME }`
</success_criteria>

<output>
After completion, create `.planning/phases/06-foundation/06-01-SUMMARY.md`
</output>
