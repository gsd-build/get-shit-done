---
phase: 04-execution-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/commands/compute-waves.js
  - src/artifacts/exec-plan.js
  - src/commands/generate-exec-plan.js
  - src/commands/verify-wave.js
autonomous: true
requirements:
  - EXEC-01
  - EXEC-02
  - EXEC-03
  - EXEC-04

must_haves:
  truths:
    - "compute-waves returns topologically valid wave groups for a milestone's non-DONE actions"
    - "generate-exec-plan produces a GSD-style PLAN.md with frontmatter, XML tasks, and why-chain context"
    - "verify-wave checks that completed actions' produces artifacts exist on disk and detects milestone completability"
  artifacts:
    - path: "src/commands/compute-waves.js"
      provides: "Wave computation from milestone action graph"
      exports: ["runComputeWaves"]
    - path: "src/artifacts/exec-plan.js"
      provides: "EXEC-PLAN markdown generation with GSD format"
      exports: ["generateExecPlan"]
    - path: "src/commands/generate-exec-plan.js"
      provides: "CLI subcommand wrapping exec-plan generation"
      exports: ["runGenerateExecPlan"]
    - path: "src/commands/verify-wave.js"
      provides: "Post-wave upward verification checks"
      exports: ["runVerifyWave"]
  key_links:
    - from: "src/commands/compute-waves.js"
      to: "src/commands/build-dag.js"
      via: "buildDagFromDisk for graph loading"
      pattern: "buildDagFromDisk\\(cwd\\)"
    - from: "src/artifacts/exec-plan.js"
      to: "src/commands/trace.js"
      via: "traceUpward for why-chain context"
      pattern: "traceUpward\\(dag"
    - from: "src/commands/verify-wave.js"
      to: "src/commands/build-dag.js"
      via: "buildDagFromDisk for graph state check"
      pattern: "buildDagFromDisk\\(cwd\\)"
---

<objective>
Build the four core engine modules for Declare's execution pipeline: wave computation, exec-plan generation, and wave verification.

Purpose: These modules provide the data layer that the /declare:execute slash command will orchestrate. They transform the Declare DAG into executable work units (waves of GSD-style plans) and verify that completed work advances milestones.
Output: Four new CJS modules — compute-waves.js, exec-plan.js, generate-exec-plan.js, verify-wave.js
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-execution-pipeline/04-RESEARCH.md
@src/commands/build-dag.js
@src/commands/trace.js
@src/commands/parse-args.js
@src/graph/engine.js
@src/artifacts/plan.js
@src/artifacts/milestone-folders.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement compute-waves and exec-plan artifact module</name>
  <files>src/commands/compute-waves.js, src/artifacts/exec-plan.js</files>
  <action>
Create `src/commands/compute-waves.js`:
- Export `runComputeWaves(cwd, args)` following the established command module pattern (parseFlag for args, buildDagFromDisk for graph loading, JSON return)
- Accept `--milestone M-XX` flag to scope execution to a single milestone
- Load DAG via `buildDagFromDisk(cwd)`, validate milestone exists and is type 'milestone'
- Get non-DONE actions for the milestone via `dag.getDownstream(milestoneId).filter(n => n.type === 'action' && n.status !== 'DONE')`
- In the current v1 model, all sibling actions within a milestone form a single wave (no inter-action edges). Group them as Wave 1.
- Return JSON: `{ milestoneId, milestoneTitle, declarations: [{id, title}], waves: [{ wave: 1, actions: [{id, title, status, produces}] }], totalActions, allDone }`
- Include upstream declarations from `dag.getUpstream(milestoneId)` for trace context enrichment
- If no non-DONE actions remain, return `{ milestoneId, waves: [], totalActions: 0, allDone: true }`

Create `src/artifacts/exec-plan.js`:
- Export `generateExecPlan(dag, actionId, milestoneId, waveNumber)` — pure function, no I/O
- Use `traceUpward(dag, actionId)` from `../commands/trace.js` to build the why-chain
- Extract declarations from trace paths: unique declaration nodes with their titles
- Build why-chain string: "This action causes M-XX ('title') which realizes D-XX: title, D-YY: title"
- Generate a GSD-style PLAN.md string with:
  - YAML frontmatter: phase (milestoneId), plan (actionId), type: execute, wave number, depends_on: [], files_modified: [], autonomous: true
  - `<objective>` section with action title, why-chain purpose, and produces output
  - `<context>` section referencing @.planning/FUTURE.md, @.planning/MILESTONES.md, and the milestone's PLAN.md path
  - `<tasks>` section with a single `<task type="auto">` containing the action description enriched with why-chain context
  - `<verification>` and `<success_criteria>` sections
  - `<output>` section instructing atomic commit and orchestrator reporting
- The action node's metadata.description provides the action content; action.title provides the name; action.metadata.produces provides the output
- Note: action descriptions come from parsePlanFile — the `description` field on each action object

Both files: zero runtime dependencies beyond existing internal modules, CJS format, 'use strict', @ts-check, JSDoc annotations.
  </action>
  <verify>
Run `node -e "const {runComputeWaves} = require('./src/commands/compute-waves'); console.log(typeof runComputeWaves)"` — should print 'function'.
Run `node -e "const {generateExecPlan} = require('./src/artifacts/exec-plan'); console.log(typeof generateExecPlan)"` — should print 'function'.
  </verify>
  <done>
compute-waves returns valid wave JSON for a milestone ID; exec-plan generates a complete GSD-format PLAN.md string from action + DAG context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement generate-exec-plan command and verify-wave command</name>
  <files>src/commands/generate-exec-plan.js, src/commands/verify-wave.js</files>
  <action>
Create `src/commands/generate-exec-plan.js`:
- Export `runGenerateExecPlan(cwd, args)` following command module pattern
- Accept flags: `--action A-XX`, `--milestone M-XX`
- Load DAG via `buildDagFromDisk(cwd)`, validate both action and milestone exist
- Determine wave number (default 1; accept `--wave N` override)
- Call `generateExecPlan(dag, actionId, milestoneId, waveNumber)` from `../artifacts/exec-plan.js`
- Write the generated content to the milestone folder: use `findMilestoneFolder(planningDir, milestoneId)` from `../artifacts/milestone-folders.js` to locate the folder
- Name the file `EXEC-PLAN-{NN}.md` where NN is the numeric suffix from the action ID (e.g., A-03 -> EXEC-PLAN-03.md)
- Return JSON: `{ actionId, milestoneId, wave, outputPath, content (first 200 chars for preview) }`
- If milestone folder not found, return error suggesting user run /declare:actions first

Create `src/commands/verify-wave.js`:
- Export `runVerifyWave(cwd, args)` following command module pattern
- Accept flags: `--milestone M-XX`, `--actions "A-01,A-02,A-03"` (comma-separated list of completed action IDs)
- Load DAG via `buildDagFromDisk(cwd)`
- Perform automated verification checks for each action:
  1. **Artifact existence**: Parse the action's `produces` field; check if referenced files exist on disk (resolve relative to cwd). If produces is empty or a description (not a file path), mark as "no-file-check" (pass).
  2. **Action status check**: Verify the action node exists in the DAG (it should; confirms graph consistency).
- Compute milestone completability: check if ALL actions for the milestone are now DONE (considering the just-completed actions as DONE even if not yet updated in artifacts)
- Build trace context for AI review: use `traceUpward(dag, milestoneId)` to get the why-chain from milestone to declarations
- Return JSON: `{ milestoneId, milestoneTitle, completedActions: [{id, title, producesExist}], milestoneCompletable: boolean, traceContext: {declarations: [{id, title}], whyChain: string}, allChecks: [{actionId, check, passed}], passed: boolean }`
- `passed` is true when all automated checks pass. The AI review is performed by the slash command (not in CJS).

Both files: follow existing patterns — parseFlag, buildDagFromDisk, JSON return, error objects. Zero new dependencies.
  </action>
  <verify>
Run `node -e "const {runGenerateExecPlan} = require('./src/commands/generate-exec-plan'); console.log(typeof runGenerateExecPlan)"` — should print 'function'.
Run `node -e "const {runVerifyWave} = require('./src/commands/verify-wave'); console.log(typeof runVerifyWave)"` — should print 'function'.
  </verify>
  <done>
generate-exec-plan writes a GSD-format EXEC-PLAN-NN.md to the correct milestone folder; verify-wave returns verification results with milestone completability and trace context for AI review.
  </done>
</task>

</tasks>

<verification>
1. All four source files exist and export their expected functions
2. compute-waves uses buildDagFromDisk and filters non-DONE actions
3. exec-plan uses traceUpward and generates valid GSD PLAN.md format with frontmatter + XML tasks
4. generate-exec-plan writes to milestone folder with EXEC-PLAN-NN.md naming
5. verify-wave checks produces artifacts and reports milestone completability
6. No new npm dependencies added
</verification>

<success_criteria>
The four engine modules compile, export correct functions, and follow established CJS/JSDoc/zero-dependency patterns. They transform DAG structure into executable waves, generate GSD-compatible plans enriched with why-chain context, and verify that completed work advances milestones.
</success_criteria>

<output>
After completion, create `.planning/phases/04-execution-pipeline/04-01-SUMMARY.md`
</output>
