---
phase: 02-future-declaration-backward-derivation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - commands/declare/future.md
  - commands/declare/derive.md
  - workflows/future.md
  - workflows/derive.md
autonomous: true

must_haves:
  truths:
    - "User can run /declare:future and be guided through capturing 3-5 present-tense declarations via conversational prompts"
    - "System detects past-derived language ('I want X because Y is broken') and goal language ('I want to achieve X') and responds with Socratic reframing, not verdicts"
    - "System validates declarations against NSR criteria (Necessary, Sufficient, Relevant) during capture"
    - "Each confirmed declaration is persisted to FUTURE.md via add-declaration tool call"
    - "User can run /declare:derive and the system derives milestones by asking 'what must be true?' for each declaration"
    - "System derives actions from milestones by asking 'what must be done?' recursively until atomic"
    - "User confirms or adjusts each proposed milestone and action before persistence"
    - "System detects overlapping milestones across declarations and proposes merges"
    - "After 2-3 reframing attempts, system accepts the user's phrasing with a note"
  artifacts:
    - path: "commands/declare/future.md"
      provides: "Slash command entry point for /declare:future"
      contains: "declare-tools.cjs"
    - path: "commands/declare/derive.md"
      provides: "Slash command entry point for /declare:derive"
      contains: "declare-tools.cjs"
    - path: "workflows/future.md"
      provides: "Full guided conversation logic for declaration capture"
      contains: "Language Detection"
    - path: "workflows/derive.md"
      provides: "Full guided conversation logic for backward derivation"
      contains: "what must be true"
  key_links:
    - from: "commands/declare/future.md"
      to: "workflows/future.md"
      via: "@-reference in command file"
      pattern: "@.*workflows/future.md"
    - from: "commands/declare/derive.md"
      to: "workflows/derive.md"
      via: "@-reference in command file"
      pattern: "@.*workflows/derive.md"
    - from: "workflows/future.md"
      to: "dist/declare-tools.cjs"
      via: "add-declaration tool calls"
      pattern: "declare-tools.cjs add-declaration"
    - from: "workflows/derive.md"
      to: "dist/declare-tools.cjs"
      via: "add-milestone and add-action tool calls"
      pattern: "declare-tools.cjs add-milestone"
---

<objective>
Create the /declare:future and /declare:derive slash commands with their conversation workflow prompts.

Purpose: These are the core user-facing commands for Phase 2. /declare:future guides users through capturing present-tense truth statements with Socratic correction and NSR validation. /declare:derive takes confirmed declarations and works backward through "what must be true?" questioning to produce milestones and actions. Both workflows are prompt engineering -- the intelligence lives in the markdown, not in code.

Output: Two slash commands (.md in commands/declare/) and two workflow files (.md in workflows/) installed to user-level paths.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-future-declaration-backward-derivation/02-RESEARCH.md
@.planning/phases/02-future-declaration-backward-derivation/02-CONTEXT.md
@.planning/phases/02-future-declaration-backward-derivation/02-01-SUMMARY.md

# Pattern references:
@commands/declare/init.md
@commands/declare/status.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /declare:future slash command and declaration capture workflow</name>
  <files>
    commands/declare/future.md
    workflows/future.md
  </files>
  <action>
**commands/declare/future.md** -- Slash command entry point.

Follow the exact pattern of `commands/declare/init.md`:
- Frontmatter: description ("Declare futures through guided conversation"), allowed-tools (Read, Write, Bash, Glob, Grep), argument-hint ("[--add]").
- Step 1: Load current graph state via `node /Users/guilherme/Projects/get-shit-done/dist/declare-tools.cjs load-graph`. Parse JSON to understand existing declarations. If error (no project), tell user to run /declare:init first.
- Step 2: Reference the workflow file via `@/Users/guilherme/Projects/get-shit-done/workflows/future.md`. Instruct Claude to follow the workflow.
- Step 3: After each confirmed declaration, persist via `node /Users/guilherme/Projects/get-shit-done/dist/declare-tools.cjs add-declaration --title "..." --statement "..."`.
- Step 4: After all declarations captured, show summary of what was declared, suggest next step (/declare:derive).
- If `--add` flag is present, skip the intro and add to existing declarations (for post-initial-session use per locked decision: "Declarations can be added or modified anytime").

**workflows/future.md** -- The full guided conversation logic.

This is the core prompt engineering artifact. Structure it in these sections:

**1. Opening (set the frame):**
```
"Let's declare the future for [project name].

When this project fully succeeds, what's true? Not what you want to achieve -- what IS true, as if you're looking back from that future.

I'll help you capture 3-5 declarations. Each one should be a present-tense statement of fact."
```

If existing declarations already exist (from load-graph), show them and ask: "Would you like to add to these, or start fresh?"

**2. Per-Declaration Loop:**

For each of the 3-5 declarations:
a. Ask a guided prompt (vary the angle -- do not repeat the same question). Examples:
   - "What's true about [domain] when this project succeeds?"
   - "If we fast-forward to the future where this is done, what do you see?"
   - "What's the reality you're creating here?"
   - "What's something that's TRUE in that future that isn't true today?"
b. Receive user's statement.
c. Classify language using the Language Detection Guide (section below).
d. If past-derived or goal language: Socratic reframe (max 2-3 attempts per locked decision).
e. NSR validation (section below).
f. If passes: confirm with user, then persist via add-declaration.
g. If fails NSR: explain which criterion and help rewrite.
h. After persisting: "Got it. [declaration]. What's next?"

**3. Language Detection Guide:**

Embedded directly in the workflow (per research: Claude IS the NLP engine, not code).

**Declared Future (ACCEPT):**
- Present tense, stated as fact: "Our API handles 10K RPS with <50ms p99"
- No causal reference to problems: stands on its own
- No aspirational language: not "we will" or "we aim to"
- No requirement framing: not "the system needs to" or "it should"

**Past-Derived (REFRAME):**
- References a problem: "I want X because Y is broken/slow/bad"
- Reactive framing: "We need to stop/fix/prevent X"
- Complaint-rooted: the energy comes from what's wrong, not what's possible
- Detection signals: "because", "instead of", "unlike", "no more", "stop", "fix"

**Goal Language (REFRAME):**
- Future aspirational: "I want to achieve X" / "Our goal is X"
- Conditional: "We should be able to X" / "We need to X"
- Requirement framing: "The system must X" / "Users should be able to"
- Detection signals: "want to", "goal", "aim", "achieve", "need to", "should"

**Reframing approach (per locked decisions):**
1. First attempt -- gentle, with philosophy: "I hear what you're pointing at. Declarations work from the future, not against the past. What if we stated it as: '[reframe]'?"
2. Second attempt -- shorter, different angle: "Let me try another angle: '[different reframe]'. Does that land?"
3. Third attempt -- accept with note: "I'll capture it as you've stated it. We can always refine later."

Show before/after comparison ONLY when the change is significant enough to warrant it (locked decision).

**4. NSR Validation:**

After each declaration passes language check:

**Necessary:** Is this declaration needed? Would the future be incomplete without it?
- FAIL: Overlaps significantly with an existing declaration
- Response: "This seems to overlap with [other]. Could we combine them, or is there a distinct aspect I'm missing?"

**Sufficient:** (Checked across the SET after 3+ declarations)
- After 3-5: "Looking at these together, is there an aspect of the future we haven't captured?"

**Relevant:** Is this about THIS project's future?
- FAIL: Too generic ("Our code is good") or wrong scope
- Response: "This feels broader than [project]. Can we make it more specific?"

**5. Closing:**

After user is satisfied (3-5 declarations captured):
```
"Here's the future we've declared:

1. [D-01]: [statement]
2. [D-02]: [statement]
...

Does this feel complete? Is there an aspect we haven't captured?"
```

If complete: "Your future is declared. Run `/declare:derive` to work backward from these declarations to milestones and actions."
If user wants more: continue the loop.

**Key design principles (embed as instructions to Claude in the workflow):**
- Feel like a dialogue, not a form. Adapt question phrasing to the user's domain.
- The reframe should feel like a gift ("here's a more powerful way to say that"), not a correction.
- Never refuse a declaration outright. After 2-3 attempts, accept.
- Independence: declarations must stand alone. If user references another declaration, note it and suggest keeping them independent (relationships emerge via shared milestones in derivation).
  </action>
  <verify>
    Test file existence and structure:
    - commands/declare/future.md exists and has valid frontmatter (description, allowed-tools)
    - workflows/future.md exists and contains "Language Detection", "NSR", "what's true", "declare-tools.cjs add-declaration"
    - Both files reference correct absolute paths to declare-tools.cjs
  </verify>
  <done>
    /declare:future command and workflow exist. The workflow contains: guided opening, per-declaration loop with varied prompts, language detection guide (past-derived + goal detection), Socratic reframing with 2-3 attempt limit, NSR validation, and closing with next-step suggestion. All tool calls reference the correct absolute path to declare-tools.cjs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /declare:derive slash command and backward derivation workflow</name>
  <files>
    commands/declare/derive.md
    workflows/derive.md
  </files>
  <action>
**commands/declare/derive.md** -- Slash command entry point.

Follow the pattern of init.md:
- Frontmatter: description ("Derive milestones and actions backward from declarations"), allowed-tools (Read, Write, Bash, Glob, Grep), argument-hint ("[D-XX]".
- Step 1: Load current graph state via `node /Users/guilherme/Projects/get-shit-done/dist/declare-tools.cjs load-graph`. Parse JSON. If no declarations exist, tell user to run /declare:future first.
- Step 2: If argument provided (D-XX), derive only for that declaration. Otherwise derive for all PENDING declarations that have no milestones yet.
- Step 3: Reference the workflow file via `@/Users/guilherme/Projects/get-shit-done/workflows/derive.md`.
- Step 4: For each confirmed milestone, persist via `node /Users/guilherme/Projects/get-shit-done/dist/declare-tools.cjs add-milestone --title "..." --realizes "D-XX"`.
- Step 5: For each confirmed action, persist via `node /Users/guilherme/Projects/get-shit-done/dist/declare-tools.cjs add-action --title "..." --causes "M-XX"`.
- Step 6: After derivation complete, run load-graph again and show updated stats. Suggest /declare:status to see the full picture.

**workflows/derive.md** -- The full backward derivation conversation logic.

**1. Opening:**

Show current declarations from load-graph output:
```
"Let's work backward from your declarations to concrete milestones and actions.

Your declared futures:
- D-01: [statement]
- D-02: [statement]
...

I'll take each declaration and ask: 'For this to be true, what must be true?' Then we'll go deeper until we reach actions you can execute directly."
```

**2. Per-Declaration Derivation Loop:**

For each declaration D:

a. State the question explicitly (per locked decision: "Show the backward logic explicitly"):
   "For '[D statement]' to be true, what must be true?"

b. Propose 2-4 milestones. Present each with clear backward logic:
   "I see these conditions that must hold:
   1. [Milestone A] -- because [why this must be true for D]
   2. [Milestone B] -- because [why]
   3. [Milestone C] -- because [why]"

c. Ask user to confirm, adjust, add, or remove each milestone. Per locked decision: "system proposes milestones, user confirms/adjusts each one before moving deeper."

d. For each confirmed milestone, persist via add-milestone.

**3. Per-Milestone Derivation Loop (recursive):**

For each confirmed milestone M:

a. State the question: "For '[M title]' to be true, what must be done?"

b. Propose 2-4 items (actions or sub-milestones).

c. For each proposed item, check atomicity (Claude's discretion):
   - Heuristic: Can this be completed in a single focused session by one agent/person? Does it produce a verifiable artifact? Is it clear what "done" means without further decomposition?
   - If YES: persist as action via add-action.
   - If NO: persist as milestone via add-milestone, then recurse (derive its sub-items).

d. User confirms/adjusts each before persistence. Per locked decision: "Derive until atomic: keep deriving until actions are small enough to execute directly."

**4. Milestone Merge Detection:**

After all declarations have been derived:

a. Load the full graph via load-graph.

b. Scan milestones. For each pair of milestones that realize DIFFERENT declarations, check if they describe the same condition. This is a semantic check done by Claude (per research: "Semantic similarity detection is Claude's job").

c. If potential overlaps found, propose merges:
   "I notice M-03 ('[title]') and M-07 ('[title]') both describe [same condition], but they serve different declarations. Should we merge them into one milestone with multiple parent declarations?"

d. If user confirms: The merge needs to be done by reading the current files, manually combining the entries, and writing updated files via Write tool. Steps:
   - Keep one milestone (the lower-numbered one).
   - Move all action links from the removed milestone to the kept one (update causedBy and Causes fields).
   - Update FUTURE.md: replace references to the removed milestone with the kept one.
   - Update MILESTONES.md: remove the duplicate row, update the kept row's Realizes field to include both declarations.
   - Write both files.
   - Commit via `node /Users/guilherme/Projects/get-shit-done/dist/declare-tools.cjs commit "declare: merge [removed-id] into [kept-id]" --files .planning/FUTURE.md .planning/MILESTONES.md`.

e. If no overlaps or user declines merges: skip.

**5. Closing:**

```
"Derivation complete.

From [N] declarations, we derived:
- [X] milestones
- [Y] actions
[If merges happened: - [Z] milestones merged]

Run `/declare:status` to see the full graph."
```

**Key design principles (embed as instructions to Claude in the workflow):**
- Make the backward logic visible and teachable. Always state the question being asked.
- Collaborative, not batch: never auto-derive a full tree. Stop for confirmation at each level.
- The user may have better domain knowledge about what milestones are needed. Propose, don't dictate.
- When checking atomicity, err on the side of "atomic enough" -- over-decomposition creates graph bloat.
- Re-derivation awareness: if milestones already exist for a declaration, present them: "These milestones were previously derived. Which still apply?" (per research pitfall #3).
  </action>
  <verify>
    Test file existence and structure:
    - commands/declare/derive.md exists and has valid frontmatter (description, allowed-tools)
    - workflows/derive.md exists and contains "what must be true", "what must be done", "merge", "declare-tools.cjs add-milestone", "declare-tools.cjs add-action"
    - Both files reference correct absolute paths to declare-tools.cjs
  </verify>
  <done>
    /declare:derive command and workflow exist. The workflow contains: per-declaration milestone derivation with explicit backward logic, per-milestone action derivation with atomicity checking, recursive depth (not fixed at two levels), user confirmation at each level, milestone merge detection across declarations, and re-derivation awareness for modified declarations. All tool calls reference the correct absolute path to declare-tools.cjs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Install commands to user-level paths and verify end-to-end</name>
  <files>
    ~/.claude/commands/declare/future.md
    ~/.claude/commands/declare/derive.md
  </files>
  <action>
**Install slash commands:**

Copy the command files to the user-level Claude commands directory (per Phase 1 decision: "Commands installed to user-level ~/.claude/commands/declare/ with absolute paths for cross-project usage"):

```bash
cp commands/declare/future.md ~/.claude/commands/declare/future.md
cp commands/declare/derive.md ~/.claude/commands/declare/derive.md
```

**Verify installation:**

1. Check all 5 declare commands exist:
   ```bash
   ls ~/.claude/commands/declare/
   ```
   Expected: future.md, derive.md, help.md, init.md, status.md

2. Verify absolute paths in command files point to the correct declare-tools.cjs:
   ```bash
   grep "declare-tools.cjs" ~/.claude/commands/declare/future.md
   grep "declare-tools.cjs" ~/.claude/commands/declare/derive.md
   ```

3. Verify workflow files exist and are referenced:
   ```bash
   ls workflows/future.md workflows/derive.md
   grep "workflows/future.md" commands/declare/future.md
   grep "workflows/derive.md" commands/declare/derive.md
   ```

4. Quick smoke test of the tooling chain:
   ```bash
   # Create temp project, init, add declaration, load graph
   TMPDIR=$(mktemp -d)
   cd $TMPDIR && git init && node /path/to/dist/declare-tools.cjs init
   node /path/to/dist/declare-tools.cjs add-declaration --title "Test" --statement "This works"
   node /path/to/dist/declare-tools.cjs load-graph
   rm -rf $TMPDIR
   ```
  </action>
  <verify>
    ls ~/.claude/commands/declare/ | sort
    # Must show: derive.md, future.md, help.md, init.md, status.md
  </verify>
  <done>
    Both /declare:future and /declare:derive are installed at user-level and accessible from any project. All 5 declare slash commands are present. Workflow files exist and are correctly referenced. The full tooling chain (init -> add-declaration -> add-milestone -> add-action -> load-graph) works end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `ls ~/.claude/commands/declare/` shows 5 files: derive.md, future.md, help.md, init.md, status.md
2. `ls workflows/` shows 2 files: derive.md, future.md
3. `grep -c "declare-tools.cjs" commands/declare/future.md` returns >= 2 (load-graph + add-declaration calls)
4. `grep -c "declare-tools.cjs" commands/declare/derive.md` returns >= 3 (load-graph + add-milestone + add-action calls)
5. `grep "Language Detection" workflows/future.md` confirms language detection guide is embedded
6. `grep "what must be true" workflows/derive.md` confirms backward derivation questioning is explicit
7. Workflow files contain all locked decisions: 2-3 reframe attempts, NSR validation, collaborative derivation, derive-until-atomic, merge detection
</verification>

<success_criteria>
Two new slash commands (/declare:future and /declare:derive) are functional and installed. The declaration capture flow guides users through 3-5 present-tense declarations with Socratic correction and NSR validation. The derivation flow works backward from declarations through "what must be true?" to milestones and "what must be done?" to actions, with user confirmation at each level, recursive depth, and milestone merge detection.
</success_criteria>

<output>
After completion, create `.planning/phases/02-future-declaration-backward-derivation/02-02-SUMMARY.md`
</output>
