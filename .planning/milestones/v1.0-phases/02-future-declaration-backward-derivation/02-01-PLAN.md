---
phase: 02-future-declaration-backward-derivation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/commands/add-declaration.js
  - src/commands/add-milestone.js
  - src/commands/add-action.js
  - src/commands/load-graph.js
  - src/commands/commands.test.js
  - src/declare-tools.js
  - dist/declare-tools.cjs
autonomous: true

must_haves:
  truths:
    - "Running `declare-tools.cjs add-declaration --title '...' --statement '...'` creates a new D-XX entry in FUTURE.md and returns JSON with the assigned ID"
    - "Running `declare-tools.cjs add-milestone --title '...' --realizes D-01` creates a new M-XX entry in MILESTONES.md, links it to D-01, and updates FUTURE.md's milestone list"
    - "Running `declare-tools.cjs add-action --title '...' --causes M-01` creates a new A-XX entry in MILESTONES.md and links it to M-01"
    - "Running `declare-tools.cjs load-graph` returns a JSON object with declarations, milestones, actions, stats, and validation"
    - "All four subcommands auto-increment IDs using DeclareDag.nextId()"
    - "All mutation commands produce atomic git commits when commit_docs is enabled"
  artifacts:
    - path: "src/commands/add-declaration.js"
      provides: "Add declaration to FUTURE.md + graph"
      exports: ["runAddDeclaration"]
    - path: "src/commands/add-milestone.js"
      provides: "Add milestone to MILESTONES.md + update FUTURE.md cross-refs"
      exports: ["runAddMilestone"]
    - path: "src/commands/add-action.js"
      provides: "Add action to MILESTONES.md"
      exports: ["runAddAction"]
    - path: "src/commands/load-graph.js"
      provides: "Load full graph state as JSON"
      exports: ["runLoadGraph"]
    - path: "src/declare-tools.js"
      provides: "CLI dispatch for all subcommands"
    - path: "dist/declare-tools.cjs"
      provides: "Bundled CLI tool"
  key_links:
    - from: "src/commands/add-declaration.js"
      to: "src/artifacts/future.js"
      via: "parseFutureFile + writeFutureFile"
      pattern: "require.*artifacts/future"
    - from: "src/commands/add-milestone.js"
      to: "src/artifacts/milestones.js"
      via: "parseMilestonesFile + writeMilestonesFile"
      pattern: "require.*artifacts/milestones"
    - from: "src/commands/add-milestone.js"
      to: "src/artifacts/future.js"
      via: "Updates FUTURE.md milestone list for cross-ref integrity"
      pattern: "writeFutureFile"
    - from: "src/declare-tools.js"
      to: "src/commands/add-declaration.js"
      via: "require + dispatch switch"
      pattern: "case 'add-declaration'"
---

<objective>
Implement four new declare-tools.cjs subcommands for atomic graph mutations and graph loading, with TDD.

Purpose: The agent-driven slash commands (/declare:future and /declare:derive) need CLI tools to persist declarations, milestones, and actions to disk. These subcommands handle file I/O, ID generation, cross-reference integrity, and git commits -- keeping the agent prompts focused on conversation, not file manipulation.

Output: Four tested command modules, updated CLI dispatch, rebuilt bundle.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-future-declaration-backward-derivation/02-RESEARCH.md

# Existing modules to build on:
@src/graph/engine.js
@src/artifacts/future.js
@src/artifacts/milestones.js
@src/commands/init.js
@src/commands/status.js
@src/declare-tools.js
@src/git/commit.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement add-declaration, add-milestone, add-action, and load-graph command modules</name>
  <files>
    src/commands/add-declaration.js
    src/commands/add-milestone.js
    src/commands/add-action.js
    src/commands/load-graph.js
  </files>
  <action>
Create four new command modules following the exact pattern of init.js and status.js (CJS, 'use strict', @ts-check, JSDoc, single exported run function returning JSON).

**src/commands/add-declaration.js** -- `runAddDeclaration(cwd, args)`:
- Parse `--title` and `--statement` flags from args array. Both required; return `{ error }` if missing.
- Load FUTURE.md from `.planning/FUTURE.md` using parseFutureFile. If file doesn't exist, start with empty array.
- Build a DeclareDag from existing declarations to get nextId('declaration').
- Append new declaration: `{ id, title, statement, status: 'PENDING', milestones: [] }`.
- Write FUTURE.md via writeFutureFile with projectName from basename(cwd).
- If config.json has commit_docs: true, call commitPlanningDocs with message `declare: add ${id} "${title}"` and files `['.planning/FUTURE.md']`.
- Return `{ id, title, statement, status: 'PENDING', committed, hash }`.

**src/commands/add-milestone.js** -- `runAddMilestone(cwd, args)`:
- Parse `--title` and `--realizes` (comma-separated declaration IDs, e.g., "D-01,D-02"). Both required.
- Load FUTURE.md + MILESTONES.md. Build DeclareDag from all nodes to get nextId('milestone').
- Validate that all declaration IDs in --realizes exist; return error if not.
- Create new milestone: `{ id, title, status: 'PENDING', realizes: [...], causedBy: [] }`.
- Update FUTURE.md: for each realized declaration, add the new milestone ID to its milestones array (cross-ref integrity).
- Write BOTH FUTURE.md and MILESTONES.md atomically.
- Commit both files: `declare: add ${id} "${title}"`.
- Return `{ id, title, realizes, status: 'PENDING', committed, hash }`.

**src/commands/add-action.js** -- `runAddAction(cwd, args)`:
- Parse `--title` and `--causes` (comma-separated milestone IDs, e.g., "M-01"). Both required.
- Load MILESTONES.md. Build DeclareDag from all nodes to get nextId('action').
- Validate that all milestone IDs in --causes exist; return error if not.
- Create new action: `{ id, title, status: 'PENDING', causes: [...] }`.
- Update MILESTONES.md: for each caused milestone, add the new action ID to its causedBy array (cross-ref integrity).
- Write MILESTONES.md.
- Commit: `declare: add ${id} "${title}"`.
- Return `{ id, title, causes, status: 'PENDING', committed, hash }`.

**src/commands/load-graph.js** -- `runLoadGraph(cwd)`:
- Check .planning/ exists, return error if not.
- Load FUTURE.md + MILESTONES.md using parseFutureFile + parseMilestonesFile.
- Build DeclareDag from all nodes + edges (same reconstruction logic as status.js).
- Return `{ declarations, milestones, actions, stats: dag.stats(), validation: dag.validate() }`.

**Shared helper: parseFlag(args, flag)**
Create a local utility (in each file or factored into a shared helper) that extracts the value after a given --flag from an args array. The existing parseCwdFlag in declare-tools.js is a model but only handles --cwd. Write a generic version. If factoring into a shared file, put it in `src/commands/parse-args.js`.

**Config-awareness for commits:**
Read `.planning/config.json` to check commit_docs. If file missing or commit_docs is not explicitly false, default to committing (same as init.js implicit behavior).
  </action>
  <verify>
    node -e "const m = require('./src/commands/add-declaration.js'); console.log(typeof m.runAddDeclaration)"
    node -e "const m = require('./src/commands/add-milestone.js'); console.log(typeof m.runAddMilestone)"
    node -e "const m = require('./src/commands/add-action.js'); console.log(typeof m.runAddAction)"
    node -e "const m = require('./src/commands/load-graph.js'); console.log(typeof m.runLoadGraph)"
  </verify>
  <done>All four modules export their run function and can be required without errors. Each follows the CJS + JSDoc + 'use strict' pattern established by init.js.</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for all four commands using node:test + node:assert</name>
  <files>
    src/commands/commands.test.js
  </files>
  <action>
Create a comprehensive test file following the pattern of `src/graph/engine.test.js` and `src/artifacts/artifacts.test.js` (node:test + node:assert/strict, describe/it blocks).

Use a temp directory (node:fs mkdtempSync + node:os tmpdir) for each test to isolate file system state. Initialize each temp dir with `git init` so commitPlanningDocs works.

**Test cases for add-declaration:**
- Returns error when --title missing
- Returns error when --statement missing
- Creates D-01 in empty FUTURE.md
- Auto-increments to D-02 when D-01 exists
- Returns correct JSON shape { id, title, statement, status, committed }
- FUTURE.md on disk contains the new declaration after call

**Test cases for add-milestone:**
- Returns error when --title missing
- Returns error when --realizes missing
- Returns error when realizes references non-existent declaration
- Creates M-01 linked to D-01
- Updates FUTURE.md milestones field on the realized declaration
- Both FUTURE.md and MILESTONES.md updated atomically

**Test cases for add-action:**
- Returns error when --title missing
- Returns error when --causes missing
- Returns error when causes references non-existent milestone
- Creates A-01 linked to M-01
- Updates MILESTONES.md causedBy field on the caused milestone

**Test cases for load-graph:**
- Returns error when .planning/ doesn't exist
- Returns empty graph for initialized but empty project
- Returns populated graph with declarations, milestones, actions, stats, validation
- Validation errors surfaced for orphan milestones

Run tests with: `node --test src/commands/commands.test.js`
  </action>
  <verify>node --test src/commands/commands.test.js</verify>
  <done>All tests pass. Coverage includes happy path, error cases, ID auto-increment, cross-reference integrity, and config-aware commits.</done>
</task>

<task type="auto">
  <name>Task 3: Update CLI dispatch and rebuild bundle</name>
  <files>
    src/declare-tools.js
    dist/declare-tools.cjs
  </files>
  <action>
**Update src/declare-tools.js:**

1. Add require statements for the four new command modules at the top:
   ```
   const { runAddDeclaration } = require('./commands/add-declaration');
   const { runAddMilestone } = require('./commands/add-milestone');
   const { runAddAction } = require('./commands/add-action');
   const { runLoadGraph } = require('./commands/load-graph');
   ```

2. Add four new cases to the switch statement:

   `add-declaration`: Parse --cwd or use process.cwd(). Pass remaining args to runAddDeclaration(cwd, args.slice(1)). Print JSON result.

   `add-milestone`: Same pattern, call runAddMilestone(cwd, args.slice(1)).

   `add-action`: Same pattern, call runAddAction(cwd, args.slice(1)).

   `load-graph`: Parse --cwd or use process.cwd(). Call runLoadGraph(cwd). Print JSON result.

3. Update the error message for unknown commands to include the new subcommands in the usage string.

4. Update the JSDoc header comment to list all available commands.

**Rebuild bundle:**
```bash
node esbuild.config.js
```

**Verify bundle works:**
```bash
node dist/declare-tools.cjs help
node dist/declare-tools.cjs load-graph 2>&1 || true
```
  </action>
  <verify>
    node dist/declare-tools.cjs help
    node dist/declare-tools.cjs add-declaration --title "test" --statement "test" 2>&1 | head -1
  </verify>
  <done>The bundled dist/declare-tools.cjs dispatches all four new subcommands. `help` output lists all commands. Bundle is a single file with no external dependencies.</done>
</task>

</tasks>

<verification>
1. `node --test src/commands/commands.test.js` -- all tests pass
2. `node dist/declare-tools.cjs add-declaration --title "Test" --statement "Test truth"` -- returns JSON with D-01
3. `node dist/declare-tools.cjs add-milestone --title "Test MS" --realizes D-01` -- returns JSON with M-01
4. `node dist/declare-tools.cjs add-action --title "Test action" --causes M-01` -- returns JSON with A-01
5. `node dist/declare-tools.cjs load-graph` -- returns JSON with 1 declaration, 1 milestone, 1 action, valid graph
6. `node dist/declare-tools.cjs help` -- lists all 8 subcommands
</verification>

<success_criteria>
Four new declare-tools.cjs subcommands (add-declaration, add-milestone, add-action, load-graph) are implemented, tested, and bundled. Each produces correct JSON output, maintains cross-reference integrity between FUTURE.md and MILESTONES.md, auto-increments IDs, and commits atomically when configured.
</success_criteria>

<output>
After completion, create `.planning/phases/02-future-declaration-backward-derivation/02-01-SUMMARY.md`
</output>
