---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/artifacts/future.js
  - src/artifacts/milestones.js
  - src/artifacts/artifacts.test.js
  - src/git/commit.js
  - src/declare-tools.js
  - templates/future.md
  - templates/milestones.md
autonomous: true

must_haves:
  truths:
    - "System can parse a hand-edited FUTURE.md into declaration nodes with IDs, statements, statuses, and linked milestones"
    - "System can parse a hand-edited MILESTONES.md into milestone and action nodes with edges"
    - "System can write a DeclareDag back to FUTURE.md and MILESTONES.md in canonical format"
    - "Round-trip (parse -> load into graph -> write back) preserves all data"
    - "declare-tools.cjs entry point dispatches subcommands"
    - "Git commit utility stages specific files and creates atomic commits"
  artifacts:
    - path: "src/artifacts/future.js"
      provides: "parseFutureFile and writeFutureFile functions"
      exports: ["parseFutureFile", "writeFutureFile"]
    - path: "src/artifacts/milestones.js"
      provides: "parseMilestonesFile and writeMilestonesFile functions"
      exports: ["parseMilestonesFile", "writeMilestonesFile"]
    - path: "src/artifacts/artifacts.test.js"
      provides: "Tests for parse/write round-trips and permissive parsing"
      min_lines: 80
    - path: "src/git/commit.js"
      provides: "commitPlanningDocs function for atomic git commits"
      exports: ["commitPlanningDocs"]
    - path: "src/declare-tools.js"
      provides: "CLI entry point with subcommand dispatch"
      exports: []
    - path: "templates/future.md"
      provides: "Empty FUTURE.md template"
    - path: "templates/milestones.md"
      provides: "Empty MILESTONES.md template"
  key_links:
    - from: "src/artifacts/future.js"
      to: "src/graph/engine.js"
      via: "uses DeclareDag to reconstruct graph from parsed data"
      pattern: "require.*graph/engine"
    - from: "src/artifacts/milestones.js"
      to: "src/graph/engine.js"
      via: "uses DeclareDag node types for validation"
      pattern: "require.*graph/engine"
    - from: "src/declare-tools.js"
      to: "src/git/commit.js"
      via: "commit subcommand delegates to commitPlanningDocs"
      pattern: "require.*git/commit"
---

<objective>
Build the artifact persistence layer (FUTURE.md and MILESTONES.md parsers/writers) and the declare-tools.cjs CLI scaffolding.

Purpose: The graph engine from Plan 01 operates in memory. This plan connects it to disk via markdown files, creating the "parse on load, write on save" cycle that is the core persistence mechanism. It also creates the CLI entry point that slash commands will invoke.

Output: Working parsers/writers for both artifact files, templates, git commit utility, and declare-tools.js entry point.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Artifact parsers, writers, and templates</name>
  <files>src/artifacts/future.js, src/artifacts/milestones.js, src/artifacts/artifacts.test.js, templates/future.md, templates/milestones.md</files>
  <action>
**Templates first** -- create the canonical artifact formats:

templates/future.md:
```markdown
# Future: [Project Name]

<!-- Each declaration is a standalone truth statement about the future. -->
<!-- Edit freely -- the system validates on load, not on save. -->
```

templates/milestones.md:
```markdown
# Milestones & Actions: [Project Name]

## Milestones

| ID | Title | Status | Realizes | Caused By |
|----|-------|--------|----------|-----------|

## Actions

| ID | Title | Status | Causes |
|----|-------|--------|--------|
```

**FUTURE.md parser (src/artifacts/future.js):**

`parseFutureFile(content)` -- returns array of declaration objects:
- Split on `## ` (h2 headings) to get sections
- For each section, match ID pattern: `(D-\d+):\s*(.+)` from the heading
- Extract fields with permissive parsing (per RESEARCH pitfall 1):
  - `**Statement:**` -- the truth statement (required)
  - `**Status:**` -- case-insensitive match, default to PENDING
  - `**Milestones:**` -- comma-separated list of M-XX IDs
- Trim whitespace everywhere, skip sections that don't match the ID pattern
- Return: `[{ id, title, statement, status, milestones: string[] }]`

`writeFutureFile(declarations, projectName)` -- returns markdown string:
- Write header: `# Future: ${projectName}`
- For each declaration, write a section card:
  ```
  ## D-01: [Title]
  **Statement:** [statement]
  **Status:** ACTIVE
  **Milestones:** M-01, M-02
  ```
- Always write in canonical format (strict output)

**MILESTONES.md parser (src/artifacts/milestones.js):**

`parseMilestonesFile(content)` -- returns { milestones: [...], actions: [...] }:
- Split content on `## Milestones` and `## Actions` sections
- Parse each section as a markdown table using the parseMarkdownTable helper (from RESEARCH Pattern 2)
- For milestones: extract ID, Title, Status, Realizes (comma-sep D-XX list), Caused By (comma-sep A-XX list)
- For actions: extract ID, Title, Status, Causes (comma-sep M-XX list)
- Permissive: handle extra whitespace, missing columns default to empty, case-insensitive status
- Return structured objects with arrays for multi-value fields (split on comma, trim)

`writeMilestonesFile(milestones, actions, projectName)` -- returns markdown string:
- Write header, then two table sections
- Pad columns for alignment (use a simple pad helper)
- Always write canonical format

Helper: `parseMarkdownTable(text)` -- generic markdown table parser (see RESEARCH code example). Returns array of row objects keyed by header names.

**Tests (src/artifacts/artifacts.test.js):**

Using node:test + node:assert/strict:

1. parseFutureFile with canonical format returns correct declarations
2. parseFutureFile with hand-edited format (extra spaces, lowercase status, missing milestones field) still parses
3. parseFutureFile with empty file returns empty array
4. writeFutureFile produces canonical format
5. Round-trip: writeFutureFile(parseFutureFile(canonical)) === canonical (normalized)
6. parseMilestonesFile with canonical format returns correct milestones and actions
7. parseMilestonesFile with hand-edited table (extra spaces, misaligned columns) still parses
8. parseMilestonesFile with empty tables returns empty arrays
9. writeMilestonesFile produces canonical format with aligned columns
10. Round-trip: write(parse(canonical)) preserves data
11. Full integration: create DeclareDag, write to files, parse back, load into new DeclareDag -- graph is equivalent
12. Parse multi-value fields: "M-01, M-02" -> ["M-01", "M-02"] and "M-01,M-02" (no space) also works

Export from each module: the parse and write functions.
  </action>
  <verify>
- `node --test src/artifacts/artifacts.test.js` -- all tests pass
- `node -e "const f = require('./src/artifacts/future'); console.log(typeof f.parseFutureFile, typeof f.writeFutureFile)"` prints "function function"
- `node -e "const m = require('./src/artifacts/milestones'); console.log(typeof m.parseMilestonesFile, typeof m.writeMilestonesFile)"` prints "function function"
  </verify>
  <done>FUTURE.md and MILESTONES.md can be parsed (permissively) and written (strictly). Round-trip preserves all data. Templates exist for initialization. 12 test cases pass.</done>
</task>

<task type="auto">
  <name>Task 2: declare-tools.js entry point and git commit utility</name>
  <files>src/declare-tools.js, src/git/commit.js</files>
  <action>
**Git commit utility (src/git/commit.js):**

Fork the pattern from GSD's gsd-tools.cjs commit functionality. Implement:

`commitPlanningDocs(cwd, message, files)`:
- Read config from `.planning/config.json` (if exists) for `commit_docs` setting. Default to true.
- If `commit_docs` is false, return `{ committed: false, reason: 'skipped_config' }`
- Check if `.planning` is gitignored: `git check-ignore .planning` -- if yes, return `{ committed: false, reason: 'skipped_gitignored' }`
- Stage specific files: `git add <file>` for each file in the array. If files is empty, stage `.planning/`
- Commit: `git commit -m <message>`
- Handle "nothing to commit" gracefully
- Return `{ committed: true, hash: <short-hash> }` on success
- Use `child_process.execSync` for all git operations, with `{ cwd, encoding: 'utf-8' }`

Helper: `execGit(cwd, args)` -- wraps execSync with error handling, returns { exitCode, stdout, stderr }

`loadConfig(cwd)`:
- Read `.planning/config.json` if it exists
- Return parsed JSON or defaults: `{ commit_docs: true }`

Export: `module.exports = { commitPlanningDocs, loadConfig }`

**CLI entry point (src/declare-tools.js):**

Subcommand dispatch pattern (fork from GSD's gsd-tools.cjs main function):

```
Usage: node declare-tools.cjs <command> [args...]

Commands:
  commit <message> --files <file1> [file2...]  - Atomic git commit for planning docs
  init                                          - (stub) Initialize project
  status                                        - (stub) Show graph status
  help                                          - (stub) Show help
```

Implementation:
- Parse process.argv for command name
- Switch on command: 'commit' delegates to commitPlanningDocs, others print "not yet implemented" (stubs for Plan 03)
- For 'commit': parse --files flag (everything after --files until next flag or end)
- Print JSON result to stdout (for machine consumption by slash commands)
- Handle errors: try/catch, print `{ error: message }` to stdout on failure
- Exit with code 0 on success, 1 on error

Do NOT add init/status/help implementation -- those come in Plan 03. Just register the subcommand names so the dispatch structure is ready.
  </action>
  <verify>
- `node src/declare-tools.js commit "test: verify commit utility" --files .planning/STATE.md` -- prints JSON with committed status (may be true or "nothing_to_commit")
- `node src/declare-tools.js help` -- prints "not yet implemented" or stub message
- `node -e "const g = require('./src/git/commit'); console.log(typeof g.commitPlanningDocs)"` prints "function"
  </verify>
  <done>declare-tools.js dispatches subcommands. Git commit utility creates atomic commits for planning docs. Commit respects config.json settings and handles edge cases (nothing to commit, gitignored).</done>
</task>

</tasks>

<verification>
- `node --test src/artifacts/artifacts.test.js` passes all tests
- `node src/declare-tools.js commit "test" --files .planning/STATE.md` returns JSON
- Templates exist at templates/future.md and templates/milestones.md
- Round-trip test: parse canonical format -> write back -> output matches input
</verification>

<success_criteria>
- Artifact persistence layer can load and save the graph as human-readable markdown
- Permissive parsing handles hand-edited files without breaking
- declare-tools.js entry point ready for slash command invocation
- Git commit utility creates atomic commits respecting config
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
