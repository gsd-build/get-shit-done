---
phase: 03-traceability-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/commands/build-dag.js
  - src/commands/load-graph.js
  - src/commands/status.js
  - src/commands/trace.js
  - src/commands/prioritize.js
  - src/declare-tools.js
autonomous: true
requirements:
  - DAG-06
  - DAG-08

must_haves:
  truths:
    - "trace subcommand returns all upward paths from any node to its root declarations"
    - "trace handles multi-path scenarios (action serving multiple milestones)"
    - "prioritize subcommand ranks actions by dependency weight (unblocking power)"
    - "prioritize supports filtering by declaration subtree"
    - "shared buildDagFromDisk eliminates graph-loading duplication across commands"
  artifacts:
    - path: "src/commands/build-dag.js"
      provides: "Shared graph loading from FUTURE.md + MILESTONES.md + milestone folders"
      exports: ["buildDagFromDisk"]
    - path: "src/commands/trace.js"
      provides: "Why-chain traversal returning all paths from node to declarations"
      exports: ["runTrace"]
    - path: "src/commands/prioritize.js"
      provides: "Dependency-weight scoring and ranking of actions"
      exports: ["runPrioritize"]
  key_links:
    - from: "src/commands/trace.js"
      to: "src/commands/build-dag.js"
      via: "buildDagFromDisk import"
      pattern: "require.*build-dag"
    - from: "src/commands/prioritize.js"
      to: "src/commands/build-dag.js"
      via: "buildDagFromDisk import"
      pattern: "require.*build-dag"
    - from: "src/commands/load-graph.js"
      to: "src/commands/build-dag.js"
      via: "refactored to use shared loader"
      pattern: "require.*build-dag"
    - from: "src/commands/status.js"
      to: "src/commands/build-dag.js"
      via: "refactored to use shared loader"
      pattern: "require.*build-dag"
    - from: "src/declare-tools.js"
      to: "src/commands/trace.js"
      via: "subcommand dispatch"
      pattern: "case 'trace'"
---

<objective>
Extract shared graph loading, implement trace and prioritize commands

Purpose: Create the tool-layer foundation for Phase 3's traceability and prioritization features. The shared buildDagFromDisk utility eliminates the graph-loading duplication identified across load-graph.js and status.js (and prevents 3 more copies in Phase 3 commands). The trace command enables why-chain traversal (DAG-06) and the prioritize command enables impact-based ordering (DAG-08).

Output: Three new source files (build-dag.js, trace.js, prioritize.js), two refactored files (load-graph.js, status.js), updated CLI dispatch, rebuilt bundle.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-traceability-navigation/03-RESEARCH.md
@src/commands/load-graph.js
@src/commands/status.js
@src/commands/parse-args.js
@src/declare-tools.js
@src/graph/engine.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared buildDagFromDisk and refactor existing commands</name>
  <files>src/commands/build-dag.js, src/commands/load-graph.js, src/commands/status.js</files>
  <action>
Create `src/commands/build-dag.js` that extracts the repeated graph-loading pattern from load-graph.js and status.js into a single shared utility:

```javascript
/**
 * buildDagFromDisk(cwd) -> { dag, declarations, milestones, actions } | { error }
 */
```

The function must:
1. Check for `.planning/` directory existence (return error if missing)
2. Read and parse FUTURE.md via parseFutureFile
3. Read and parse MILESTONES.md via parseMilestonesFile
4. Load actions from milestone folders via loadActionsFromFolders (import from load-graph.js)
5. Build DeclareDag: add all nodes, add milestone->declaration edges (realizes), add action->milestone edges (causes)
6. Return `{ dag, declarations, milestones, actions }`

Then refactor:

**load-graph.js:** Keep `loadActionsFromFolders` (it's used by build-dag.js and status.js). Replace the inline DAG building in `runLoadGraph` with a call to `buildDagFromDisk(cwd)`. Return the same shape: `{ declarations, milestones, actions, stats, validation }`.

**status.js:** Remove all inline artifact parsing and DAG construction (lines ~92-135). Replace with `const graphResult = buildDagFromDisk(cwd);` plus `if (graphResult.error) return graphResult;`. Keep all status-specific logic (staleness detection, coverage, health computation) untouched. Import `buildDagFromDisk` from `./build-dag`. Remove now-unused imports (parseFutureFile, parseMilestonesFile, DeclareDag, readFileSync for artifacts).

Follow existing patterns: 'use strict', @ts-check, JSDoc annotations, CJS module.exports.
  </action>
  <verify>
Run existing tests to confirm no regressions: `cd /Users/guilherme/Projects/get-shit-done && node --test src/commands/commands.test.js`

Then verify the refactored commands still work: `node src/declare-tools.js load-graph` and `node src/declare-tools.js status` should return valid JSON (may show "No Declare project" error if no .planning/ exists -- that's fine, it means the command runs).
  </verify>
  <done>
build-dag.js exists and exports buildDagFromDisk. load-graph.js and status.js both import from build-dag.js instead of duplicating graph construction. All existing tests pass. load-graph and status subcommands produce identical output to before the refactor.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement trace and prioritize commands, wire into CLI, rebuild bundle</name>
  <files>src/commands/trace.js, src/commands/prioritize.js, src/declare-tools.js</files>
  <action>
**trace.js** - Implement `runTrace(cwd, args)`:

1. Parse args: `nodeId` = first positional arg or `parseFlag(args, 'node')`. `outputFile` = `parseFlag(args, 'output')`.
2. Call `buildDagFromDisk(cwd)` to load graph. Return error if graph fails to load.
3. If no nodeId provided, return a node list grouped by type (declarations, milestones, actions) with their IDs and titles -- this feeds the interactive picker in the slash command.
4. Validate nodeId exists in DAG. Return error if not found.
5. Implement `traceUpward(dag, startId)` per research Pattern 1:
   - Recursive upward traversal via `dag.getUpstream(id)`
   - Returns array of paths, each path = array of `{id, type, title, status}`
   - Declarations are endpoints (no upstream)
   - Orphan nodes return single-node path
   - Max recursion depth is 3 (bounded by 3-layer DAG)
6. Add path limit: if > 20 paths, truncate and include `truncated: true, totalPaths: N`.
7. Format output for `--output` file write: render paths as tree connectors (per user decision). Use plain text/Unicode, no ANSI colors.
8. If `outputFile`, write formatted text via `fs.writeFileSync(path.resolve(cwd, outputFile))`.
9. Return JSON: `{ nodeId, node, paths, pathCount, truncated?, formatted }`.

**prioritize.js** - Implement `runPrioritize(cwd, args)`:

1. Parse args: `filterDeclaration` = `parseFlag(args, 'declaration')`. `outputFile` = `parseFlag(args, 'output')`.
2. Call `buildDagFromDisk(cwd)` to load graph.
3. Implement `dependencyWeight(dag, nodeId)` per research Pattern 2:
   - BFS upward from nodeId via `dag.getUpstream()`
   - Count unique nodes reachable (excluding self)
   - Return count as score
4. Implement `getSubtreeNodeIds(dag, rootId)` per research Pattern 3:
   - BFS downward from rootId via `dag.getDownstream()`
   - Returns Set of all node IDs in subtree
5. Implement `rankActions(dag, filterDeclarationId?)`:
   - Get all actions from DAG (or filter to subtree if declaration provided)
   - Compute dependencyWeight for each
   - Sort descending by score, then by ID for stability
   - Return ranked array: `[{ rank, id, title, score }]`
6. If `outputFile`, write formatted ranked list as plain text.
7. Return JSON: `{ ranking, filter, totalActions }`.

**declare-tools.js** - Add two new case blocks in the switch:

```javascript
case 'trace': {
  const cwd = parseCwdFlag(args) || process.cwd();
  const result = runTrace(cwd, args.slice(1));
  console.log(JSON.stringify(result));
  if (result.error) process.exit(1);
  break;
}
case 'prioritize': {
  const cwd = parseCwdFlag(args) || process.cwd();
  const result = runPrioritize(cwd, args.slice(1));
  console.log(JSON.stringify(result));
  if (result.error) process.exit(1);
  break;
}
```

Add imports at top for runTrace and runPrioritize. Update the error message listing available commands to include 'trace' and 'prioritize'.

**Rebuild bundle:** Run `node esbuild.config.js` to rebuild `dist/declare-tools.cjs`.

Follow existing patterns: CJS, 'use strict', @ts-check, JSDoc, parseFlag from parse-args.js.
  </action>
  <verify>
Test trace: `node src/declare-tools.js trace` (should return node list or error if no project).
Test trace with ID: `node src/declare-tools.js trace A-01` (should return paths or "node not found").
Test prioritize: `node src/declare-tools.js prioritize` (should return ranking or error).
Test prioritize with filter: `node src/declare-tools.js prioritize --declaration D-01`.
Verify bundle builds: `node esbuild.config.js` exits 0.
Verify bundle works: `node dist/declare-tools.cjs trace` and `node dist/declare-tools.cjs prioritize`.
  </verify>
  <done>
trace subcommand returns structured JSON with all upward paths for a given node ID. When called without args, returns grouped node list for interactive picker. prioritize subcommand returns ranked action list with dependency-weight scores. Both support --output flag for file writes. Both support --declaration filter (prioritize) and --node (trace). Bundle rebuilt successfully.
  </done>
</task>

</tasks>

<verification>
1. `node --test src/commands/commands.test.js` -- all existing tests pass (no regressions from refactor)
2. `node src/declare-tools.js load-graph` -- returns same JSON structure as before refactor
3. `node src/declare-tools.js status` -- returns same JSON structure as before refactor
4. `node src/declare-tools.js trace` -- returns node list or appropriate error
5. `node src/declare-tools.js prioritize` -- returns ranking or appropriate error
6. `node dist/declare-tools.cjs trace` -- bundled version works
7. `node dist/declare-tools.cjs prioritize` -- bundled version works
8. `grep -c "parseFutureFile" src/commands/status.js` returns 0 (duplication eliminated)
</verification>

<success_criteria>
- buildDagFromDisk shared utility exists and is used by load-graph.js, status.js, trace.js, and prioritize.js
- trace command returns all upward paths (multi-path support for many-to-many edges)
- prioritize command ranks actions by dependency weight with optional declaration filter
- Both commands support --output flag for file writing
- Bundle rebuilt with new commands wired in
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/03-traceability-navigation/03-01-SUMMARY.md`
</output>
