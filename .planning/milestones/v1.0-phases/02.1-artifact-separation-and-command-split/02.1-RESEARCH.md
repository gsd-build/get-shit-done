# Phase 02.1: Artifact Separation and Command Split - Research

**Researched:** 2026-02-16
**Domain:** Artifact restructuring, folder-based plans, command split, staleness detection
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Folder structure
- Milestone folders live in `.planning/milestones/`
- Naming convention: ID + slug (e.g., `M001-user-auth/`)
- Each folder contains PLAN.md (the actions/plan for that milestone) plus execution artifacts (summaries, logs generated during execution)
- MILESTONES.md (flat file) and folders are dual-maintained: MILESTONES.md holds milestone metadata (status, cross-refs), folders hold plan and execution artifacts. Both are authoritative for their respective concerns.

#### Migration path
- No production data to migrate -- still in dev/testing
- Fresh start: strip actions from MILESTONES.md, keep existing milestones
- Actions will be re-derived through /declare:actions into the new folder structure
- Old test data can be discarded

#### Command behavior: /declare:milestones
- Derives milestones **per declaration** (one declaration at a time -> derive -> confirm -> next)
- Confirmation uses AskUserQuestion multi-select checkboxes -- user checks which milestones to accept
- Only derives milestones, no actions (actions are /declare:actions)

#### Command behavior: /declare:actions
- Two modes: `/declare:actions` (no args) = derive plans for all milestones missing one (happy path); `/declare:actions M001` = target a specific milestone
- Presents derived plan for approval before writing PLAN.md to the milestone folder
- Creates the milestone folder if it doesn't exist yet

#### Living sync model (partial)
- When a declaration changes, /declare:milestones flags inconsistencies with existing milestones -- user decides what to update (not automatic reconciliation)
- When a milestone is removed, its folder is archived to `.planning/milestones/_archived/`
- /declare:status enhanced with basic health view: milestone coverage, plan status, staleness indicators
- Full sync logic (automatic reconciliation, drift detection) deferred to later phases

### Claude's Discretion
- PLAN.md format inside milestone folders
- Exact staleness detection heuristics for /declare:status
- How inconsistency flagging presents to the user
- Internal data structures for cross-reference tracking

### Deferred Ideas (OUT OF SCOPE)
- Rich web UI for browsing/editing the declaration -> milestone -> action structure -- future phase
- Full automatic reconciliation when declarations change -- later phase (this phase builds structure that enables it)
- Drift detection (actions with no causation path) -- Phase 6
</user_constraints>

## Summary

This phase restructures Declare's artifact layer from a flat two-file model (FUTURE.md + MILESTONES.md containing both milestones and actions) into a folder-based model where MILESTONES.md holds only milestone metadata and each milestone gets its own folder (`.planning/milestones/M001-slug/`) containing a PLAN.md with actions. The existing `/declare:milestones` command is rewritten to only derive milestones (with checkbox confirmation UI), and a new `/declare:actions` command is introduced to derive action plans per milestone.

The implementation requires changes across all layers: artifact parsers/writers, CLI subcommands, slash commands, workflows, and the graph loader. The DAG engine itself needs no changes -- it already handles declarations, milestones, and actions as node types. The primary work is in the persistence layer (where actions live on disk), the command layer (splitting the combined derive workflow into two commands), and the status command (adding staleness/coverage indicators).

This is a codebase-internal restructuring phase. No new external libraries are needed. All changes use established patterns: CJS modules, JSDoc types, `node:fs` for file I/O, `node:test` for testing, esbuild for bundling.

**Primary recommendation:** Implement in three plans: (1) artifact layer changes (MILESTONES.md rewrite, folder structure, PLAN.md parser/writer, load-graph update), (2) CLI subcommand changes (new `create-plan` or modified `add-action`, milestone folder management), (3) slash command and workflow rewrites (`/declare:milestones` with checkbox UI, new `/declare:actions`, `/declare:status` with staleness).

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| node:fs | Node 18+ | File I/O for milestones folders, PLAN.md read/write | Already used by all artifact modules |
| node:path | Node 18+ | Path construction for milestone folder paths | Already used everywhere |
| node:test | Node 18+ | Test framework | Already used for all existing tests |
| esbuild | 0.24.2 | CJS bundling | Already in devDependencies, used for dist/declare-tools.cjs |

### Supporting
No new libraries needed. This phase uses only what already exists in the project.

### Alternatives Considered
None -- this is purely internal restructuring using established patterns.

**Installation:**
```bash
# No new dependencies needed
```

## Architecture Patterns

### Current Project Structure
```
src/
  artifacts/
    future.js          # FUTURE.md parser/writer
    milestones.js      # MILESTONES.md parser/writer (currently: milestones + actions)
    artifacts.test.js  # Tests for both parsers
  graph/
    engine.js          # DeclareDag (unchanged by this phase)
    engine.test.js     # DAG tests
  commands/
    parse-args.js      # Shared parseFlag utility
    init.js            # /declare:init logic
    status.js          # /declare:status logic
    add-declaration.js # Add D-XX to FUTURE.md
    add-milestone.js   # Add M-XX to MILESTONES.md
    add-action.js      # Add A-XX to MILESTONES.md (will change target)
    load-graph.js      # Load full DAG from disk
    help.js            # Help text
    commands.test.js   # Integration tests
  git/
    commit.js          # Atomic git commit utility
  declare-tools.js     # CLI entry point (dispatch)
workflows/
  future.md            # Declaration capture conversation logic
  milestones.md        # Backward derivation conversation logic (currently combined milestones+actions)
commands/declare/      # User-level slash commands (installed to ~/.claude/commands/declare/)
  init.md
  status.md
  help.md
  future.md
  milestones.md        # Currently handles both milestones and actions derivation
dist/
  declare-tools.cjs    # Bundled CLI
```

### Target Structure After This Phase
```
src/
  artifacts/
    future.js          # FUTURE.md parser/writer (unchanged)
    milestones.js      # MILESTONES.md parser/writer (MODIFIED: milestones only, no actions table)
    plan.js            # NEW: PLAN.md parser/writer for milestone folders
    artifacts.test.js  # Tests updated for new structure
  commands/
    add-milestone.js   # MODIFIED: also creates milestone folder
    add-action.js      # REMOVED or REPURPOSED (actions now live in PLAN.md, not flat file)
    create-plan.js     # NEW: writes PLAN.md to milestone folder
    load-graph.js      # MODIFIED: reads from FUTURE.md + MILESTONES.md + milestone folders
    status.js          # MODIFIED: adds staleness/coverage indicators
    ...rest unchanged
  declare-tools.js     # MODIFIED: update dispatch for new/changed subcommands
workflows/
  milestones.md        # MODIFIED: milestones-only derivation with checkbox UI
  actions.md           # NEW: action plan derivation per milestone
commands/declare/
  milestones.md        # MODIFIED: milestones-only, checkbox confirmation
  actions.md           # NEW: /declare:actions command
  status.md            # MODIFIED: renders staleness indicators
```

### Pattern 1: Milestone Folder Convention
**What:** Each milestone gets a folder in `.planning/milestones/` named `{ID}-{slug}/` containing PLAN.md and execution artifacts.
**When to use:** When creating a milestone or deriving its plan.
**Details:**
- ID format uses zero-padded three digits: `M001`, `M002`, etc. (context says `M001-user-auth/`)
- NOTE: The current DAG engine uses `M-01` format (with hyphen, two digits). The folder convention uses `M001` (no hyphen, three digits). This discrepancy needs resolution.
- Slug is derived from the milestone title: lowercase, hyphens for spaces, strip special chars
- Folder created on `add-milestone` or on first `create-plan` (whichever comes first)

**ID Format Decision Needed:**
The current codebase uses `M-01` (prefix-hyphen-twodigit) for milestone IDs everywhere: DAG engine, parsers, writers, cross-references. The context decision uses `M001` (prefix-threedigit-no-hyphen) for folder names. Two options:
1. **Folder names use normalized form** -- milestone ID stays `M-01` in all data, folder is named `M-01-user-auth/` (keep consistency)
2. **Folder names use context form** -- milestone ID stays `M-01` in data, folder is named `M001-user-auth/` (requires ID-to-folder mapping)

**Recommendation:** Option 1 -- use `M-01-slug/` for folders. This avoids a mapping layer and keeps IDs consistent everywhere. The context's `M001` was likely illustrative rather than prescriptive. If the user wants `M001`, a simple conversion function (`M-01` -> `M001`) would suffice.

### Pattern 2: PLAN.md Format (Claude's Discretion)
**What:** The format of PLAN.md inside each milestone folder.
**Recommendation:** Follow a lightweight structure that serves the use case -- it's read by Claude during execution, written by the actions derivation workflow.

```markdown
# Plan: M-01 -- [Milestone Title]

**Milestone:** M-01
**Realizes:** D-01, D-02
**Status:** PENDING
**Derived:** 2026-02-16

## Actions

### A-01: [Action Title]
**Status:** PENDING
**Produces:** [What artifact or state change this action creates]
[Optional description paragraph]

### A-02: [Action Title]
**Status:** PENDING
**Produces:** [What artifact or state change this action creates]
[Optional description paragraph]
```

**Why this format:**
- Section-per-action (not table) allows richer descriptions when needed
- Machine-parseable with the same section-splitting pattern used by `future.js`
- Human-readable and editable
- Each action has an ID for cross-referencing (uses DAG's A-XX format)
- `Produces` field makes verification checkable
- Status is per-action so partial progress is visible

### Pattern 3: Dual Authority Model
**What:** MILESTONES.md and milestone folders are both authoritative for their respective concerns.
**MILESTONES.md owns:** Milestone metadata -- ID, title, status, realizes (which declarations), causedBy (summary of action IDs from PLAN.md).
**Milestone folders own:** Plan content -- action details, descriptions, execution artifacts.
**Sync rule:** When PLAN.md is written/updated, the action IDs are reflected back to MILESTONES.md's `Caused By` column. When a milestone status changes in MILESTONES.md, the PLAN.md header status is updated too.

### Pattern 4: Command Module Pattern (Established)
**What:** All command modules follow: parseFlag for args -> load artifacts -> build DAG for nextId -> mutate -> write -> commit.
**Example:** See `src/commands/add-milestone.js` for the canonical pattern.
**For new commands:** `create-plan.js` follows the same pattern but writes to a milestone folder instead of a flat file.

### Pattern 5: Checkbox Confirmation via AskUserQuestion
**What:** `/declare:milestones` uses Claude Code's `AskUserQuestion` tool with multi-select checkboxes for milestone confirmation.
**How:** The slash command markdown instructs Claude to present derived milestones as checkbox options. This is a prompt-level pattern -- the `.md` workflow file describes how to format the AskUserQuestion call.
**Note:** AskUserQuestion is a Claude Code built-in tool. The command `.md` file lists it in `allowed-tools` and the workflow instructs Claude to use it.

### Anti-Patterns to Avoid
- **Don't duplicate action data:** Actions live in PLAN.md files. MILESTONES.md only has action ID references in `Caused By`. Never store full action details in both places.
- **Don't auto-reconcile:** When inconsistencies are found between declarations and milestones, FLAG them for the user. Do not auto-fix. This is a locked decision.
- **Don't break existing ID format:** The DAG engine validates `M-XX` format with regex `/^[DMA]-\d+$/`. If folder naming uses a different format, use a conversion function, not a DAG change.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Slug generation | Complex slug library | Simple regex: `title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')` | Only used for folder names, no i18n needed |
| Markdown parsing | Full markdown AST parser | Regex-based section splitting (same as `future.js`) | Already proven pattern in codebase |
| File watching for staleness | fs.watch/chokidar | Git log timestamps via `execFileSync` | Already used in `status.js`, simple and reliable |
| Multi-select UI | Custom UI library | AskUserQuestion tool (Claude Code built-in) | Available in the Claude Code environment |

**Key insight:** This phase adds no new problem domains. Every pattern needed (file I/O, markdown parsing, git operations, CLI dispatch) already exists in the codebase. The work is restructuring, not inventing.

## Common Pitfalls

### Pitfall 1: Cross-Reference Integrity During Migration
**What goes wrong:** Stripping actions from MILESTONES.md while keeping milestones could break `Caused By` references if not handled carefully.
**Why it happens:** The current `writeMilestonesFile` writes both milestones and actions tables. Removing the actions table means `Caused By` references on milestones point to IDs that no longer exist in MILESTONES.md.
**How to avoid:** During migration, clear the `causedBy` field on all milestones (since actions are being re-derived). The new MILESTONES.md format doesn't need a `Caused By` column at all if actions live in PLAN.md -- or it becomes `Has Plan: yes/no` instead.
**Warning signs:** Validation errors about broken edges after migration.

### Pitfall 2: load-graph Must Read From Multiple Sources
**What goes wrong:** `load-graph` currently reads FUTURE.md + MILESTONES.md. After this phase it must also scan `.planning/milestones/*/PLAN.md` to find actions.
**Why it happens:** Actions move from a single flat file to distributed PLAN.md files across milestone folders.
**How to avoid:** Use `node:fs.readdirSync` to scan `.planning/milestones/` for folders, then read each `PLAN.md`. Build actions array from all PLAN.md files, not from MILESTONES.md.
**Warning signs:** `load-graph` returns 0 actions after migration, or misses actions from specific milestones.

### Pitfall 3: DAG ID Format vs Folder Name Format
**What goes wrong:** If folder names use `M001-slug` but DAG uses `M-01`, conversion bugs cause lookups to fail.
**Why it happens:** Two different naming conventions for the same entity.
**How to avoid:** Pick one convention for folders (recommend `M-01-slug/` to match DAG IDs) and write a single `milestoneIdToFolderPrefix` utility if needed.
**Warning signs:** "Milestone not found" errors when folder exists.

### Pitfall 4: MILESTONES.md Writer Signature Change
**What goes wrong:** `writeMilestonesFile(milestones, actions, projectName)` is called from multiple places. Changing its signature (removing `actions` param) breaks callers.
**Why it happens:** The function currently accepts both milestones and actions arrays.
**How to avoid:** Either keep the signature accepting actions (ignore if empty) for backward compatibility during transition, or update all callers at once. Grep for `writeMilestonesFile` to find all call sites.
**Call sites:** `add-milestone.js`, `add-action.js`, `init.js`, `commands.test.js`, `artifacts.test.js`.
**Warning signs:** Runtime errors about missing arguments.

### Pitfall 5: Tests Must Be Updated Atomically
**What goes wrong:** Changing the milestones parser to no longer return actions breaks existing tests that expect `{ milestones, actions }` return shape.
**Why it happens:** `artifacts.test.js` and `commands.test.js` both test the current combined format.
**How to avoid:** Update tests in the same task as the artifact changes. Never leave tests in a broken state between tasks.
**Warning signs:** Test failures between plan tasks.

### Pitfall 6: Workflow File Must Match Command File
**What goes wrong:** The `.md` command file references a workflow file that doesn't exist or has the wrong structure.
**Why it happens:** Phase 02 established the pattern: `commands/declare/milestones.md` references `workflows/milestones.md` via `@` syntax.
**How to avoid:** When creating `commands/declare/actions.md`, also create `workflows/actions.md`. When modifying `commands/declare/milestones.md`, also update `workflows/milestones.md`.
**Warning signs:** Slash command runs but produces confused output because workflow instructions are missing.

## Code Examples

### Current: parseMilestonesFile returns milestones + actions
```javascript
// Source: src/artifacts/milestones.js (current)
function parseMilestonesFile(content) {
  const milestonesMatch = content.match(/## Milestones\s*\n([\s\S]*?)(?=## Actions|$)/i);
  const actionsMatch = content.match(/## Actions\s*\n([\s\S]*?)$/i);
  // ... returns { milestones, actions }
}
```

### After: parseMilestonesFile returns milestones only
```javascript
// Proposed: src/artifacts/milestones.js (new)
function parseMilestonesFile(content) {
  // No more ## Actions section -- actions live in PLAN.md files
  const milestonesMatch = content.match(/## Milestones\s*\n([\s\S]*?)$/i);
  const milestoneRows = milestonesMatch ? parseMarkdownTable(milestonesMatch[1]) : [];

  const milestones = milestoneRows.map(row => ({
    id: (row['ID'] || '').trim(),
    title: (row['Title'] || '').trim(),
    status: (row['Status'] || 'PENDING').trim().toUpperCase(),
    realizes: splitMultiValue(row['Realizes'] || ''),
    hasPlan: (row['Plan'] || '').trim().toUpperCase() === 'YES',
  })).filter(m => m.id);

  return { milestones };
}
```

### New: PLAN.md parser
```javascript
// Proposed: src/artifacts/plan.js
function parsePlanFile(content) {
  if (!content || !content.trim()) return { milestone: null, actions: [] };

  // Extract milestone ID from header
  const headerMatch = content.match(/^# Plan:\s*(M-\d+)/m);
  const milestoneId = headerMatch ? headerMatch[1] : null;

  // Extract actions from ### sections
  const actionSections = content.split(/^### /m).slice(1);
  const actions = actionSections.map(section => {
    const lines = section.trim().split('\n');
    const headerMatch = lines[0].match(/^(A-\d+):\s*(.+)/);
    if (!headerMatch) return null;
    const [, id, title] = headerMatch;
    const status = extractField(lines, 'Status') || 'PENDING';
    const produces = extractField(lines, 'Produces') || '';
    return { id, title: title.trim(), status: status.toUpperCase(), produces };
  }).filter(Boolean);

  return { milestone: milestoneId, actions };
}
```

### New: Milestone folder utilities
```javascript
// Proposed: src/artifacts/milestone-folders.js
const { existsSync, mkdirSync, readdirSync, readFileSync } = require('node:fs');
const { join } = require('node:path');

function slugify(title) {
  return title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
}

function milestoneFolderName(id, title) {
  return `${id}-${slugify(title)}`;
}

function getMilestoneFolderPath(planningDir, id, title) {
  return join(planningDir, 'milestones', milestoneFolderName(id, title));
}

function ensureMilestoneFolder(planningDir, id, title) {
  const folderPath = getMilestoneFolderPath(planningDir, id, title);
  if (!existsSync(folderPath)) {
    mkdirSync(folderPath, { recursive: true });
  }
  return folderPath;
}

function findMilestoneFolder(planningDir, id) {
  const milestonesDir = join(planningDir, 'milestones');
  if (!existsSync(milestonesDir)) return null;
  const entries = readdirSync(milestonesDir, { withFileTypes: true });
  const folder = entries.find(e => e.isDirectory() && e.name.startsWith(id));
  return folder ? join(milestonesDir, folder.name) : null;
}

function archiveMilestoneFolder(planningDir, id) {
  const folder = findMilestoneFolder(planningDir, id);
  if (!folder) return false;
  const archiveDir = join(planningDir, 'milestones', '_archived');
  mkdirSync(archiveDir, { recursive: true });
  // rename folder into _archived/
  const { renameSync } = require('node:fs');
  const { basename } = require('node:path');
  renameSync(folder, join(archiveDir, basename(folder)));
  return true;
}
```

### Updated: load-graph scanning milestone folders
```javascript
// Proposed: src/commands/load-graph.js (modified section)
const { parsePlanFile } = require('../artifacts/plan');

function loadActionsFromFolders(planningDir) {
  const milestonesDir = join(planningDir, 'milestones');
  if (!existsSync(milestonesDir)) return [];

  const allActions = [];
  const entries = readdirSync(milestonesDir, { withFileTypes: true });

  for (const entry of entries) {
    if (!entry.isDirectory() || entry.name.startsWith('_')) continue;
    const planPath = join(milestonesDir, entry.name, 'PLAN.md');
    if (!existsSync(planPath)) continue;
    const content = readFileSync(planPath, 'utf-8');
    const { milestone, actions } = parsePlanFile(content);
    for (const action of actions) {
      allActions.push({ ...action, causes: milestone ? [milestone] : [] });
    }
  }

  return allActions;
}
```

### Staleness detection heuristic (Claude's Discretion)
```javascript
// Proposed: heuristic for /declare:status
function detectStaleness(planningDir, milestones) {
  const indicators = [];

  for (const m of milestones) {
    const folder = findMilestoneFolder(planningDir, m.id);

    // Milestone without a folder = no plan derived yet
    if (!folder) {
      indicators.push({ milestone: m.id, issue: 'NO_PLAN', detail: 'No plan derived yet' });
      continue;
    }

    const planPath = join(folder, 'PLAN.md');
    if (!existsSync(planPath)) {
      indicators.push({ milestone: m.id, issue: 'NO_PLAN', detail: 'Folder exists but no PLAN.md' });
      continue;
    }

    // Check if PLAN.md has been modified recently via git
    try {
      const lastModified = execFileSync('git', ['log', '-1', '--format=%ct', '--', planPath], {
        cwd: planningDir.replace('/.planning', ''),
        encoding: 'utf-8',
        stdio: ['pipe', 'pipe', 'pipe'],
      }).trim();

      if (lastModified) {
        const ageMs = Date.now() - (parseInt(lastModified, 10) * 1000);
        const ageDays = ageMs / (1000 * 60 * 60 * 24);
        if (ageDays > 30) {
          indicators.push({ milestone: m.id, issue: 'STALE', detail: `Plan not updated in ${Math.floor(ageDays)} days` });
        }
      }
    } catch { /* git not available */ }

    // Milestone is ACTIVE but all actions are DONE
    const plan = parsePlanFile(readFileSync(planPath, 'utf-8'));
    if (m.status === 'ACTIVE' && plan.actions.length > 0 && plan.actions.every(a => a.status === 'DONE')) {
      indicators.push({ milestone: m.id, issue: 'COMPLETABLE', detail: 'All actions done, milestone still ACTIVE' });
    }

    // Milestone is DONE but has PENDING actions
    if (m.status === 'DONE' && plan.actions.some(a => a.status !== 'DONE')) {
      indicators.push({ milestone: m.id, issue: 'INCONSISTENT', detail: 'Milestone marked DONE but has incomplete actions' });
    }
  }

  // Check declaration coverage: declarations with no milestones
  // (this is already partially handled by orphan detection in the DAG)

  return indicators;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Actions in MILESTONES.md | Actions in PLAN.md per milestone folder | This phase | Actions co-located with their milestone context |
| Combined /declare:milestones (milestones + actions) | Split /declare:milestones + /declare:actions | This phase | Cleaner UX, focused commands |
| No staleness detection | Basic staleness in /declare:status | This phase | Proactive health monitoring |

**Deprecated/outdated after this phase:**
- `writeMilestonesFile(milestones, actions, projectName)` -- the `actions` parameter becomes unnecessary
- `add-action` subcommand writing to MILESTONES.md -- actions now written to PLAN.md
- `## Actions` section in MILESTONES.md -- no longer exists

## Open Questions

1. **Milestone ID in folder names: `M-01-slug` vs `M001-slug`?**
   - What we know: DAG engine uses `M-01` format. Context says `M001-user-auth/`.
   - What's unclear: Whether `M001` was a hard requirement or illustrative.
   - Recommendation: Use `M-01-slug/` for consistency. If user wants `M001`, a trivial conversion function works. Flag this to the planner for user confirmation.

2. **Should `add-action` subcommand be removed or repurposed?**
   - What we know: Actions now live in PLAN.md, not MILESTONES.md. The `add-action` subcommand wrote to MILESTONES.md.
   - What's unclear: Whether individual action additions are still needed (vs. writing the entire PLAN.md at once).
   - Recommendation: Replace `add-action` with `create-plan` (or `write-plan`) that writes an entire PLAN.md. Individual action addition is not useful when actions are part of a coherent plan document. The `/declare:actions` workflow derives all actions for a milestone at once and writes the plan as a unit.

3. **What columns should the new MILESTONES.md table have?**
   - What we know: Currently: ID, Title, Status, Realizes, Caused By. `Caused By` referenced action IDs from the old actions table.
   - What's unclear: Whether to keep `Caused By` (referencing PLAN.md action IDs), replace with `Has Plan` (boolean), or add `Plan Status`.
   - Recommendation: Replace `Caused By` with `Plan` column (YES/NO or plan file path). This keeps MILESTONES.md self-contained for its concern (milestone metadata). The planner should decide exact columns.

4. **How does `create-plan` handle action ID generation?**
   - What we know: Current `add-action` uses the DAG's `nextId('action')` which requires loading all existing actions to find max ID.
   - What's unclear: With actions distributed across PLAN.md files, loading all actions requires scanning all milestone folders.
   - Recommendation: `load-graph` already needs to scan all folders. Use `load-graph` output to build the DAG, then call `nextId('action')` for each new action. Alternatively, action IDs could be scoped to their milestone (e.g., actions in M-01's plan are M-01-A-01, M-01-A-02) but this changes the DAG engine ID validation significantly. Recommend keeping global A-XX IDs and scanning folders.

5. **Inconsistency flagging in /declare:milestones -- what does it look like?**
   - What we know: When a declaration changes, the command should flag inconsistencies with existing milestones.
   - What's unclear: How to detect a "changed" declaration (compare to what baseline?).
   - Recommendation: Use a simple heuristic -- if a declaration already has milestones but the user runs `/declare:milestones` on it, show existing milestones and ask "Do these still align with the declaration? Would you like to re-derive?" This is re-derivation awareness (already partially exists in the current workflow). No need for diff-based change detection in this phase.

## Sources

### Primary (HIGH confidence)
- **Codebase analysis** -- All source files read directly: `src/artifacts/milestones.js`, `src/artifacts/future.js`, `src/commands/*.js`, `src/graph/engine.js`, `src/declare-tools.js`, `workflows/*.md`, `commands/declare/*.md`
- **Phase summaries** -- `02-01-SUMMARY.md`, `02-02-SUMMARY.md` for established patterns and decisions
- **CONTEXT.md** -- User decisions for this phase

### Secondary (MEDIUM confidence)
- **ROADMAP.md** -- Phase 02.1 success criteria (note: references ACTIONS.md flat file, superseded by CONTEXT.md folder decision)

### Tertiary (LOW confidence)
- None -- this is entirely internal codebase restructuring with no external dependencies to verify.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- no new dependencies, all existing tools
- Architecture: HIGH -- all patterns established in prior phases, folder structure is straightforward
- Pitfalls: HIGH -- identified from direct codebase analysis of current code paths and cross-references

**Research date:** 2026-02-16
**Valid until:** No expiry -- internal codebase knowledge, not library versions
