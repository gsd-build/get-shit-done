---
phase: 06-alignment-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/engine.js
  - src/artifacts/future.js
  - src/commands/check-drift.js
  - src/commands/check-occurrence.js
  - src/commands/compute-performance.js
  - src/commands/renegotiate.js
  - src/declare-tools.js
autonomous: true
requirements:
  - ALGN-01
  - ALGN-02
  - ALGN-03
  - ALGN-04

must_haves:
  truths:
    - "check-drift returns orphaned nodes with contextual suggestions for reconnection"
    - "check-occurrence returns declaration data with milestone/action context for AI assessment"
    - "compute-performance returns per-declaration alignment x integrity as HIGH/MEDIUM/LOW labels"
    - "renegotiate archives a declaration to FUTURE-ARCHIVE.md and identifies orphaned milestones"
    - "All four new subcommands are registered in declare-tools.js and bundled"
  artifacts:
    - path: "src/commands/check-drift.js"
      provides: "Orphan detection with contextual suggestions"
      exports: ["runCheckDrift"]
    - path: "src/commands/check-occurrence.js"
      provides: "Declaration context for AI occurrence assessment"
      exports: ["runCheckOccurrence"]
    - path: "src/commands/compute-performance.js"
      provides: "Per-declaration and rollup performance computation"
      exports: ["runComputePerformance"]
    - path: "src/commands/renegotiate.js"
      provides: "Archive + replace declaration flow"
      exports: ["runRenegotiate"]
    - path: "src/artifacts/future.js"
      provides: "FUTURE-ARCHIVE.md parser/writer added to existing module"
      exports: ["parseFutureFile", "writeFutureFile", "parseFutureArchive", "writeFutureArchive", "appendToArchive"]
  key_links:
    - from: "src/commands/check-drift.js"
      to: "src/commands/build-dag.js"
      via: "buildDagFromDisk for graph loading"
      pattern: "buildDagFromDisk"
    - from: "src/commands/compute-performance.js"
      to: "src/graph/engine.js"
      via: "isCompleted for integrity status checks"
      pattern: "isCompleted"
    - from: "src/commands/renegotiate.js"
      to: "src/artifacts/future.js"
      via: "appendToArchive for declaration archival"
      pattern: "appendToArchive"
---

<objective>
Build the CJS data layer for Phase 6: four new commands (check-drift, check-occurrence, compute-performance, renegotiate) plus FUTURE-ARCHIVE.md artifact support and declare-tools registration.

Purpose: These commands provide deterministic data that the slash commands (Plan 06-02) will use for AI assessment, drift surfacing, and renegotiation orchestration. Follows the established pattern: CJS returns JSON, slash command handles interaction.

Output: Four new CJS command modules, updated future.js with archive support, updated engine.js with findOrphans, updated declare-tools.js with new subcommands, rebuilt bundle.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/graph/engine.js
@src/artifacts/future.js
@src/commands/build-dag.js
@src/commands/status.js
@src/commands/parse-args.js
@src/declare-tools.js
@.planning/phases/06-alignment-performance/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add findOrphans to engine, archive support to future.js, and create check-drift + check-occurrence commands</name>
  <files>
    src/graph/engine.js
    src/artifacts/future.js
    src/commands/check-drift.js
    src/commands/check-occurrence.js
  </files>
  <action>
**engine.js** -- Add a `findOrphans(dag)` convenience function (exported, not a method) that wraps `dag.validate()` and filters for orphan-type errors, returning `[{id, type, title, status}]`. Keep it as a standalone exported function matching the `isCompleted` pattern.

**future.js** -- Add three functions for FUTURE-ARCHIVE.md support:

1. `parseFutureArchive(content)` -- Parses `## Archived: D-XX -- Title` sections with fields: Statement, Archived (date), Reason, Replaced By, Status at Archive. Returns array of archive entry objects.

2. `writeFutureArchive(entries)` -- Writes archive entries to canonical markdown format with `# Future Archive` header, `---` separators between entries.

3. `appendToArchive(existingContent, entry)` -- Parses existing, appends new entry, writes back. Entry shape: `{id, title, statement, archivedAt, reason, replacedBy, statusAtArchive}`.

**check-drift.js** -- Create `runCheckDrift(cwd)`:
- Use `buildDagFromDisk(cwd)` to load graph.
- Use `findOrphans(dag)` to get orphaned nodes.
- For each orphan, call `findNearestConnections(dag, orphanId)` (local helper) to suggest up to 3 possible parent connections:
  - For orphaned actions: find milestones that have existing actions (suggest connecting to them).
  - For orphaned milestones: find active declarations (suggest connecting to them).
- Each suggestion includes: `{type: 'connect', target: targetId, targetTitle, reason}`.
- Return: `{hasDrift: boolean, driftedNodes: [{id, type, title, status, suggestions: [...]}]}`.

**check-occurrence.js** -- Create `runCheckOccurrence(cwd, args)`:
- Parse `--declaration D-XX` flag using `parseFlag`.
- If no flag, return ALL declarations with their context (batch mode for milestone-completion triggers).
- Use `buildDagFromDisk(cwd)` to load graph.
- For each declaration, gather: `{declarationId, statement, status, milestoneCount, milestones: [{id, title, status}], actionSummary: {total, completed}}`.
- Return the gathered data for AI assessment by the slash command.
  </action>
  <verify>
Run `node src/graph/engine.js` (no errors on require). Run `node -e "const {findOrphans} = require('./src/graph/engine'); console.log(typeof findOrphans)"` prints "function". Run `node -e "const {parseFutureArchive, appendToArchive} = require('./src/artifacts/future'); console.log(typeof parseFutureArchive, typeof appendToArchive)"` prints "function function". Run `node -e "const {runCheckDrift} = require('./src/commands/check-drift'); console.log(typeof runCheckDrift)"` prints "function". Run `node -e "const {runCheckOccurrence} = require('./src/commands/check-occurrence'); console.log(typeof runCheckOccurrence)"` prints "function".
  </verify>
  <done>findOrphans returns filtered orphan array from validate(). parseFutureArchive/writeFutureArchive/appendToArchive handle FUTURE-ARCHIVE.md round-trip. check-drift returns orphaned nodes with max 3 contextual suggestions each. check-occurrence returns declaration data with milestone/action context for AI assessment.</done>
</task>

<task type="auto">
  <name>Task 2: Create compute-performance and renegotiate commands, register all in declare-tools.js, rebuild bundle</name>
  <files>
    src/commands/compute-performance.js
    src/commands/renegotiate.js
    src/declare-tools.js
    dist/declare-tools.cjs
  </files>
  <action>
**compute-performance.js** -- Create `runComputePerformance(cwd)`:
- Use `buildDagFromDisk(cwd)` to load graph.
- For each declaration, compute:
  - **Structural alignment**: Get downstream milestones. Count milestones that have at least one action (via `dag.getDownstream`). Ratio = milestonesWithActions / totalMilestones. Map to label: >= 0.8 = HIGH, >= 0.5 = MEDIUM, else LOW. If no milestones, alignment = LOW.
  - **Integrity**: Get all milestones for this declaration. Count statuses: KEPT/HONORED/RENEGOTIATED = verified, BROKEN = broken, rest = pending. Use thresholds: brokenRatio > 0.3 = LOW, verifiedRatio >= 0.7 and no broken = HIGH, verifiedRatio >= 0.4 = MEDIUM, else LOW. Empty milestones = HIGH (vacuously true).
  - **Combined performance**: If either is LOW -> LOW. If both HIGH -> HIGH. Otherwise MEDIUM.
  - Return per-declaration: `{declarationId, declarationTitle, statement, alignment: {level, milestonesTotal, milestonesWithActions}, integrity: {level, verified, broken, pending, total}, performance}`.
- Compute project rollup: aggregate across declarations using same logic (any LOW -> LOW rollup, all HIGH -> HIGH, else MEDIUM).
- Return: `{perDeclaration: [...], rollup: {alignment, integrity, performance}}`.

**renegotiate.js** -- Create `runRenegotiate(cwd, args)`:
- Parse `--declaration D-XX` and `--reason "..."` flags.
- Use `buildDagFromDisk(cwd)` to load graph.
- Validate the declaration exists.
- Read FUTURE.md, find the declaration, set its status to RENEGOTIATED.
- Write updated FUTURE.md (using `writeFutureFile`).
- Read or create FUTURE-ARCHIVE.md, append archived entry using `appendToArchive` with: id, title, statement, archivedAt (ISO timestamp), reason, replacedBy (empty for now), statusAtArchive (RENEGOTIATED).
- Write FUTURE-ARCHIVE.md to `.planning/FUTURE-ARCHIVE.md`.
- Find orphaned milestones: milestones that realized ONLY this declaration (check `realizes` array). For each, find downstream actions.
- Return: `{archived: {id, title, archivedAt}, orphanedMilestones: [{id, title, status, actions: [{id, title, status}]}], archivePath, nextStep: 'Create replacement declaration or reassign milestones'}`.

**declare-tools.js** -- Register four new subcommands in the switch statement:
- `check-drift` -> `runCheckDrift(cwd)`
- `check-occurrence` -> `runCheckOccurrence(cwd, args.slice(1))`
- `compute-performance` -> `runComputePerformance(cwd)`
- `renegotiate` -> `runRenegotiate(cwd, args.slice(1))`

Add the require() imports at the top. Update the error message string with the new command names.

**Bundle rebuild**: Run `node esbuild.config.js` to produce updated `dist/declare-tools.cjs`.
  </action>
  <verify>
Run `node -e "const {runComputePerformance} = require('./src/commands/compute-performance'); console.log(typeof runComputePerformance)"` prints "function". Run `node -e "const {runRenegotiate} = require('./src/commands/renegotiate'); console.log(typeof runRenegotiate)"` prints "function". Run `node esbuild.config.js` succeeds. Run `node dist/declare-tools.cjs check-drift` returns JSON (may be error if no project). Run `node dist/declare-tools.cjs compute-performance` returns JSON. Run `node dist/declare-tools.cjs renegotiate` returns JSON (error about missing flag is OK). Run `node dist/declare-tools.cjs check-occurrence` returns JSON.
  </verify>
  <done>compute-performance returns per-declaration and rollup performance as HIGH/MEDIUM/LOW labels. renegotiate archives declaration to FUTURE-ARCHIVE.md and lists orphaned milestones. All four new commands registered in declare-tools.js and accessible via bundled CLI. Bundle builds successfully.</done>
</task>

</tasks>

<verification>
1. `node dist/declare-tools.cjs check-drift` returns valid JSON with `hasDrift` field
2. `node dist/declare-tools.cjs check-occurrence` returns valid JSON with declarations context
3. `node dist/declare-tools.cjs compute-performance` returns valid JSON with `perDeclaration` and `rollup`
4. `node dist/declare-tools.cjs renegotiate --declaration D-01 --reason "test"` returns valid JSON (may error if no D-01 exists, but error is structured JSON)
5. `node dist/declare-tools.cjs help` lists new commands (if help is updated)
6. No existing tests broken: `node --test src/graph/engine.test.js` passes
</verification>

<success_criteria>
- Four new CJS commands provide deterministic data for slash command orchestration
- FUTURE-ARCHIVE.md has full parse/write/append support
- findOrphans convenience function wraps validate() orphan filtering
- Performance uses qualitative labels only (HIGH/MEDIUM/LOW), never numeric scores for output
- Renegotiation archives declaration and identifies transitively orphaned milestones with their actions
- Bundle builds and all new subcommands are accessible via CLI
</success_criteria>

<output>
After completion, create `.planning/phases/06-alignment-performance/06-01-SUMMARY.md`
</output>
