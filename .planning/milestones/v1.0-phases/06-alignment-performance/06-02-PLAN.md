---
phase: 06-alignment-performance
plan: 02
type: execute
wave: 2
depends_on:
  - "06-01"
files_modified:
  - src/commands/status.js
  - .claude/commands/declare/execute.md
  - .claude/commands/declare/status.md
autonomous: true
requirements:
  - ALGN-01
  - ALGN-02
  - ALGN-03
  - ALGN-04

must_haves:
  truths:
    - "Running /declare:execute automatically checks for drift before each wave and shows soft-block warnings with suggestions"
    - "Running /declare:execute triggers occurrence checks when a milestone completes, asking 'does this still occur?'"
    - "Running /declare:status shows per-declaration performance (alignment x integrity) and a project rollup"
    - "Renegotiation flow is triggered from occurrence checks when a declaration is 'no longer true'"
    - "FUTURE.md is referenced as the shared future document by execute and status commands"
  artifacts:
    - path: "src/commands/status.js"
      provides: "Performance section in status output"
      contains: "runComputePerformance"
    - path: ".claude/commands/declare/execute.md"
      provides: "Drift pre-check, occurrence check at milestone completion, renegotiation flow"
      contains: "check-drift"
    - path: ".claude/commands/declare/status.md"
      provides: "Performance display rendering"
      contains: "Performance"
  key_links:
    - from: ".claude/commands/declare/execute.md"
      to: "dist/declare-tools.cjs check-drift"
      via: "CJS CLI call before each wave"
      pattern: "check-drift"
    - from: ".claude/commands/declare/execute.md"
      to: "dist/declare-tools.cjs check-occurrence"
      via: "CJS CLI call after milestone completion"
      pattern: "check-occurrence"
    - from: ".claude/commands/declare/status.md"
      to: "src/commands/status.js"
      via: "CJS CLI call for status data with performance"
      pattern: "performance"
---

<objective>
Wire Phase 6 CJS commands into slash command orchestration: drift checks in execute, occurrence checks at milestone completion, performance display in status, and renegotiation flow when declarations drift.

Purpose: The CJS layer (Plan 06-01) provides data; this plan adds the AI assessment, user interaction, and visual rendering that makes alignment and performance visible and actionable.

Output: Updated execute.md with drift pre-checks and occurrence checks, updated status.md with performance rendering, updated status.js with performance data section.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-alignment-performance/06-01-SUMMARY.md
@src/commands/status.js
@.claude/commands/declare/execute.md
@.claude/commands/declare/status.md
@.planning/phases/06-alignment-performance/06-RESEARCH.md
@.planning/phases/06-alignment-performance/06-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add performance section to status.js and update status.md rendering</name>
  <files>
    src/commands/status.js
    .claude/commands/declare/status.md
    dist/declare-tools.cjs
  </files>
  <action>
**status.js** -- Integrate performance computation into the status command output:

1. Import `runComputePerformance` from `./compute-performance`.
2. In `runStatus()`, after computing integrity, call `runComputePerformance(cwd)`.
3. If it returns an error, set performance to null (graceful degradation).
4. Otherwise, add the `performance` field to the return object containing: `{perDeclaration: [{declarationId, declarationTitle, alignment, integrity, performance}], rollup: {alignment, integrity, performance}}`.
5. The status return object now includes `performance` alongside existing `integrity`, `coverage`, `staleness` etc.

Rebuild bundle: `node esbuild.config.js`.

**status.md** -- Add a new **Performance** section to the rendering instructions, placed after the Integrity section (before Health Indicators):

Add this to the rendering instructions:

```
**Performance:** If the status output contains a `performance` field (non-null):

Show the project rollup first:
"Performance: [rollup.performance] (alignment: [rollup.alignment] x integrity: [rollup.integrity])"

Then show per-declaration breakdown:
| Declaration | Alignment | Integrity | Performance |
|-------------|-----------|-----------|-------------|
| D-XX: [title] | HIGH | MEDIUM | MEDIUM |

If `performance` is null, skip this section entirely (graceful degradation for projects with no declarations).
```

Keep the "Performance: HIGH (alignment: HIGH x integrity: HIGH)" plain text label format per the locked decision.
  </action>
  <verify>
Run `node esbuild.config.js` succeeds. Run `node dist/declare-tools.cjs status` and confirm the output JSON includes a `performance` field (may be null if no declarations exist, which is OK). Read status.md and confirm it has the Performance rendering section.
  </verify>
  <done>status.js returns performance data (per-declaration + rollup) as part of the status output. status.md renders performance in the "Performance: HIGH (alignment: HIGH x integrity: HIGH)" format with a per-declaration table. Bundle rebuilt successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Add drift pre-checks, occurrence checks, and renegotiation flow to execute.md</name>
  <files>
    .claude/commands/declare/execute.md
  </files>
  <action>
Update the execute.md slash command to add three new behaviors:

**1. Drift pre-check (before Step 3, wave execution):**

Add a new Step 2.5 "Check for drift" between Step 2 (load data) and Step 3 (wave execution):

```
**Step 2.5: Check for drift.**

Run:
node dist/declare-tools.cjs check-drift

Parse the JSON output.

If `hasDrift` is true:
- Display a drift warning banner:

## Drift Detected

The following nodes have no causation path to any declaration:

For each drifted node, display:
- [type] [id]: [title] (status: [status])
  Suggestions:
  - Connect to [suggestion.target] ([suggestion.targetTitle]) -- [suggestion.reason]

Then ask: "Drifted nodes detected. Continue execution anyway? (yes/no/fix)"
- "yes" -> proceed with execution
- "no" -> abort execution
- "fix" -> suggest the user run /declare:milestones or manually edit MILESTONES.md/PLAN.md to reconnect orphaned nodes, then retry

This is a SOFT BLOCK per user decision -- warn but allow continuation.

If `hasDrift` is false: proceed silently.
```

**2. Occurrence checks (after Step 4, milestone completion):**

Add a new Step 5 "Occurrence check" after milestone completion:

```
**Step 5: Occurrence check at milestone completion.**

After marking the milestone as DONE (or when all actions are complete):

Run:
node dist/declare-tools.cjs check-occurrence

Parse the JSON output. For each declaration in the result:

Perform AI assessment: Given the declaration statement and its connected milestones/actions, assess:
1. Does this declaration still occur as what was declared? (Is it still true/relevant?)
2. Has any work drifted from the declaration's intent?
3. Rate alignment: HIGH / MEDIUM / LOW

Display the assessment:

### Occurrence Check: D-XX -- [title]

**Statement:** "[statement]"
**Connected milestones:** [count] ([completed] verified)
**Assessment:** [AI assessment of whether this still occurs as declared]
**Alignment:** [HIGH/MEDIUM/LOW]

If the AI assessment determines a declaration is "no longer true" or alignment is LOW:
- Ask the user: "Declaration D-XX appears to no longer occur as declared. Renegotiate? (yes/no)"
- If "yes" -> enter renegotiation flow (Step 5a)
- If "no" -> note it and continue

**Step 5a: Renegotiation flow (if triggered).**

Ask the user: "Why is this declaration no longer true?" and capture their reason.

Run:
node dist/declare-tools.cjs renegotiate --declaration D-XX --reason "[user's reason]"

Parse the JSON output.

Display:
### Renegotiation Complete: D-XX

**Archived to:** FUTURE-ARCHIVE.md
**Reason:** [reason]

If orphanedMilestones is non-empty, display them grouped:

**Orphaned milestones requiring review:**

For each orphaned milestone:
- M-XX: [title] ([status])
  Actions: A-XX ([status]), A-XX ([status])
  Options:
  1. Reassign to another declaration
  2. Archive this milestone
  3. Leave for now (will appear as drift)

"Which milestones would you like to reassign? Provide IDs or 'skip' to leave for later."

If user provides IDs, guide them through reassignment (edit MILESTONES.md to update the Realizes column). If "skip", acknowledge and continue.

Then prompt: "Would you like to create a replacement declaration now? (yes/no)"
- If "yes": suggest running `/declare:future` to add a new declaration
- If "no": continue
```

**3. Update execution summary:**

Update the Step 4 completion banner to include a note about the occurrence check:

```
## Execution Complete: M-XX -- [milestoneTitle]

**Actions completed:** [pendingCount]
**Waves executed:** [waves.length]
**Milestone status:** [DONE or current status]
**Occurrence check:** [Performed / Skipped (if no declarations affected)]
```

Keep all existing execute.md behavior intact. These additions are purely additive -- they insert between existing steps and after the final step.
  </action>
  <verify>
Read execute.md and confirm: Step 2.5 (drift check) exists with soft-block UX. Step 5 (occurrence check) exists with AI assessment prompting. Step 5a (renegotiation flow) exists with orphan review. All original steps (1-4) are preserved unchanged.
  </verify>
  <done>execute.md has drift pre-checks with soft-block warning before wave execution, occurrence checks with AI assessment after milestone completion, and renegotiation flow with orphan review when declarations are no longer true. All original execution behavior is preserved.</done>
</task>

</tasks>

<verification>
1. `node dist/declare-tools.cjs status` returns JSON with `performance` field
2. status.md contains Performance rendering instructions with per-declaration table format
3. execute.md contains Step 2.5 (drift check) with `check-drift` CLI call and soft-block UX
4. execute.md contains Step 5 (occurrence check) with `check-occurrence` CLI call and AI assessment
5. execute.md contains Step 5a (renegotiation flow) with `renegotiate` CLI call and orphan review
6. All original execute.md steps are preserved (1, 2, 3a-e, 4)
7. No existing tests broken
</verification>

<success_criteria>
- Drift is surfaced automatically during execution with soft-block (not hard block) per user decision
- Occurrence checks fire at milestone completion with AI assessment per each declaration
- Renegotiation archives declaration to FUTURE-ARCHIVE.md and presents orphans grouped by milestone for user review
- Performance appears in status output as "Performance: HIGH (alignment: HIGH x integrity: HIGH)" format
- Per-declaration granularity with project rollup, all qualitative labels (never numeric)
- FUTURE.md is treated as the shared future document referenced by both execute and status commands
</success_criteria>

<output>
After completion, create `.planning/phases/06-alignment-performance/06-02-SUMMARY.md`
</output>
