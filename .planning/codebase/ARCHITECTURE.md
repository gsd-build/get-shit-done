# Architecture

**Analysis Date:** 2026-02-05

## Pattern Overview

**Overall:** Command-orchestrator pattern with subagent specialization

GSD is a meta-prompting and context engineering system designed as a distributed multi-agent orchestration framework. The architecture separates concerns into:
1. **Command Layer** — User-facing commands that route to specialized agents
2. **Orchestrator Layer** — Commands that coordinate multi-agent workflows
3. **Agent Layer** — Specialized subagents executing focused responsibilities
4. **Reference Layer** — Shared knowledge and patterns used by all agents

**Key Characteristics:**
- User commands trigger orchestrators, which spawn parallel subagents with specialized roles
- Each agent receives fresh context window (100% budget) for peak quality
- Orchestrators coordinate, not execute — they're lean and delegation-focused
- Plans are prompts, not documents — PLAN.md files directly execute when read by executor agents
- State is centralized in `.planning/` directory with hierarchical metadata

## Layers

**Command Layer:**
- Purpose: Entry points for user interaction (e.g., `/gsd:new-project`, `/gsd:plan-phase`)
- Location: `commands/gsd/*.md`
- Contains: Command definitions with frontmatter (name, description, agent, allowed-tools)
- Depends on: Nothing directly — commands are registered with Claude Code/Gemini
- Used by: Users via `/gsd:command-name` syntax

**Orchestrator Layer:**
- Purpose: Coordinate multi-agent workflows without implementing business logic
- Location: `commands/gsd/*.md` (orchestrator-type commands) and `get-shit-done/workflows/*.md`
- Contains: Step-by-step coordination logic, agent spawning via Task tool, result aggregation
- Depends on: Agent layer (spawns subagents), reference layer (shared knowledge)
- Used by: Command layer, other orchestrators
- Examples: `/gsd:plan-phase` orchestrates research → planner → checker loop; `/gsd:execute-phase` orchestrates wave-based parallel execution

**Agent Layer:**
- Purpose: Specialized workers executing focused responsibilities
- Location: `agents/*.md`
- Contains: Role definitions, specialized workflows, self-contained logic
- Depends on: Reference layer (for patterns and knowledge)
- Used by: Orchestrators (spawned via Task calls)
- Agents:
  - `gsd-planner` — Creates executable PLAN.md files with task breakdown
  - `gsd-executor` — Executes PLAN.md files with atomic commits
  - `gsd-verifier` — Validates plan completion against must-haves
  - `gsd-codebase-mapper` — Analyzes codebase and writes STACK/ARCHITECTURE/CONVENTIONS docs
  - `gsd-project-researcher` — Deep domain research for new projects
  - `gsd-phase-researcher` — Phase-specific research before planning
  - `gsd-debugger` — Diagnoses and fixes issues in execution
  - Others: plan-checker, integration-checker, roadmapper, etc.

**Reference Layer:**
- Purpose: Shared patterns, checklists, and knowledge consumed by agents
- Location: `get-shit-done/references/*.md`
- Contains: Questioning frameworks, verification patterns, git integration rules, model profiles, planning config options, TDD workflows
- Examples: `questioning.md` (question templates), `verification-patterns.md` (how to verify work), `model-profiles.md` (quality/balanced/budget model assignments)

**Template Layer:**
- Purpose: Default document structures generated by orchestrators
- Location: `get-shit-done/templates/*.md`
- Contains: Markdown templates for PROJECT.md, REQUIREMENTS.md, ROADMAP.md, PLAN.md, SUMMARY.md, STATE.md, discovery docs
- Examples: `templates/project.md` (project context structure), `templates/codebase/*.md` (codebase analysis document templates)

**Installation & Setup Layer:**
- Purpose: Install GSD into user's Claude Code/Gemini/OpenCode environment
- Location: `bin/install.js` (Node.js installation script)
- Responsible for: Copying command definitions, agents, and references to user's `~/.claude/`, `~/.config/opencode/`, or `~/.gemini/`

## Data Flow

**New Project Initialization:**

1. User runs `/gsd:new-project`
2. Orchestrator checks for existing code, offers codebase mapping
3. Orchestrator asks deep questions (questioning.md patterns)
4. Orchestrator writes PROJECT.md from responses
5. Orchestrator offers optional research phase
6. If research selected: spawns gsd-project-researcher → writes research docs
7. Orchestrator synthesizes requirements from PROJECT.md and research
8. Orchestrator writes REQUIREMENTS.md and ROADMAP.md
9. Creates STATE.md to track project progress
10. Creates config.json to store workflow preferences

**Phase Planning & Execution:**

1. User runs `/gsd:plan-phase 1`
2. Orchestrator loads ROADMAP.md, finds Phase 1 context
3. Loads CONTEXT.md if phase-specific decisions exist (locked decisions)
4. If needed: spawns gsd-phase-researcher → writes RESEARCH.md
5. Spawns gsd-planner → creates PLAN.md (split into multiple if large)
6. Spawns gsd-plan-checker → validates plans against requirements and locked decisions
7. If checker fails: orchestrator revises plan with feedback, re-checks
8. Returns validated PLAN.md(s) ready for execution
9. User runs `/gsd:execute-phase 1`
10. Orchestrator discovers all PLAN.md files in phase
11. Groups plans by wave (dependency metadata in PLAN frontmatter)
12. Spawns gsd-executor subagents in parallel for each wave
13. Each executor reads its PLAN.md and implements all tasks
14. Executor creates SUMMARY.md with commit hashes and status
15. Orchestrator collects all SUMMARYs
16. Spawns gsd-verifier → checks implementation against must-haves
17. Verifier returns VERIFICATION.md with pass/gaps/human-needed status
18. Orchestrator updates ROADMAP.md and STATE.md
19. Optionally commits planning docs (configurable)
20. Routes to next phase or milestone

**State Management:**

- `.planning/PROJECT.md` — Project vision, requirements, scope
- `.planning/config.json` — Workflow settings (research on/off, commit_docs, model_profile, parallelization)
- `.planning/REQUIREMENTS.md` — Traceability table mapping requirements to phases
- `.planning/ROADMAP.md` — Phase structure with names, goals, must-haves, assignments
- `.planning/STATE.md` — Current execution position, accumulated decisions, blockers
- `.planning/phases/NN-name/CONTEXT.md` — User decisions for this phase (locked, deferred, discretionary)
- `.planning/phases/NN-name/RESEARCH.md` — Domain research (if conducted)
- `.planning/phases/NN-name/PLAN.md` — Executable prompt for executor
- `.planning/phases/NN-name/SUMMARY.md` — Execution results with commits and deviations

## Key Abstractions

**The Command:**
- Purpose: Maps user input to an orchestrator or agent
- Examples: `commands/gsd/new-project.md`, `commands/gsd/plan-phase.md`
- Pattern: YAML frontmatter (name, description, agent, allowed-tools) + markdown workflow
- Every command routes to exactly one agent via the `agent:` field

**The Agent:**
- Purpose: Specialized worker with a focused responsibility
- Location: `agents/*.md`
- Structure: Role definition → process steps → execution flow
- Lifecycle: Spawned by orchestrator via Task tool, runs to completion, returns output
- Context: Each agent gets 100% fresh context window (separate from orchestrator)

**The Plan:**
- Purpose: Executable prompt that drives implementation
- Format: PLAN.md with frontmatter (phase, plan, type, wave, depends_on) + objective + context references + tasks
- Key property: IS the prompt, not transformed into a prompt
- Tasks have four required fields: `<files>` (what gets created/modified), `<action>` (how), `<verify>` (proof), `<done>` (acceptance)
- Types: `auto` (fully autonomous), `checkpoint:human-verify` (pause for visual check), `checkpoint:decision` (pause for choice), `checkpoint:human-action` (pause for unavoidable manual work)

**The Summary:**
- Purpose: Execution result documentation
- Created by: gsd-executor after plan completion
- Contains: Objective, context, task results (files, commits, status), deviations discovered and handled, verification pass/fail status
- Used by: Orchestrators to aggregate results and route to verification

**The Context:**
- Purpose: Phase-specific user decisions that constrain planning
- Location: `.planning/phases/NN-name/CONTEXT.md`
- Structure: Three sections:
  1. **Decisions** — Locked choices (must be honored exactly)
  2. **Deferred Ideas** — Out of scope for this phase
  3. **Claude's Discretion** — Areas where user says "you decide"
- Consumed by: Researcher (shapes what to research), Planner (shapes tasks), Checker (validates plans respect context)

## Entry Points

**Installation Entry Point:**
- Location: `bin/install.js`
- Invocation: `npx get-shit-done-cc [--claude|--opencode|--gemini|--all] [--global|--local] [--uninstall]`
- Responsibilities: Parse runtime selection, determine install location, copy GSD files to user's config directory
- Output: Installs `.claude/get-shit-done/`, `.opencode/get-shit-done/`, or `.gemini/get-shit-done/`

**User-Facing Commands:**
- All commands in `commands/gsd/*.md` are entry points
- Invocation: `/gsd:command-name [args]` (e.g., `/gsd:new-project`, `/gsd:plan-phase 1`)
- Each command has an `agent:` field pointing to the orchestrator/agent to spawn
- Commands available:
  - Project lifecycle: `new-project`, `progress`
  - Phase workflow: `plan-phase`, `execute-phase`, `verify-work`
  - Interaction: `discuss-phase`, `quick` (ad-hoc requests)
  - System: `debug`, `update`, `help`, `map-codebase`

**CLI Installation Entry Point (for non-interactive installs):**
- `bin/install.js` with flags: `--claude`, `--opencode`, `--gemini`, `--global`, `--local`
- Used in Docker, CI, scripts for automated setup

## Error Handling

**Strategy:** Graceful degradation with explicit fallback paths

**Patterns:**

1. **Missing configuration** — Default to sensible values
   - Missing `config.json` → assume defaults (research: true, commit_docs: true, model_profile: balanced)
   - Missing `MODEL_PROFILE` → default to "balanced"
   - Missing `.planning/` → error with "run `/gsd:new-project` first"

2. **File system errors** — Fail fast with context
   - Missing phase directory → create it if planning, error if executing
   - Missing CONTEXT.md → continue (phase may have no special context)
   - Missing ROADMAP.md → error in execute-phase, critical for navigation

3. **Agent failures** — Orchestrator handles transparently
   - Researcher fails → offer to skip research and proceed with planning
   - Planner returns invalid PLAN.md → plan-checker flags issues, offer revision
   - Executor task fails → deviation rules auto-fix where possible, document in SUMMARY.md
   - Verifier finds gaps → offer `/gsd:plan-phase {X} --gaps` for closure

4. **Authentication/environment** — Task-level handling
   - Git command fails (no repo) → catch and create repo
   - OpenCode config dir not found → use XDG defaults
   - Node version mismatch → warn but continue

5. **Context window pressure** — Preemptive splitting
   - Plans sized to complete within ~50% context (leaves room for implementation)
   - Large phases split into multiple smaller plans (each plan is wave-independent)
   - Aggressive atomicity: 2-3 tasks per plan, not 10-15

## Cross-Cutting Concerns

**Logging:**
- Markdown-based progress output (ASCII boxes, section headers)
- Git commits as audit trail (every task in executor creates a commit)
- STATE.md tracks execution position for resumability

**Validation:**
- Commands validated by Claude Code runtime (tool permissions)
- Phase numbers validated against ROADMAP.md
- Plans validated by gsd-plan-checker against requirements and context
- Implementation validated by gsd-verifier against must-haves (not just claim-verification)

**Authentication & Authorization:**
- GSD itself has no auth — runs in user's Claude Code environment
- External integrations (APIs, git) use environment variables or system credentials
- File system access is user's current permissions (no privilege elevation)

**Configuration Management:**
- `.planning/config.json` stores workflow preferences (JSON-based)
- `.planning/PROJECT.md` and `ROADMAP.md` are generated once, updated by orchestrators
- `.planning/STATE.md` is updated by executors and orchestrators (project memory)
- Model profile resolution from `config.json` happens at each command entry

**Git Integration:**
- Every executor task creates an atomic commit (per-task traceability)
- Commit message format: `type(scope): description` (from GSD-STYLE.md)
- Planning docs optionally committed based on `commit_docs` config
- `.planning/` can be gitignored (auto-detection in executor)
- Branch creation based on branching_strategy config (phase, milestone, or none)

---

*Architecture analysis: 2026-02-05*
