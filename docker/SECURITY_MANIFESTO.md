# üõ°Ô∏è GSD Secure: The "Full Containment" Manifesto

> **"Safe Intelligence"**: Why we run GSD Agents inside a Docker Container.

## 1. The Core Problem
Autonomous AI Agents (like GSD) act as "Junior Developers". To do their job, they need powerful permissions:
*   Read/Write files.
*   Execute shell commands.
*   Install dependencies.

Running an autonomous agent directly on your Host OS ("Bare Metal") is a critical risk.
**Why is this madness?**
1.  **Massive Data Loss**: LLMs hallucinate. If an agent tries to clean a build folder and accidentally runs `rm -rf ~` or `rm -rf /`, your personal photos, documents, and code are gone forever.
2.  **Malware Injection (Supply Chain)**: Agents often install libraries to solve problems (`npm install x`). If an agent installs a typosquatted malicious package, that malware runs immediately on your host, stealing browser cookies, SSH keys, and crypto wallets.
3.  **Environment Pollution**: Agents might change your global git config, node version, or python environment, breaking your other projects silently.
4.  **Data Exfiltration**: An agent running on your host can read *any* file it wants, including `.env` files from other projects or your `.ssh/id_rsa`.

5.  **The "Fatigue Factor" and Non-Technical Risks**:
    *   **Alert Fatigue**: When an agent asks for approval 50 times, you stop reading. The 51st command is the malicious one, and you click "Approve" out of habit.
    *   **Complexity Blindness**: For non-technical users, a command like `rm -rf $(npm bin)` looks harmless but can be destructive. Expecting a human to audit every shell command generated by an AI is unrealistic and unsafe.

**GSD Secure eliminates all these risks by physically and digitally isolating the execution.**

## 2. The Solution: Full Containment
We rejected the "Native Sandbox" approach (intercepting system calls) in favor of **Full Containment** (Docker).

| Feature | Option A: Native Sandbox | Option B: GSD Secure (Docker) |
| :--- | :--- | :--- |
| **Where Agent Lives** | On Host | **In Isolated Container** |
| **File System** | Read/Write Host | **Bind Mount Only** (Project Folder) |
| **Malware Risk** | Persistent | **Ephemeral** (Destroyed on exit) |
| **Security Level** | High Complexity / Leaky | **Kernel-Level Isolation** |

**Verdict**: We chose Option B. The Agent is not just handcuffed; it is in a separate room.

## 3. Architecture Overview
The GSD Secure environment consists of three layers:

### Layer 1: The "Space Suit" (Docker Image)
*   **Base**: `node:20-slim` (Minimal attack surface).
*   **Tools**: Pre-loaded with `git`, `python3`, `curl`.
    *   **Universal Auth Mounting**: Automatically detects and mounts keys for:
        *   Google Gemini (`~/.gemini`)
        *   Anthropic Claude (`~/.claude`)
        *   OpenCode (`~/.config/opencode`)
    *   **Identity Injection**: Passes the host's Git configuration (`user.name`, `email`) into the container, so commits belong to *you*.
*   **Auto-Stack**: Project dependencies are installed *inside* the container at runtime, keeping your Host OS clean.

### Layer 3: The "Brain" (Agent Awareness)
*   The GSD Agent is aware of this architecture.
*   It requests tools via `STACK.md` code blocks.
*   It assumes it is running as `root` *inside* the container, but maps to your user *outside*.

## 4. Security Guarantees
1.  **Zero Host Pollution**: `npm install` runs inside. `apt-get` runs inside. Your host remains untouched.
2.  **Scope Containment**: The agent can only see the folder you mounted (`/app`). It cannot access your Documents, Desktop, or System files.
3.  **Supply Chain Firewall**: If an agent downloads a malicious package, it infects only the disposable container. Restarting the sandbox eradicates the threat.

## 5. Network Mode: The Conscious Trade-off

GSD Secure offers two network modes. We made a deliberate choice about the default based on real-world developer needs.

---

### The Problem We Found

During testing, we discovered that Docker's default bridge network blocks access to localhost services. This caused major friction:

```
# Inside container with bridge network:
curl localhost:5432      # ‚ùå Connection refused
psql -h localhost        # ‚ùå Could not connect
```

Developers expected their local Postgres, Redis, and dev servers to "just work." Instead, they got cryptic errors and had to learn Docker networking workarounds.

---

### Default Mode: `gsd-secure`

**Uses Docker's `--network host` option.**

This means the container shares your computer's network interface. From the container's perspective, `localhost` is the same as your host machine's `localhost`.

#### What Works:
| Service | Example | Status |
|---------|---------|--------|
| Local PostgreSQL | `localhost:5432` | ‚úÖ Works |
| Local Redis | `localhost:6379` | ‚úÖ Works |
| Local dev server | `localhost:3000` | ‚úÖ Works |
| Cloud APIs | `api.supabase.com` | ‚úÖ Works |
| External databases | `db.example.com` | ‚úÖ Works |

#### What's Still Protected:
- ‚úÖ **File system**: Agent can only access `/app` (your mounted project folder)
- ‚úÖ **Malware persistence**: Container is ephemeral, destroyed on exit
- ‚úÖ **Host system files**: Cannot read `~/.ssh`, `~/.env`, other projects

#### What's NOT Protected:
- ‚ö†Ô∏è **Local network visibility**: Container can reach other machines on your LAN
- ‚ö†Ô∏è **Localhost services**: Container can connect to any localhost port
- ‚ö†Ô∏è **VPN access**: If you're on VPN, container sees that network too

---

### Strict Mode: `gsd-secure --strict`

**Uses Docker's bridge network with external DNS (Google/Cloudflare).**

This creates a fully isolated network. The container has its own network namespace and cannot see your localhost directly.

#### What Works:
| Service | Example | Status |
|---------|---------|--------|
| Cloud APIs | `api.supabase.com` | ‚úÖ Works |
| External databases | `db.example.com` | ‚úÖ Works |
| Local PostgreSQL | `localhost:5432` | ‚ùå Blocked |
| Local Redis | `localhost:6379` | ‚ùå Blocked |

#### How to Access Localhost in Strict Mode:
Use the special hostname `host.docker.internal`:

```bash
# Instead of:
psql -h localhost -p 5432

# Use:
psql -h host.docker.internal -p 5432
```

#### What's Protected:
- ‚úÖ **File system**: Agent can only access `/app`
- ‚úÖ **Malware persistence**: Container is ephemeral
- ‚úÖ **Host system files**: Cannot read outside `/app`
- ‚úÖ **Local network**: Cannot see other machines on your LAN
- ‚úÖ **Localhost services**: Cannot connect unless explicitly using `host.docker.internal`

---

### Security Comparison Table

| Threat Vector | Default Mode | Strict Mode |
|---------------|--------------|-------------|
| Read files outside project | üõ°Ô∏è **Blocked** | üõ°Ô∏è **Blocked** |
| Persist malware after exit | üõ°Ô∏è **Blocked** (ephemeral) | üõ°Ô∏è **Blocked** (ephemeral) |
| Access localhost:5432 | ‚ö†Ô∏è Allowed | üõ°Ô∏è **Blocked** |
| Scan local network (LAN) | ‚ö†Ô∏è Allowed | üõ°Ô∏è **Blocked** |
| Access VPN resources | ‚ö†Ô∏è Allowed | üõ°Ô∏è **Blocked** |
| Connect to cloud APIs | ‚úÖ Allowed | ‚úÖ Allowed |

---

### When to Use Each Mode

| Scenario | Recommended Mode |
|----------|------------------|
| Normal development with local DB | `gsd-secure` (default) |
| Working with cloud-only services | `gsd-secure` (default) |
| Running untrusted code/dependencies | `gsd-secure --strict` |
| Security-sensitive environment | `gsd-secure --strict` |
| Corporate network with sensitive resources | `gsd-secure --strict` |

---

### Our Philosophy

> **Remove friction for the common case. Provide strict isolation for those who need it.**

99% of developers need localhost access during development. The previous bridge-network default created confusion and frustration. By making `--network host` the default, we prioritize developer experience while keeping all file system protections intact.

For security-conscious users and sensitive environments, `--strict` mode provides full network isolation with explicit opt-in for localhost access via `host.docker.internal`.

---

## 6. Why Not Docker Sandboxes?

Docker recently introduced [Docker Sandboxes](https://docs.docker.com/ai/sandboxes/), a feature that runs AI agents in microVMs with private Docker daemons. We evaluated this approach and decided **it's not suitable for GSD Secure**.

### What Docker Sandboxes Offers

| Feature | Status |
|---------|--------|
| MicroVM isolation (Hyper-V/Virtualization.framework) | ‚úÖ |
| Private Docker daemon per sandbox | ‚úÖ |
| Filesystem isolation | ‚úÖ |
| Multi-agent support (Claude, Gemini, Codex) | ‚úÖ |

### The Deal-Breaker: No Localhost Access

From Docker's official documentation:
> *"Sandboxes also cannot access your host's localhost services. The VM boundary prevents direct access to services running on your host machine."*

This is a fundamental architectural limitation. Docker Sandboxes **cannot** connect to:
- ‚ùå Local PostgreSQL (`localhost:5432`)
- ‚ùå Local Redis (`localhost:6379`)
- ‚ùå Local dev servers (`localhost:3000`)

### Why This Matters

99% of developers run databases and services locally during development. Requiring them to migrate to cloud services or reconfigure everything just to use a sandbox is unacceptable friction.

Our philosophy is **"Remove friction for the common case."** Docker Sandboxes violates this by making the common case (local dev) impossible.

### Our Approach

GSD Secure uses **container isolation** instead of microVMs:
- ‚úÖ Localhost access works out-of-the-box (default mode)
- ‚úÖ Full network isolation available when needed (`--strict` mode)
- ‚úÖ Same file system protections as Docker Sandboxes
- ‚úÖ Works on Linux, macOS, and Windows

We trade some isolation (container vs VM) for **practical developer experience**.
