#!/usr/bin/env node
/**
 * V3 Runtime - Bundled functions for Claude Code execution
 * Generated by react-agentic (single-entry esbuild bundler)
 *
 * Usage: node runtime.js <functionName> '<jsonArgs>'
 */

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// tsx/commands/gsd/plan-phase.runtime.ts
import * as fs4 from "fs/promises";
import * as path4 from "path";

// tsx/helpers/config.ts
import * as fs from "fs/promises";
import * as path from "path";
var CONFIG_PATH = ".planning/config.json";
var DEFAULT_CONFIG = {
  mode: "interactive",
  depth: "standard",
  parallelization: true,
  commit_docs: true,
  model_profile: "balanced",
  workflow: {
    research: true,
    plan_check: true,
    verifier: true
  }
};
async function readConfig(basePath = process.cwd()) {
  try {
    const configPath = path.join(basePath, CONFIG_PATH);
    const content = await fs.readFile(configPath, "utf-8");
    const parsed = JSON.parse(content);
    return parsed;
  } catch {
    return null;
  }
}
__name(readConfig, "readConfig");
function getModelProfile(config) {
  return config?.model_profile ?? DEFAULT_CONFIG.model_profile;
}
__name(getModelProfile, "getModelProfile");
function getWorkflowSettings(config) {
  return config?.workflow ?? DEFAULT_CONFIG.workflow;
}
__name(getWorkflowSettings, "getWorkflowSettings");

// tsx/helpers/environment.ts
import * as fs2 from "fs/promises";
import * as path2 from "path";
async function exists(filePath) {
  try {
    await fs2.access(filePath);
    return true;
  } catch {
    return false;
  }
}
__name(exists, "exists");
async function planningExists(basePath = process.cwd()) {
  return exists(path2.join(basePath, ".planning"));
}
__name(planningExists, "planningExists");

// tsx/helpers/phase.ts
function normalizePhaseNumber(phase) {
  const str = String(phase);
  if (str.includes(".")) {
    const [intPart, decPart] = str.split(".");
    const normalizedInt = intPart.padStart(2, "0");
    return `${normalizedInt}.${decPart}`;
  }
  return str.padStart(2, "0");
}
__name(normalizePhaseNumber, "normalizePhaseNumber");
function parsePhaseNumber(phase) {
  const normalized = normalizePhaseNumber(phase);
  if (normalized.includes(".")) {
    const [intPart, decPart] = normalized.split(".");
    return {
      integer: parseInt(intPart, 10),
      decimal: parseInt(decPart, 10)
    };
  }
  return {
    integer: parseInt(normalized, 10)
  };
}
__name(parsePhaseNumber, "parsePhaseNumber");
function buildPhaseSlug(name, maxLength = 40) {
  return name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/--+/g, "-").replace(/^-|-$/g, "").slice(0, maxLength);
}
__name(buildPhaseSlug, "buildPhaseSlug");
function extractPhaseFromDirName(dirName) {
  const match = dirName.match(/^(\d{2}(?:\.\d+)?)-/);
  return match ? match[1] : null;
}
__name(extractPhaseFromDirName, "extractPhaseFromDirName");
function extractNameFromDirName(dirName) {
  const match = dirName.match(/^\d{2}(?:\.\d+)?-(.+)$/);
  return match ? match[1] : null;
}
__name(extractNameFromDirName, "extractNameFromDirName");
function comparePhaseNumbers(a, b) {
  const parsedA = parsePhaseNumber(a);
  const parsedB = parsePhaseNumber(b);
  if (parsedA.integer !== parsedB.integer) {
    return parsedA.integer - parsedB.integer;
  }
  const decA = parsedA.decimal ?? -1;
  const decB = parsedB.decimal ?? -1;
  return decA - decB;
}
__name(comparePhaseNumbers, "comparePhaseNumbers");

// tsx/helpers/files.ts
import * as fs3 from "fs/promises";
import * as path3 from "path";
var PHASES_DIR = ".planning/phases";
async function listPhaseDirectories(basePath = process.cwd()) {
  const phasesDir = path3.join(basePath, PHASES_DIR);
  try {
    const entries = await fs3.readdir(phasesDir, { withFileTypes: true });
    const phases = [];
    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      const phaseNum = extractPhaseFromDirName(entry.name);
      const phaseName = extractNameFromDirName(entry.name);
      if (phaseNum && phaseName) {
        phases.push({
          number: phaseNum,
          name: phaseName,
          slug: phaseName,
          directory: path3.join(phasesDir, entry.name)
        });
      }
    }
    return phases.sort((a, b) => comparePhaseNumbers(a.number, b.number));
  } catch {
    return [];
  }
}
__name(listPhaseDirectories, "listPhaseDirectories");
async function findPhaseDirectory(phase, basePath = process.cwd()) {
  const phases = await listPhaseDirectories(basePath);
  const normalized = phase.padStart(2, "0");
  return phases.find((p) => p.number === normalized || p.number.startsWith(`${normalized}.`)) ?? null;
}
__name(findPhaseDirectory, "findPhaseDirectory");
async function listPlanFiles(phaseDir) {
  try {
    const entries = await fs3.readdir(phaseDir);
    return entries.filter((e) => e.endsWith("-PLAN.md")).map((e) => path3.join(phaseDir, e)).sort();
  } catch {
    return [];
  }
}
__name(listPlanFiles, "listPlanFiles");
async function findResearchFile(phaseDir) {
  try {
    const entries = await fs3.readdir(phaseDir);
    const research = entries.find((e) => e.endsWith("-RESEARCH.md"));
    return research ? path3.join(phaseDir, research) : null;
  } catch {
    return null;
  }
}
__name(findResearchFile, "findResearchFile");
async function findContextFile(phaseDir) {
  try {
    const entries = await fs3.readdir(phaseDir);
    const context = entries.find((e) => e.endsWith("-CONTEXT.md"));
    return context ? path3.join(phaseDir, context) : null;
  } catch {
    return null;
  }
}
__name(findContextFile, "findContextFile");
async function readFileContent(filePath) {
  try {
    return await fs3.readFile(filePath, "utf-8");
  } catch {
    return null;
  }
}
__name(readFileContent, "readFileContent");
async function readStateFile(basePath = process.cwd()) {
  return readFileContent(path3.join(basePath, ".planning", "STATE.md"));
}
__name(readStateFile, "readStateFile");
async function readRoadmapFile(basePath = process.cwd()) {
  return readFileContent(path3.join(basePath, ".planning", "ROADMAP.md"));
}
__name(readRoadmapFile, "readRoadmapFile");

// tsx/helpers/frontmatter.ts
function parseFrontmatter(content) {
  const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n([\s\S]*)$/);
  if (!match) {
    return { frontmatter: null, body: content };
  }
  const yamlContent = match[1];
  const body = match[2];
  try {
    const frontmatter = parseSimpleYaml(yamlContent);
    return { frontmatter, body };
  } catch {
    return { frontmatter: null, body: content };
  }
}
__name(parseFrontmatter, "parseFrontmatter");
function parseSimpleYaml(yaml) {
  const result = {};
  const lines = yaml.split("\n");
  let currentKey = null;
  let currentArray = null;
  for (const line of lines) {
    if (!line.trim() || line.trim().startsWith("#")) continue;
    const arrayMatch = line.match(/^(\s*)-\s+(.*)$/);
    if (arrayMatch && currentKey && currentArray !== null) {
      const value = arrayMatch[2].trim();
      currentArray.push(parseYamlValue(value));
      continue;
    }
    const kvMatch = line.match(/^(\s*)([^:]+):\s*(.*)$/);
    if (kvMatch) {
      const indent = kvMatch[1].length;
      const key = kvMatch[2].trim();
      const rawValue = kvMatch[3].trim();
      if (currentKey && currentArray !== null) {
        result[currentKey] = currentArray;
        currentArray = null;
      }
      if (rawValue === "" || rawValue === "|" || rawValue === ">") {
        currentKey = key;
        currentArray = [];
      } else if (indent === 0) {
        currentKey = key;
        currentArray = null;
        result[key] = parseYamlValue(rawValue);
      }
    }
  }
  if (currentKey && currentArray !== null && currentArray.length > 0) {
    result[currentKey] = currentArray;
  }
  return result;
}
__name(parseSimpleYaml, "parseSimpleYaml");
function parseYamlValue(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  if (value === "true") return true;
  if (value === "false") return false;
  if (/^-?\d+(\.\d+)?$/.test(value)) {
    return parseFloat(value);
  }
  return value;
}
__name(parseYamlValue, "parseYamlValue");
function parsePlanFrontmatter(content) {
  const { frontmatter } = parseFrontmatter(content);
  return frontmatter;
}
__name(parsePlanFrontmatter, "parsePlanFrontmatter");

// tsx/commands/gsd/plan-phase.runtime.ts
function parseFlags(args) {
  return {
    research: args.includes("--research"),
    skipResearch: args.includes("--skip-research"),
    gaps: args.includes("--gaps"),
    skipVerify: args.includes("--skip-verify")
  };
}
__name(parseFlags, "parseFlags");
function resolveModels(profile) {
  const profiles = {
    quality: { researcher: "opus", planner: "opus", checker: "sonnet" },
    balanced: { researcher: "sonnet", planner: "opus", checker: "sonnet" },
    budget: { researcher: "haiku", planner: "sonnet", checker: "haiku" }
  };
  return profiles[profile] || profiles.balanced;
}
__name(resolveModels, "resolveModels");
var DEFAULT_AGENT_PATHS = {
  researcher: "~/.claude/agents/gsd-phase-researcher.md",
  planner: "~/.claude/agents/gsd-planner.md",
  checker: "~/.claude/agents/gsd-plan-checker.md"
};
function extractPhaseNumber(args) {
  const cleaned = args.replace(/--research/g, "").replace(/--skip-research/g, "").replace(/--gaps/g, "").replace(/--skip-verify/g, "").trim();
  const match = cleaned.match(/\b(\d+(?:\.\d+)?)\b/);
  return match ? match[1] : null;
}
__name(extractPhaseNumber, "extractPhaseNumber");
function extractPhaseFromRoadmap(roadmap, phaseId) {
  const phaseRegex = new RegExp(
    `Phase\\s+${phaseId.replace(".", "\\.")}:\\s*([^\\n]+)`,
    "i"
  );
  const nameMatch = roadmap.match(phaseRegex);
  if (!nameMatch) return null;
  const name = nameMatch[1].trim();
  const descRegex = new RegExp(
    `Phase\\s+${phaseId.replace(".", "\\.")}:[^\\n]*\\n([\\s\\S]*?)(?=\\n##\\s|\\nPhase\\s+\\d|$)`,
    "i"
  );
  const descMatch = roadmap.match(descRegex);
  const description = descMatch ? descMatch[1].trim() : "";
  return { name, description };
}
__name(extractPhaseFromRoadmap, "extractPhaseFromRoadmap");
async function findNextUnplannedPhase(roadmap) {
  const phaseMatches = roadmap.matchAll(/Phase\s+(\d+(?:\.\d+)?):/gi);
  for (const match of phaseMatches) {
    const phaseNum = match[1];
    const normalized = normalizePhaseNumber(phaseNum);
    const phaseInfo = await findPhaseDirectory(normalized);
    if (!phaseInfo) {
      return normalized;
    }
    const plans = await listPlanFiles(phaseInfo.directory);
    if (plans.length === 0) {
      return normalized;
    }
  }
  return null;
}
__name(findNextUnplannedPhase, "findNextUnplannedPhase");
async function init(args) {
  const errorCtx = /* @__PURE__ */ __name((error) => ({
    error,
    phaseId: "",
    phaseName: "",
    phaseDescription: "",
    phaseDir: "",
    hasResearch: false,
    hasPlans: false,
    planCount: 0,
    planFiles: [],
    needsResearch: false,
    flags: { research: false, skipResearch: false, gaps: false, skipVerify: false },
    models: { researcher: "sonnet", planner: "opus", checker: "sonnet" },
    modelProfile: "balanced",
    config: { workflowResearch: true, workflowPlanCheck: true },
    agentPaths: DEFAULT_AGENT_PATHS
  }), "errorCtx");
  if (!await planningExists()) {
    return errorCtx(".planning/ directory not found. Run /gsd:new-project first.");
  }
  const flags = parseFlags(args.arguments);
  const roadmap = await readRoadmapFile();
  if (!roadmap) {
    return errorCtx("ROADMAP.md not found or empty.");
  }
  let phaseId = extractPhaseNumber(args.arguments);
  if (!phaseId) {
    phaseId = await findNextUnplannedPhase(roadmap);
    if (!phaseId) {
      return errorCtx("Could not determine phase number. Specify phase or check roadmap.");
    }
  }
  phaseId = normalizePhaseNumber(phaseId);
  const phaseInfo = extractPhaseFromRoadmap(roadmap, phaseId);
  if (!phaseInfo) {
    const availablePhases = Array.from(roadmap.matchAll(/Phase\s+(\d+(?:\.\d+)?)/gi)).map((m) => m[1]).join(", ");
    return errorCtx(`Phase ${phaseId} not found in roadmap. Available: ${availablePhases}`);
  }
  let phaseDir = "";
  const existingPhase = await findPhaseDirectory(phaseId);
  if (existingPhase) {
    phaseDir = existingPhase.directory;
  } else {
    const slug = buildPhaseSlug(phaseInfo.name);
    phaseDir = `.planning/phases/${phaseId}-${slug}`;
    await fs4.mkdir(phaseDir, { recursive: true });
  }
  const researchFile = await findResearchFile(phaseDir);
  const planFiles = await listPlanFiles(phaseDir);
  const config = await readConfig();
  const workflowSettings = getWorkflowSettings(config);
  const modelProfile = getModelProfile(config);
  const hasResearch = researchFile !== null;
  let needsResearch = false;
  if (!flags.gaps && !flags.skipResearch) {
    if (workflowSettings.research) {
      if (flags.research || !hasResearch) {
        needsResearch = true;
      }
    }
  }
  return {
    phaseId,
    phaseName: phaseInfo.name,
    phaseDescription: phaseInfo.description,
    phaseDir,
    hasResearch,
    hasPlans: planFiles.length > 0,
    planCount: planFiles.length,
    planFiles,
    needsResearch,
    flags,
    models: resolveModels(modelProfile),
    modelProfile,
    config: {
      workflowResearch: workflowSettings.research,
      workflowPlanCheck: workflowSettings.plan_check
    },
    agentPaths: DEFAULT_AGENT_PATHS
  };
}
__name(init, "init");
async function checkExistingPlans(args) {
  const planFiles = await listPlanFiles(args.phaseDir);
  if (planFiles.length === 0) {
    return {
      hasPlans: false,
      planCount: 0,
      planFiles: [],
      planSummary: ""
    };
  }
  const summaryLines = [];
  for (const file of planFiles) {
    const content = await readFileContent(file);
    if (!content) continue;
    const basename3 = path4.basename(file, ".md");
    const frontmatter = parsePlanFrontmatter(content);
    const wave = frontmatter?.wave ?? 1;
    const objMatch = content.match(/##.*(?:objective|goal)[^\n]*\n([^\n]+)/i);
    const objective = objMatch ? objMatch[1].trim().slice(0, 50) + "..." : "-";
    summaryLines.push(`- ${basename3} (wave ${wave}): ${objective}`);
  }
  return {
    hasPlans: true,
    planCount: planFiles.length,
    planFiles,
    planSummary: summaryLines.join("\n")
  };
}
__name(checkExistingPlans, "checkExistingPlans");
async function buildResearcherPrompt(args) {
  const roadmap = await readRoadmapFile() ?? "";
  const requirements = await readFileContent(".planning/REQUIREMENTS.md") ?? "";
  const state = await readStateFile() ?? "";
  const contextFile = await findContextFile(args.phaseDir);
  const phaseContext = contextFile ? await readFileContent(contextFile) ?? "" : "";
  const decisionsMatch = state.match(/### Decisions Made[\s\S]*?(?=###|$)/);
  const decisions = decisionsMatch ? decisionsMatch[0] : "";
  const prompt = `<objective>
Research how to implement Phase ${args.phaseId}: ${args.phaseName}

Answer: "What do I need to know to PLAN this phase well?"
</objective>

<context>
**Phase description:**
${args.phaseDescription}

**Requirements (if any):**
${requirements.slice(0, 3e3)}

**Prior decisions:**
${decisions}

**Phase context (if any):**
${phaseContext}
</context>

<output>
Write research findings to: ${args.phaseDir}/${args.phaseId}-RESEARCH.md
</output>`;
  return {
    prompt,
    agentPath: args.agentPath
  };
}
__name(buildResearcherPrompt, "buildResearcherPrompt");
async function buildPlannerPrompt(args) {
  const state = await readStateFile() ?? "";
  const roadmap = await readRoadmapFile() ?? "";
  const requirements = await readFileContent(".planning/REQUIREMENTS.md") ?? "";
  const contextFile = await findContextFile(args.phaseDir);
  const context = contextFile ? await readFileContent(contextFile) ?? "" : "";
  const researchFile = await findResearchFile(args.phaseDir);
  const research = researchFile ? await readFileContent(researchFile) ?? "" : "";
  let verification = "";
  let uat = "";
  if (args.mode === "gap_closure") {
    verification = await readFileContent(`${args.phaseDir}/${args.phaseId}-VERIFICATION.md`) ?? "";
    uat = await readFileContent(`${args.phaseDir}/${args.phaseId}-UAT.md`) ?? "";
  }
  let currentPlans = "";
  if (args.mode === "revision") {
    const planFiles = await listPlanFiles(args.phaseDir);
    const plans = await Promise.all(planFiles.map((f) => readFileContent(f)));
    currentPlans = plans.filter(Boolean).join("\n\n---\n\n");
  }
  let prompt;
  if (args.mode === "revision") {
    prompt = `<revision_context>

**Phase:** ${args.phaseId}
**Mode:** revision

**Existing plans:**
${currentPlans}

**Checker issues:**
${args.issues?.map((issue, i) => `${i + 1}. ${issue}`).join("\n") || "None specified"}

</revision_context>

<instructions>
Make targeted updates to address checker issues.
Do NOT replan from scratch unless issues are fundamental.
Return what changed.
</instructions>`;
  } else {
    prompt = `<planning_context>

**Phase:** ${args.phaseId} - ${args.phaseName}
**Mode:** ${args.mode}

**Project State:**
${state}

**Roadmap:**
${roadmap}

**Requirements (if exists):**
${requirements}

**Phase Context (if exists):**
${context}

**Research (if exists):**
${research}

${args.mode === "gap_closure" ? `**Gap Closure:**
VERIFICATION.md:
${verification}

UAT.md:
${uat}
` : ""}
</planning_context>

<downstream_consumer>
Output consumed by /gsd:execute-phase
Plans must be executable prompts with:

- Frontmatter (wave, depends_on, files_modified, autonomous)
- Tasks in XML format
- Verification criteria
- must_haves for goal-backward verification
</downstream_consumer>

<quality_gate>
Before returning PLANNING COMPLETE:

- [ ] PLAN.md files created in phase directory
- [ ] Each plan has valid frontmatter
- [ ] Tasks are specific and actionable
- [ ] Dependencies correctly identified
- [ ] Waves assigned for parallel execution
- [ ] must_haves derived from phase goal
</quality_gate>`;
  }
  return {
    prompt,
    agentPath: args.agentPath
  };
}
__name(buildPlannerPrompt, "buildPlannerPrompt");
async function buildCheckerPrompt(args) {
  const planFiles = await listPlanFiles(args.phaseDir);
  const plans = await Promise.all(planFiles.map((f) => readFileContent(f)));
  const plansContent = plans.filter(Boolean).join("\n\n---\n\n");
  const requirements = await readFileContent(".planning/REQUIREMENTS.md") ?? "";
  const roadmap = await readRoadmapFile() ?? "";
  const goalRegex = new RegExp(`Phase\\s+${args.phaseId.replace(".", "\\.")}:[^\\n]*`, "i");
  const goalMatch = roadmap.match(goalRegex);
  const phaseGoal = goalMatch ? goalMatch[0] : `Phase ${args.phaseId}`;
  const prompt = `<verification_context>

**Phase:** ${args.phaseId}
**Phase Goal:** ${phaseGoal}

**Plans to verify:**
${plansContent}

**Requirements (if exists):**
${requirements}

</verification_context>

<expected_output>
Return one of:
- ## VERIFICATION PASSED \u2014 all checks pass
- ## ISSUES FOUND \u2014 structured issue list
</expected_output>`;
  return {
    prompt,
    phaseGoal
  };
}
__name(buildCheckerPrompt, "buildCheckerPrompt");
async function parseAgentStatus(args) {
  const output = args.output;
  if (output.includes("## RESEARCH COMPLETE") || output.includes("## PLANNING COMPLETE")) {
    return { status: "COMPLETE", message: "Agent completed successfully", issues: [] };
  }
  if (output.includes("## RESEARCH BLOCKED") || output.includes("## PLANNING BLOCKED")) {
    const blockerMatch = output.match(/## (?:RESEARCH|PLANNING) BLOCKED[:\s]*([^\n]+)?/);
    return {
      status: "BLOCKED",
      message: blockerMatch?.[1] || "Agent encountered a blocker",
      issues: []
    };
  }
  if (output.includes("## CHECKPOINT REACHED")) {
    const checkpointMatch = output.match(/## CHECKPOINT REACHED[:\s]*([^\n]+)?/);
    return {
      status: "CHECKPOINT",
      message: checkpointMatch?.[1] || "Checkpoint reached",
      issues: []
    };
  }
  if (output.includes("## PLANNING INCONCLUSIVE")) {
    return { status: "INCONCLUSIVE", message: "Planning was inconclusive", issues: [] };
  }
  if (output.includes("## VERIFICATION PASSED")) {
    return { status: "PASSED", message: "Verification passed", issues: [] };
  }
  if (output.includes("## ISSUES FOUND")) {
    const issuesSection = output.split("## ISSUES FOUND")[1] || "";
    const issueMatches = issuesSection.match(/[-*]\s+(.+)/g) || [];
    const issues = issueMatches.map((m) => m.replace(/^[-*]\s+/, "").trim());
    return {
      status: "ISSUES_FOUND",
      message: `Found ${issues.length} issue(s)`,
      issues
    };
  }
  return { status: "COMPLETE", message: "Agent completed (no explicit status)", issues: [] };
}
__name(parseAgentStatus, "parseAgentStatus");
async function readAndDisplayPlans(args) {
  const planFiles = await listPlanFiles(args.phaseDir);
  const plans = await Promise.all(planFiles.map(async (f) => {
    const content = await readFileContent(f);
    return `### ${path4.basename(f)}

${content || "(empty)"}`;
  }));
  return plans.join("\n\n---\n\n");
}
__name(readAndDisplayPlans, "readAndDisplayPlans");
async function archiveExistingPlans(args) {
  const planFiles = await listPlanFiles(args.phaseDir);
  const archiveDir = `${args.phaseDir}/archive`;
  await fs4.mkdir(archiveDir, { recursive: true });
  const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
  for (const file of planFiles) {
    const basename3 = path4.basename(file);
    await fs4.rename(file, `${archiveDir}/${timestamp}-${basename3}`);
  }
  return `Archived ${planFiles.length} plan(s) to ${archiveDir}`;
}
__name(archiveExistingPlans, "archiveExistingPlans");
async function generateSummary(args) {
  const planFiles = await listPlanFiles(args.phaseDir);
  const waves = [];
  for (const file of planFiles) {
    const content = await readFileContent(file);
    if (!content) continue;
    const frontmatter = parsePlanFrontmatter(content);
    const wave = typeof frontmatter?.wave === "number" ? frontmatter.wave : 1;
    const objMatch = content.match(/##.*(?:objective|goal)[^\n]*\n([^\n]+)/i);
    const objective = objMatch ? objMatch[1].trim() : "";
    const existing = waves.find((w) => w.wave === wave);
    const planName = path4.basename(file, ".md");
    if (existing) {
      existing.plans.push(planName);
      if (!existing.objective && objective) {
        existing.objective = objective;
      }
    } else {
      waves.push({ wave, plans: [planName], objective });
    }
  }
  waves.sort((a, b) => a.wave - b.wave);
  let research;
  if (args.skippedResearch) {
    research = "skipped";
  } else if (args.forcedResearch || !args.hasResearch) {
    research = "completed";
  } else {
    research = "existing";
  }
  let verification;
  if (args.skipVerify) {
    verification = "skipped";
  } else if (args.checkerPassed) {
    verification = "passed";
  } else {
    verification = "override";
  }
  return {
    phaseId: args.phaseId,
    phaseName: args.phaseName,
    planCount: planFiles.length,
    waveCount: waves.length,
    waves,
    research,
    verification
  };
}
__name(generateSummary, "generateSummary");
async function formatSummaryMarkdown(args) {
  const { summary } = args;
  const waveTable = summary.waves.map(
    (w) => `| ${w.wave} | ${w.plans.join(", ")} | ${w.objective || "-"} |`
  ).join("\n");
  const researchStatus = {
    completed: "Completed",
    existing: "Used existing",
    skipped: "Skipped"
  }[summary.research];
  const verificationStatus = {
    passed: "Passed",
    override: "Passed with override",
    skipped: "Skipped"
  }[summary.verification];
  return `
\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501
 GSD \u25BA PHASE ${summary.phaseId} PLANNED \u2713
\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501

**Phase ${summary.phaseId}: ${summary.phaseName}** \u2014 ${summary.planCount} plan(s) in ${summary.waveCount} wave(s)

| Wave | Plans | What it builds |
|------|-------|----------------|
${waveTable}

Research: ${researchStatus}
Verification: ${verificationStatus}

\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

## \u25B6 Next Up

**Execute Phase ${summary.phaseId}** \u2014 run all ${summary.planCount} plans

\`/gsd:execute-phase ${summary.phaseId}\`

<sub>/clear first \u2192 fresh context window</sub>

\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

**Also available:**
- cat .planning/phases/${summary.phaseId}-*/*-PLAN.md \u2014 review plans
- /gsd:plan-phase ${summary.phaseId} --research \u2014 re-research first

\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
`;
}
__name(formatSummaryMarkdown, "formatSummaryMarkdown");

// .generated/_runtime_entry.ts
var registry = {
  planPhase_init: init,
  planPhase_checkExistingPlans: checkExistingPlans,
  planPhase_buildResearcherPrompt: buildResearcherPrompt,
  planPhase_buildPlannerPrompt: buildPlannerPrompt,
  planPhase_buildCheckerPrompt: buildCheckerPrompt,
  planPhase_parseAgentStatus: parseAgentStatus,
  planPhase_readAndDisplayPlans: readAndDisplayPlans,
  planPhase_archiveExistingPlans: archiveExistingPlans,
  planPhase_generateSummary: generateSummary,
  planPhase_formatSummaryMarkdown: formatSummaryMarkdown
};


// ============================================================================
// CLI Entry Point
// ============================================================================

const [,, fnName, argsJson] = process.argv;

if (!fnName) {
  console.error('Usage: node runtime.js <functionName> <jsonArgs>');
  console.error('Available functions:', Object.keys(registry).join(', '));
  process.exit(1);
}

const fn = registry[fnName];
if (!fn) {
  console.error(`Unknown function: ${fnName}`);
  console.error('Available functions:', Object.keys(registry).join(', '));
  process.exit(1);
}

let args = {};
if (argsJson) {
  try {
    args = JSON.parse(argsJson);
  } catch (e) {
    console.error(`Invalid JSON args: ${e.message}`);
    process.exit(1);
  }
}

try {
  const result = await fn(args);
  console.log(JSON.stringify(result));
} catch (e) {
  console.error(`Function error: ${e.message}`);
  process.exit(1);
}
